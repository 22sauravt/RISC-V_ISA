{
    "instructions": [
        {
            "description": "AND",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "and",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "and.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "28" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := (RS) & (RB)"
            ],
            "body": [
                "The contents of register RS are ANDed with the con",
                "tents of register RB and the result is placed into register ",
                "RA.",
                "Some forms of and Rx, Rx, Rx provide special func",
                "tions; see Section10.3 of Book III."
            ]
        },
        {
            "description": "AND Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "andi.",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "28" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "RA := (RS) & (<sup>48</sup>0 || UI)"
            ],
            "body": [
                "The contents of register RS are ANDed with 480||UI ",
                "and the result is placed into register RA."
            ]
        },
        {
            "description": "AND Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "andis.",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "29" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "RA := (RS) & (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "The contents of register RS are ANDed with ",
                "320||UI||160 and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "AND with Complement",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "andc",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "andc.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "60" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := (RS) & ~(RB)"
            ],
            "body": [
                "The contents of register RS are ANDed with the comple",
                "ment of the contents of register RB and the result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Add",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "add",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "add.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "266" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "The sum (RA) + (RB) is placed into register RT."
            ]
        },
        {
            "description": "Add Carrying",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addc",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addc.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addco",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addco.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "10" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "The sum (RA) + (RB) is placed into register RT."
            ]
        },
        {
            "description": "Add Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "adde",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "adde.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addeo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addeo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "138" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := (RA) + (RB) + CA"
            ],
            "body": [
                "The sum (RA) + (RB) + CA is placed into register RT."
            ]
        },
        {
            "description": "Add Extended using alternate carry bit",
            "form": "Z23-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addex",
                    "regs": [ "RT,RA,RB,CY" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "CY", "size": "2" },
                { "name": "opcode", "size": "8", "value": "170" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if CY=0 then RT := (RA) + (RB) + OV"
            ],
            "body": [
                "For CY=0, the sum (RA) + (RB) + OV is placed into regis",
                "ter RT.",
                "For CY=0, OV is set to 1 if there is a carry out of bit 0 of ",
                "the sum in 64-bit mode or there is a carry out of bit 32 ",
                "of the sum in 32-bit mode, and set to 0 otherwise. OV32 ",
                "is set to 1 if there is a carry out of bit 32 bit of the sum.",
                "CY=1, CY=2, and CY=3 are reserved.",
                "  "
            ]
        },
        {
            "description": "Add Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addi",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "14" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "if “addi”  then",
                "   RT := (RA|0) + EXTS64(SI)",
                "if “paddi” & R=0 then",
                "   RT := (RA|0) + EXTS64(si0||si1)",
                "if “paddi” & R=1 then",
                "   RT := CIA + EXTS64(si0||si1)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For addi, let the sum of the contents of register RA, or ",
                "the value 0 if RA=0, and the value SI, sign-extended to ",
                "64 bits, is placed into register RT.",
                "For paddi with R=0, the sum of the contents of register ",
                "RA, or the value 0 if RA=0, and the value si0||si1, ",
                "sign-extended to 64 bits, is placed into register RT.",
                "For paddi with R=1, the sum of the address of the ",
                "instruction and the value si0||si1, sign-extended to 64 ",
                "bits, is placed into register RT.",
                "For paddi, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Examples of extended mnemonics for Add Immediate:",
                "Examples of extended mnemonics for Prefixed Add ",
                "Immediate:",
                "  "
            ]
        },
        {
            "description": "Prefixed Add Immediate",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "addi", "RT,", "RA,SI", ",R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "si0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "14" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "si1", "size": "16" }
            ],
            "code": [
                "if “addi”  then",
                "   RT := (RA|0) + EXTS64(SI)",
                "if “paddi” & R=0 then",
                "   RT := (RA|0) + EXTS64(si0||si1)",
                "if “paddi” & R=1 then",
                "   RT := CIA + EXTS64(si0||si1)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For addi, let the sum of the contents of register RA, or ",
                "the value 0 if RA=0, and the value SI, sign-extended to ",
                "64 bits, is placed into register RT.",
                "For paddi with R=0, the sum of the contents of register ",
                "RA, or the value 0 if RA=0, and the value si0||si1, ",
                "sign-extended to 64 bits, is placed into register RT.",
                "For paddi with R=1, the sum of the address of the ",
                "instruction and the value si0||si1, sign-extended to 64 ",
                "bits, is placed into register RT.",
                "For paddi, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Examples of extended mnemonics for Add Immediate:",
                "Examples of extended mnemonics for Prefixed Add ",
                "Immediate:",
                "  "
            ]
        },
        {
            "description": "Add Immediate Carrying",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addic",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "12" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA) + SI is placed into register RT.",
                "Example of extended mnemonics for Add Immediate ",
                "Carrying:"
            ]
        },
        {
            "description": "Add Immediate Carrying and Record",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addic.",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "13" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA) + SI is placed into register RT.",
                "Example of extended mnemonics for Add Immediate ",
                "Carrying and Record:"
            ]
        },
        {
            "description": "Add Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addis",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "15" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "if RA = 0 then RT := EXTS(SI || <sup>16</sup>0)",
                "else           RT := (RA) + EXTS(SI || <sup>16</sup>0)"
            ],
            "body": [
                "The sum (RA|0) + (SI||0x0000) is placed into regis",
                "ter RT.",
                "Examples of extended mnemonics for Add Immediate ",
                "Shifted:"
            ]
        },
        {
            "description": "Add PC Immediate Shifted",
            "form": "DX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addpcis",
                    "regs": [ "RT,D" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "RT", "size": "5" },
                { "name": "d1", "size": "5" },
                { "name": "d0", "size": "10" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "d2", "size": "1" }
            ],
            "code": [
                "D := d0||d1||d2",
                "RT := NIA + EXTS(D || <sup>16</sup>0)"
            ],
            "body": [
                "The sum of NIA + (D||0x0000) is placed into register ",
                "RT. ",
                "Examples of extended mnemonics for Add PC Immedi",
                "ate Shifted:"
            ]
        },
        {
            "description": "Add and Generate Sixes",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addg6s",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "74" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "do i = 0 to 15",
                "   dc<sub>i</sub> := carry_out(RA<sub>4xi:63</sub> + RB<sub>4xi:63</sub>)",
                "c := <sup>4</sup>(dc<sub>0</sub>) || <sup>4</sup>(dc<sub>1</sub>) || ... || <sup>4</sup>(dc<sub>15</sub>)",
                "RT := (~c) & 0x6666_6666_6666_6666"
            ],
            "body": [
                "The contents of register RA are added to the contents of ",
                "register RB. Sixteen carry bits are produced, one for ",
                "each carry out of decimal position n (bit position 4xn).",
                "A doubleword is composed from the 16 carry bits, and ",
                "placed into RT. The doubleword consists of a decimal ",
                "six (0b0110) in every decimal digit position for which the ",
                "corresponding carry bit is 0, and a zero (0b0000) in ",
                "every position for which the corresponding carry bit is ",
                "1.",
                "  ",
                "",
                ""
            ]
        },
        {
            "description": "Add to Minus One Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addme",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addme.",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addmeo",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addmeo.",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "234" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := (RA) + CA - 1"
            ],
            "body": [
                "The sum (RA) + CA + 641 is placed into register RT."
            ]
        },
        {
            "description": "Add to Zero Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addze",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addze.",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addzeo",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addzeo.",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "202" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := (RA) + CA"
            ],
            "body": [
                "The sum (RA) + CA is placed into register RT."
            ]
        },
        {
            "description": "Bit Permute Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "bpermd",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "252" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "do i = 0 to 7",
                "   index := (RS)<sub>8*i:8*i+7</sub>",
                "   If index < 64",
                "      then perm<sub>i</sub> := (RB)<sub>index</sub>",
                "      else perm<sub>i</sub> := 0",
                "RA := <sup>56</sup>0 || perm<sub>0:7</sub>"
            ],
            "body": [
                "Eight permuted bits are produced. For each permuted ",
                "bit i where i ranges from 0 to 7 and for each byte i of ",
                "RS, do the following.",
                "The permuted bits are placed in the least-significant ",
                "byte of RA, and the remaining bits are filled with 0s.",
                "  "
            ]
        },
        {
            "description": "Branch",
            "form": "I-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "b",
                    "regs": [ "target_addr", "(AA=0 LK=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "ba",
                    "regs": [ "target_addr", "(AA=1 LK=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bl",
                    "regs": [ "target_addr", "(AA=0 LK=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "bla",
                    "regs": [ "target_addr", "(AA=1 LK=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "18" },
                { "name": "LI", "size": "24" },
                { "name": "AA", "size": "1" },
                { "name": "LK", "size": "1" }
            ],
            "code": [
                "if AA then NIA :=<sub>iea</sub> EXTS(LI || 0b00)",
                "else       NIA :=<sub>iea</sub> CIA + EXTS(LI || 0b00)",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "target_addr specifies the branch target address.",
                "If AA=0 then the branch target address is the sum of ",
                "LI||0b00 sign-extended and the address of this ",
                "instruction, with the high-order 32 bits of the branch tar",
                "get address set to 0 in 32-bit mode.",
                "If AA=1 then the branch target address is the value ",
                "LI||0b00 sign-extended, with the high-order 32 bits of ",
                "the branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register."
            ]
        },
        {
            "description": "Branch Conditional",
            "form": "B-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "bc",
                    "regs": [ "BO,BI,target_addr", "(AA=0 LK=0)", "bca", "BO,BI,target_addr", "(AA=1 LK=0)", "bcl", "BO,BI,target_addr", "(AA=0 LK=1)", "bcla", "BO,BI,target_addr", "(AA=1 LK=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "16" },
                { "name": "BO", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "BD", "size": "14" },
                { "name": "AA", "size": "1" },
                { "name": "LK", "size": "1" }
            ],
            "code": [
                "if (64-bit mode)",
                "   then M := 0",
                "   else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>)",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok & cond_ok then",
                "   if AA then NIA :=<sub>iea</sub> EXTS(BD || 0b00)",
                "   else       NIA :=<sub>iea</sub> CIA + EXTS(BD || 0b00)",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. target_addr specifies the branch target ",
                "address.",
                "If AA=0 then the branch target address is the sum of ",
                "BD||0b00 sign-extended and the address of this ",
                "instruction, with the high-order 32 bits of the branch tar",
                "get address set to 0 in 32-bit mode.",
                "If AA=1 then the branch target address is the value ",
                "BD||0b00 sign-extended, with the high-order 32 bits of ",
                "the branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "Examples of extended mnemonics for Branch Condi",
                "tional:"
            ]
        },
        {
            "description": "Branch Conditional to Branch Target Address Register",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "bctar",
                    "regs": [ "BO,BI,BH", "(LK=0)", "bctarl", "BO,BI,BH", "(LK=1)" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BO", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "BH", "size": "2" },
                { "name": "opcode", "size": "9", "value": "560" },
                { "name": "LK", "size": "1" }
            ],
            "code": [
                "if (64-bit mode)",
                "   then M := 0",
                "   else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok & cond_ok then NIA :=<sub>iea</sub> TAR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. The BH field is used as described in ",
                "Figure44. The branch target address is ",
                "TAR<sub>0:61</sub>||0b00, with the high-order 32 bits of the ",
                "branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "  ",
                ""
            ]
        },
        {
            "description": "Branch Conditional to Count Register",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "bcctr",
                    "regs": [ "BO,BI,BH", "(LK=0)", "bcctrl", "BO,BI,BH", "(LK=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BO", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "BH", "size": "2" },
                { "name": "opcode", "size": "9", "value": "528" },
                { "name": "LK", "size": "1" }
            ],
            "code": [
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if cond_ok then NIA :=<sub>iea</sub> CTR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. The BH field is used as described in ",
                "Figure44. The branch target address is ",
                "CTR<sub>0:61</sub>||0b00, with the high-order 32 bits of the ",
                "branch target address set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "If the “decrement and test CTR” option is specified ",
                "(BO<sub>2</sub>=0), the instruction form is invalid.",
                "Examples of extended mnemonics for Branch Condi",
                "tional to Count Register."
            ]
        },
        {
            "description": "Branch Conditional to Link Register",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "bclr",
                    "regs": [ "BO,BI,BH", "(LK=0)", "bclrl", "BO,BI,BH", "(LK=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BO", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "BH", "size": "2" },
                { "name": "opcode", "size": "9", "value": "16" },
                { "name": "LK", "size": "1" }
            ],
            "code": [
                "if (64-bit mode)",
                "   then M := 0",
                "   else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok & cond_ok then NIA :=<sub>iea</sub> LR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "BI+32 specifies the Condition Register bit to be tested. ",
                "The BO field is used to resolve the branch as described ",
                "in Figure42. The BH field is used as described in ",
                "Figure44. The branch target address is LR<sub>0:61</sub>||0b00, ",
                "with the high-order 32 bits of the branch target address ",
                "set to 0 in 32-bit mode.",
                "If LK=1 then the effective address of the instruction fol",
                "lowing the Branch instruction is placed into the Link ",
                "Register.",
                "Examples of extended mnemonics for Branch Condi",
                "tional to Link Register:",
                "  "
            ]
        },
        {
            "description": "Byte-Reverse Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "brd",
                    "regs": [ "RA,RS" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "187" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> ||",
                "RA := (RS)<sub>40:47</sub> || (RS)<sub>32:39 </sub>||",
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7</sub>"
            ],
            "body": [
                "The contents of register RS are placed into register RA in ",
                "byte-reversed order."
            ]
        },
        {
            "description": "Byte-Reverse Halfword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "brh",
                    "regs": [ "RA,RS" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "219" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7  </sub> ||",
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "RA := (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub> ||",
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>"
            ],
            "body": [
                "The contents of bits 0:15 of register RS are placed into ",
                "bits 0:15 of register RA in byte-reversed order.",
                "The contents of bits 16:31 of register RS are placed into ",
                "bits 16:31 of register RA in byte-reversed order.",
                "The contents of bits 32:47 of register RS are placed into ",
                "bits 32:47 of register RA in byte-reversed order.",
                "The contents of bits 48:63 of register RS are placed into ",
                "bits 48:63 of register RA in byte-reversed order."
            ]
        },
        {
            "description": "Byte-Reverse Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "brw",
                    "regs": [ "RA,RS" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "155" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7  </sub> ||",
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> ||",
                "RA := (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub>"
            ],
            "body": [
                "The contents of bits 0:31 of register RS are placed into ",
                "bits 0:31 of register RA in byte-reversed order.",
                "The contents of bits 32:63 of register RS are placed into ",
                "bits 32:63 of register RA in byte-reversed order."
            ]
        },
        {
            "description": "Centrifuge Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cfuged",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "220" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "ptr0 := 0",
                "ptr1 := 0",
                "do i = 0 to 63",
                "   if((RB)<sub>i</sub>=0) then do",
                "      result<sub>ptr0</sub> := (RS)<sub>i</sub>",
                "      ptr0 := ptr0 + 1",
                "   end",
                "   if((RB)<sub>63-i</sub>==1) then do",
                "      result<sub>63-ptr1</sub> := (RS)<sub>63-i</sub>",
                "      ptr1 := ptr1 + 1",
                "   end",
                "end",
                "RA := result"
            ],
            "body": [
                "The bits in GPR[RS] whose corresponding bits in the ",
                "mask in GPR[RB] equal 1 are placed in the rightmost ",
                "bits in GPR[RA] maintaining their relative original order.  ",
                "The other bits in GPR[RS] are placed in the leftmost bits ",
                "in GPR[RA] maintaining their relative original order."
            ]
        },
        {
            "description": "Compare",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmp",
                    "regs": [ "BF,L,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "L", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "0" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)<sub>32:63</sub>)",
                "              b := EXTS((RB)<sub>32:63</sub>)",
                "         else a := (RA)",
                "              b := (RB)",
                "if      a < b then c := 0b100",
                "else if a > b then c := 0b010",
                "else               c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> if L=0) are com",
                "pared with the contents of register RB ((RB)<sub>32:63</sub> if L=0), ",
                "treating the operands as signed integers. The result of ",
                "the comparison is placed into CR field BF",
                ".",
                "Examples of extended mnemonics for Compare:"
            ]
        },
        {
            "description": "Compare Bytes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpb",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "508" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "do n = 0 to 7 ",
                "   if RS<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> = (RB)<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> then ",
                "      RA<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> := 81",
                "   else ",
                "      RA<sub>8</sub><sub>*</sub><sub>n:8</sub><sub>*</sub><sub>n+7</sub> := 80"
            ],
            "body": [
                "Each byte of the contents of register RS is compared to ",
                "each corresponding byte of the contents in register RB. ",
                "If they are equal, the corresponding byte in RA is set to ",
                "0xFF. Otherwise the corresponding byte in RA is set to ",
                "0x00."
            ]
        },
        {
            "description": "Compare Equal Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpeqb",
                    "regs": [ "BF,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "224" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "src1 := GPR[RA].bit[56:63]",
                "",
                "match := (src1 = (RB)<sub>00:07</sub>) |",
                "match := (src1 = (RB)<sub>08:15</sub>) |",
                "match := (src1 = (RB)<sub>16:23</sub>) |",
                "match := (src1 = (RB)<sub>24:31</sub>) |",
                "match := (src1 = (RB)<sub>32:39</sub>) |",
                "match := (src1 = (RB)<sub>40:47</sub>) |",
                "match := (src1 = (RB)<sub>48:55</sub>) |",
                "match := (src1 = (RB)<sub>56:63</sub>)",
                "",
                "CR<sub>4×BF+32:4×BF+35</sub> := 0b0 || match || 0b00"
            ],
            "body": [
                "CR field BF is set to indicate if the contents of bits 56:63 ",
                "of register RA are equal to the contents of any of the 8 ",
                "bytes in register RB.",
                "Results are undefined in 32-bit mode.",
                ""
            ]
        },
        {
            "description": "Compare Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpi",
                    "regs": [ "BF,L,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "11" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "L", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)<sub>32:63</sub>)",
                "         else a := (RA)",
                "if      a < EXTS(SI) then c := 0b100",
                "else if a > EXTS(SI) then c := 0b010",
                "else                      c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> sign-extended to ",
                "64 bits if L=0) are compared with the sign-extended ",
                "value of the SI field, treating the operands as signed ",
                "integers. The result of the comparison is placed into CR ",
                "field BF.",
                "Examples of extended mnemonics for Compare Imme",
                "diate:"
            ]
        },
        {
            "description": "Compare Logical",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpl",
                    "regs": [ "BF,L,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "L", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "32" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if L = 0 then a := <sup>32</sup>0 || (RA)<sub>32:63</sub>",
                "              b := <sup>32</sup>0 || (RB)<sub>32:63</sub>",
                "         else a := (RA)",
                "              b := (RB)",
                "if      a <<sup>u</sup> b then c := 0b100",
                "else if a ><sup>u</sup> b then c := 0b010",
                "else                c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> if L=0) are com",
                "pared with the contents of register RB ((RB)<sub>32:63</sub> if L=0), ",
                "treating the operands as unsigned integers. The result ",
                "of the comparison is placed into CR field BF",
                ".",
                "Examples of extended mnemonics for Compare Logi",
                "cal:"
            ]
        },
        {
            "description": "Compare Logical Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpli",
                    "regs": [ "BF,L,RA,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "10" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "L", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "if L = 0 then a := <sup>32</sup>0 || (RA)<sub>32:63</sub>",
                "         else a := (RA)",
                "if      a <<sup>u</sup> (<sup>48</sup>0 || UI) then c := 0b100",
                "else if a ><sup>u</sup> (<sup>48</sup>0 || UI) then c := 0b010",
                "else                         c := 0b001",
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := c || XER<sub>SO</sub>",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)<sub>32:63</sub> zero-extended to ",
                "64 bits if L=0) are compared with 480||UI, treating the ",
                "operands as unsigned integers. The result of the com",
                "parison is placed into CR field BF",
                ".",
                "Examples of extended mnemonics for Compare Logical ",
                "Immediate:"
            ]
        },
        {
            "description": "Compare Ranged Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmprb",
                    "regs": [ "BF,L,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "L", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "192" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "src1    := EXTZ((RA)<sub>56:63</sub>)",
                "",
                "src21hi := EXTZ((RB)<sub>32:39</sub>)",
                "src21lo := EXTZ((RB)<sub>40:47</sub>)",
                "src22hi := EXTZ((RB)<sub>48:55</sub>)",
                "src22lo := EXTZ((RB)<sub>56:63</sub>)",
                "",
                "if L=0 then",
                "   in_range :=  (src22lo <= src1) & (src1 <= src22hi)",
                "else",
                "   in_range := ((src21lo <= src1) & (src1 <= src21hi)) |",
                "   in_range := ((src22lo <= src1) & (src1 <= src22hi))",
                "",
                "CR<sub>4×BF+32:4×BF+35</sub> := 0b0 || in_range || 0b00"
            ],
            "body": [
                "Let src1 be the unsigned integer value in bits 56:63 of ",
                "register RA.",
                "Let src21hi be the unsigned integer value in bits 32:39 ",
                "of register RB.",
                "Let src21lo be the unsigned integer value in bits 40:47 ",
                "of register RB.",
                "Let src22hi be the unsigned integer value in bits 48:55 ",
                "of register RB.",
                "Let src22lo be the unsigned integer value in bits 56:63 ",
                "of register RB.",
                "Let x be considered “in range” of y:z if the value x is ",
                "greater than or equal to the value y and the value x is ",
                "less than or equal to the value z.",
                "When L=0, the value in_range is set to 1 if src1 is in ",
                "range of src22lo:src22hi. Otherwise, the value ",
                "in_range is set to 0.",
                "When L=1, the value in_range is set to 1 if either src1 ",
                "is in range of src21lo:src21hi, or src1 is in range of ",
                "src22lo:src22hi. Otherwise, the value in_range is set ",
                "to 0.",
                "CR field BF is set to the value 0b0 concatenated with ",
                "in_range concatenated with 0b00. ",
                ""
            ]
        },
        {
            "description": "Condition Register AND",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "crand",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "257" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> & CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ANDed with the bit in the Condition Register specified ",
                "by BB+32, and the result is placed into the bit in the ",
                "Condition Register specified by BT+32."
            ]
        },
        {
            "description": "Condition Register AND with Complement",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "crandc",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "129" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> & ~CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ANDed with the complement of the bit in the Condition ",
                "Register specified by BB+32, and the result is placed ",
                "into the bit in the Condition Register specified by ",
                "BT+32."
            ]
        },
        {
            "description": "Condition Register Equivalent",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "creqv",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "289" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> == CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "XORed with the bit in the Condition Register specified ",
                "by BB+32, and the complemented result is placed into ",
                "the bit in the Condition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter Equivalent:"
            ]
        },
        {
            "description": "Condition Register NAND",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "crnand",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "225" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := ~(CR<sub>BA+32</sub> & CR<sub>BB+32</sub>)"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ANDed with the bit in the Condition Register specified ",
                "by BB+32, and the complemented result is placed into ",
                "the bit in the Condition Register specified by BT+32."
            ]
        },
        {
            "description": "Condition Register NOR",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "crnor",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "33" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := ~(CR<sub>BA+32</sub> | CR<sub>BB+32</sub>)"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ORed with the bit in the Condition Register specified by ",
                "BB+32, and the complemented result is placed into the ",
                "bit in the Condition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter NOR:"
            ]
        },
        {
            "description": "Condition Register OR",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "cror",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "449" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> | CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ORed with the bit in the Condition Register specified by ",
                "BB+32, and the result is placed into the bit in the Con",
                "dition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter OR:"
            ]
        },
        {
            "description": "Condition Register OR with Complement",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "crorc",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "417" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> | ~CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "ORed with the complement of the bit in the Condition ",
                "Register specified by BB+32, and the result is placed ",
                "into the bit in the Condition Register specified by ",
                "BT+32."
            ]
        },
        {
            "description": "Condition Register XOR",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "crxor",
                    "regs": [ "BT,BA,BB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BT", "size": "5" },
                { "name": "BA", "size": "5" },
                { "name": "BB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "193" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> ^ CR<sub>BB+32</sub>"
            ],
            "body": [
                "The bit in the Condition Register specified by BA+32 is ",
                "XORed with the bit in the Condition Register specified ",
                "by BB+32, and the result is placed into the bit in the ",
                "Condition Register specified by BT+32.",
                "Example of extended mnemonics for Condition Regis",
                "ter XOR:"
            ]
        },
        {
            "description": "Convert Binary Coded Decimal To Declets",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cbcdtd",
                    "regs": [ "RA, RS" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "314" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "do i = 0 to 1",
                "   n := i x 32",
                "RA<sub>n+0:n+11  </sub>:= 0 ",
                "RA<sub>n+12:n+21 </sub>:= BCD_TO_DPD((RS)<sub>n+8:n+19</sub>) ",
                "RA<sub>n+22:n+31 </sub>:= BCD_TO_DPD((RS)<sub>n+20:n+31</sub>)"
            ],
            "body": [
                "The low-order 24 bits of each word of register RS con",
                "tain six, 4-bit BCD fields which are converted to two ",
                "declets; each set of two declets is placed into the ",
                "low-order 20 bits of the corresponding word in RA. The ",
                "high-order 12 bits in each word of RA are set to 0.",
                "If a 4-bit BCD field has a value greater than 9 the ",
                "results are undefined."
            ]
        },
        {
            "description": "Convert Declets To Binary Coded Decimal",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cdtbcd",
                    "regs": [ "RA, RS" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "282" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "do i = 0 to 1",
                "   n := i x 32",
                "RA<sub>n+0:n+7  </sub> := 0 ",
                "RA<sub>n+8:n+19  </sub>:= DPD_TO_BCD((RS)<sub>n+12:n+21</sub>)",
                "RA<sub>n+20:n+31 </sub>:= DPD_TO_BCD((RS)<sub>n+22:n+31</sub>)"
            ],
            "body": [
                "The low-order 20 bits of each word of register RS con",
                "tain two declets which are converted to six, 4-bit BCD ",
                "fields; each set of six, 4-bit BCD fields is placed into the ",
                "low-order 24 bits of the corresponding word in RA. The ",
                "high-order 8 bits in each word of RA are set to 0."
            ]
        },
        {
            "description": "Count Leading Zeros Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cntlzd",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "cntlzd.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "58" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := 0",
                "do while n < 64",
                "  if (RS)<sub>n</sub> = 1 then leave",
                "  n := n + 1",
                "RA := n"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 0 of register RS is placed into register RA. This ",
                "number ranges from 0 to 64, inclusive.",
                "If Rc=1, CR Field 0 is set to reflect the result."
            ]
        },
        {
            "description": "Count Leading Zeros Doubleword under bit Mask",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cntlzdm",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "59" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "count = 0",
                "do i = 0 to 63",
                "   if((RB)<sub>i</sub>=1) then do",
                "      if((RS)<sub>i</sub>=1) then break",
                "      count := count + 1",
                "   end",
                "end",
                "RA := EXTZ64(count)"
            ],
            "body": [
                "Let n be the number of bits in register RB having the ",
                "value 1.",
                "Extract and pack together the contents of the bits in ",
                "register RS corresponding to a mask specified in ",
                "register RB, creating an n-bit value. ",
                "Count the number of contiguous leftmost 0 bits in the ",
                "n-bit extracted value and place the result into register ",
                "RA."
            ]
        },
        {
            "description": "Count Leading Zeros Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cntlzw",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "cntlzw.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "26" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := 32",
                "",
                "do while n < 64",
                "   if (RS)<sub>n</sub> = 1 then leave",
                "   n := n + 1",
                "",
                "RA := n - 32"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 32 of register RS is placed into register RA. This ",
                "number ranges from 0 to 32, inclusive.",
                "If Rc is equal to 1, CR field 0 is set to reflect the result.",
                "  "
            ]
        },
        {
            "description": "Count Trailing Zeros Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cnttzd",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "cnttzd.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "570" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n  := 0",
                "do while n < 64",
                "   if (RS)<sub>63-n</sub> = 0b1 then leave ",
                "   n  := n + 1",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 63 of register RS is placed into register RA. This ",
                "number ranges from 0 to 64, inclusive.",
                "If Rc is equal to 1, CR field 0 is set to reflect the result."
            ]
        },
        {
            "description": "Count Trailing Zeros Doubleword under bit Mask",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cnttzdm",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "571" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "count := 0",
                "do i = 0 to 63",
                "   if((RB)<sub>63-i</sub>=1) then do",
                "      if((RS)<sub>63-i</sub>=1) then break",
                "      count := count + 1",
                "   end",
                "end",
                "RA := EXTZ64(count)"
            ],
            "body": [
                "Let n be the number of bits in register RB having the ",
                "value 1.",
                "Extract and pack together the contents of bits in ",
                "register RS corresponding to a mask specified in ",
                "register RB, creating an n-bit value. ",
                "Count the number of contiguous rightmost 0 bits in the ",
                "n-bit extracted value and place the result into register ",
                "RA."
            ]
        },
        {
            "description": "Count Trailing Zeros Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cnttzw",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "cnttzw.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "538" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := 0",
                "",
                "do while n < 32",
                "   if (RS)<sub>63-n</sub> = 0b1 then leave ",
                "   n  := n + 1",
                "",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 63 of the rightmost word of register RS is placed ",
                "into register RA. This number ranges from 0 to 32, ",
                "inclusive.",
                "If Rc is equal to 1, CR field 0 is set to reflect the result."
            ]
        },
        {
            "description": "DFP Add",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dadd",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "2" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Add Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "daddq",
                    "regs": [ "FRTp,FRAp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "2" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRA[p] is added to the DFP oper",
                "and in FRB[p].  ",
                "The result is rounded to the target-format precision ",
                "under control of  DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the smaller exponent of the two ",
                "source operands. ",
                "Figure80 summarizes the actions for Add.  Figure80 ",
                "does not include the setting of FPRF. FPRF is always set ",
                "to the class and sign of the result, except for an ",
                "enabled invalid-operation exception, in which case the ",
                "field remains unchanged.",
                "dadd[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Compare Ordered",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcmpo",
                    "regs": [ "BF,FRA,FRB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "130" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Compare Ordered Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcmpoq",
                    "regs": [ "BF,FRAp,FRBp" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "130" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRA[p] is compared to the DFP ",
                "operand in FRB[p].  The result of the compare is placed ",
                "into CR field BF and the FPCC.",
                "dcmpo[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "DFP Compare Unordered",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcmpu",
                    "regs": [ "BF,FRA,FRB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "642" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Compare Unordered Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcmpuq",
                    "regs": [ "BF,FRAp,FRBp" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "642" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRA[p] is compared to the DFP ",
                "operand in FRB[p].  The result of the compare is placed ",
                "into CR field BF and the FPCC.",
                "dcmpu[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "DFP Convert From Fixed",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcffix",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "802" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 64-bit signed binary integer in FRB is converted ",
                "and rounded to a DFP Long value and placed into FRT.  ",
                "The sign of the result is the same as the sign of the ",
                "source operand.  The ideal exponent is zero.",
                "If the source operand is a zero, then a plus zero with a ",
                "zero exponent is returned.",
                "FPRF is set to the class and sign of the result.",
                "dcffix[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert From Fixed Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcffixq",
                    "regs": [ "FRTp,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "802" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 64-bit signed binary integer in FRB is converted ",
                "and rounded to a DFP Extended value and placed into ",
                "FRTp. The sign of the result is the same as the sign of ",
                "the source operand. The ideal exponent is zero.",
                "If the source operand is a zero, then a plus zero with a ",
                "zero exponent is returned.",
                "FPRF is set to the class and sign of the result.",
                "dcffixq[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert From Fixed Quadword Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dcffixqq",
                    "regs": [ "FRTp,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "994" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 128-bit signed binary integer in VRB is converted ",
                "and rounded to a DFP Extended value and placed into ",
                "FRTp. The sign of the result is the same as the sign of ",
                "the source operand. The ideal exponent is zero.",
                "If the source operand is a zero, then a plus zero with a ",
                "zero exponent is returned.",
                "FPRF is set to the class and sign of the result.",
                "dcffixqq is treated as a Floating-Point and a Vector ",
                "instruction in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To DFP Extended",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dctqpq",
                    "regs": [ "FRTp,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "258" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP long operand in the FRB is converted to DFP ",
                "extended format and placed into FRTp. The sign of the ",
                "result is the same as the sign of the operand in FRB. ",
                "The ideal exponent is the exponent of the operand in ",
                "FRB.",
                "If the operand in FRB is an SNaN, an invalid-operation ",
                "exception is recognized. If the exception is disabled, ",
                "the SNaN is converted to the corresponding QNaN in ",
                "DFP extended format.",
                "dctqpq[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To DFP Long",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dctdp",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "258" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP short operand in bits 32:63 of FRB is ",
                "converted to DFP long format and the converted result ",
                "is placed into FRT. The sign of the result is the same as ",
                "the sign of the source operand. The ideal exponent is ",
                "the exponent of the source operand.",
                "If the operand in FRB is an SNaN, it is converted to an ",
                "SNaN in DFP long format and does not cause an ",
                "invalid-operation exception.",
                "dctdp[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To Fixed",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dctfix",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "290" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Convert To Fixed Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dctfixq",
                    "regs": [ "FRT,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "290" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRB[p] is rounded to an integer ",
                "value and is placed into FRT in the 64-bit signed binary ",
                "integer format.  The sign of the result is the same as ",
                "the sign of the source operand, except when the ",
                "source operand is a NaN or a zero.",
                "Figure96 summarizes the actions for Convert To ",
                "Fixed.",
                "dctfix[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Convert To Fixed Quadword Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dctfixqq",
                    "regs": [ "VRT,FRBp" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "994" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRBp is rounded to an integer ",
                "value and is placed into VRT in the 128-bit signed ",
                "binary integer format. The sign of the result is the ",
                "same as the sign of the source operand, except when ",
                "the source operand is a NaN or a zero.",
                "Figure 96 summarizes the actions for Convert To ",
                "Fixed.",
                "dctfixqq is treated as a Floating-Point and a Vector ",
                "instruction in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Decode DPD To BCD",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "ddedpd",
                    "regs": [ "SP,FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "SP", "size": "2" },
                { "name": "reserved", "size": "3" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "322" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Decode DPD To BCD Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "ddedpdq",
                    "regs": [ "SP,FRTp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "SP", "size": "2" },
                { "name": "reserved", "size": "3" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "322" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "A portion of the significand of the DFP operand in ",
                "FRB[p] is converted to a signed or unsigned BCD ",
                "number depending on the SP field. For infinity and ",
                "NaN, the significand is considered to be the contents ",
                "in the trailing significand field padded on the left by a ",
                "zero digit.",
                "ddedpd[q][.] are treated as Floating-Point instructions ",
                "in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Divide",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "ddiv",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "546" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Divide Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "ddivq",
                    "regs": [ "FRTp,FRAp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "546" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRA[p] is divided by the DFP ",
                "operand in FRB[p].  ",
                "The result is rounded to the target-format precision ",
                "under control of the DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the difference of subtracting the ",
                "exponent of the divisor from the exponent of the ",
                "dividend.",
                "Figure82 summarizes the actions for Divide.  ",
                "Figure82 does not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except ",
                "for an enabled invalid-operation and enabled ",
                "zero-divide exceptions, in which cases the field ",
                "remains unchanged.",
                "ddiv[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Encode BCD To DPD",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "denbcd",
                    "regs": [ "S,FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "S", "size": "1" },
                { "name": "reserved", "size": "4" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "834" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Encode BCD To DPD Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "denbcdq",
                    "regs": [ "S,FRTp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "S", "size": "1" },
                { "name": "reserved", "size": "4" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "834" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The signed or unsigned BCD operand, depending on ",
                "the S field, in FRB[p] is converted to a DFP number. ",
                "The ideal exponent is zero.",
                "If an invalid BCD digit or sign code is detected in the ",
                "source operand, an invalid-operation exception (VXCVI) ",
                "occurs.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exception when VE=1.",
                "denbcd[q][.] are treated as Floating-Point instructions ",
                "in terms of resource availability. "
            ]
        },
        {
            "description": "DFP Extract Biased Exponent",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dxex",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "354" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Extract Biased Exponent Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dxexq",
                    "regs": [ "FRT,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "354" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The biased exponent of the operand in FRB[p] is ",
                "extracted and placed into FRT in the 64-bit signed ",
                "binary integer format.  When the operand in FRB is an ",
                "infinity, QNaN, or SNaN, a special code is returned. ",
                "dxex[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Insert Biased Exponent",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "diex",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "866" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Insert Biased Exponent Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "diexq",
                    "regs": [ "FRTp,FRA,FRBp" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "866" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let a be the value of the 64-bit signed binary integer in ",
                "FRA.",
                "",
                "When 0 £ a £ MBE, a is the biased target exponent ",
                "that is combined with the sign bit and the significand ",
                "value of the DFP operand in FRB[p] to form the DFP ",
                "result in FRT[p]. The ideal exponent is the specified ",
                "target exponent.",
                "When a specifies a special code (a < 0 or a > MBE), an ",
                "infinity, QNaN, or SNaN is formed in FRT[p] with the ",
                "trailing significand field containing the value from the ",
                "trailing significand field of the source operand in ",
                "FRB[p], and with an N-bit combination field set as ",
                "follows.",
                "diex[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Multiply",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dmul",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "34" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Multiply Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dmulq",
                    "regs": [ "FRTp,FRAp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "34" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRA[p] is multiplied by the DFP ",
                "operand in FRB[p].  ",
                "The result is rounded to the target-format precision ",
                "under control of DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the sum of the two exponents of ",
                "the source operands.",
                "Figure81 summarizes the actions for Multiply.  ",
                "Figure81 does not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except for ",
                "an enabled invalid-operation exception, in which case ",
                "the field remains unchanged.",
                "dmul[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Quantize",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dqua",
                    "regs": [ "FRT,FRA,FRB,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "3" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Quantize Immediate",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dquai",
                    "regs": [ "TE,FRT,FRB,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "TE", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "67" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Quantize Immediate Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dquaiq",
                    "regs": [ "TE,FRTp,FRBp,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "TE", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "67" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRB[p] is converted and rounded ",
                "to the form with the exponent specified by TE based on ",
                "the rounding mode specified in the RMC field. TE is a ",
                "5-bit signed binary integer.  The result of that form is ",
                "placed in FRT[p].  The sign of the result is the same as ",
                "the sign of the operand in FRB[p].  The ideal exponent ",
                "is the exponent specified by TE.",
                "When the value of the operand in FRB[p] is greater ",
                "than (10p-1) % 10TE, where p is the format precision, ",
                "an invalid operation exception is recognized.",
                "When the delivered result differs in value from the ",
                "operand in FRB[p], an inexact exception is recognized.  ",
                "No underflow exception is recognized by this ",
                "operation, regardless of the value of the operand in ",
                "FRB[p].",
                "FPRF is always set to the class and sign of the result, ",
                "except for an enabled invalid-operation exception, in ",
                "which case the field remains unchanged.",
                "dquai[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Quantize Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dquaq",
                    "regs": [ "FRTp,FRAp,FRBp,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "3" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in register FRB[p] is converted and ",
                "rounded to the form with the same exponent as that of ",
                "the DFP operand in FRA[p] based on the rounding ",
                "mode specified by RMC. The result of that form is placed ",
                "in FRT[p].  The sign of the result is the same as the ",
                "sign of the operand in FRB[p]. The ideal exponent is ",
                "the exponent specified in FRA[p].",
                "When the value of the operand in FRB[p] is greater ",
                "than (10p-1) x 10Ea, where p is the format precision ",
                "and Ea is the exponent of the operand in FRA[p], an ",
                "invalid operation exception is recognized.",
                "When the delivered result differs in value from the ",
                "operand in FRB[p], an inexact exception is recognized.  ",
                "No underflow exception is recognized by this ",
                "operation, regardless of the value of the operand in ",
                "FRB[p].",
                "Figure89 and Figure90 summarize the actions.  The ",
                "tables do not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except ",
                "for an enabled invalid-operation exception, in which ",
                "case the field remains unchanged.",
                "dqua[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Reround",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drrnd",
                    "regs": [ "FRT,FRA,FRB,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "35" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Reround Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drrndq",
                    "regs": [ "FRTp,FRA,FRBp,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "35" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let k be the contents of bits 58:63 of FRA that specifies ",
                "the reference significance.",
                "When the DFP operand in FRB[p] is a finite number, ",
                "and if the reference significance is zero, or if the ",
                "reference significance is nonzero and the number of ",
                "significant digits of the source operand is less than or ",
                "equal to the reference significance, then the value and ",
                "the form of the source operand is placed in FRT[p].  If ",
                "the reference significance is nonzero and the number ",
                "of significant digits of the source operand is greater ",
                "than the reference significance, then the source ",
                "operand is converted and rounded to the number of ",
                "significant digits specified in the reference significance ",
                "based on the rounding mode specified in the RMC ",
                "field.  The result of the form with the specified number ",
                "of significant digits is placed in FRT[p].  The sign of the ",
                "result is the same as the sign of the operand in FRB[p].",
                "For this instruction, the number of significant digits of ",
                "the value 0 is considered to be zero.  The ideal ",
                "exponent is the greater value of the exponent of the ",
                "operand in FRB[p] and the referenced exponent.  The ",
                "referenced exponent is the resultant exponent if the ",
                "operand in FRB[p] would have been converted and ",
                "rounded to the number of significant digits specified in ",
                "the reference significance based on the rounding ",
                "mode specified by RMC.",
                "If the exponent of the rounded result of the form that ",
                "has the specified number of significant digits would be ",
                "greater than X<sub>max</sub><sub>,</sub> an invalid operation exception (VXCVI) ",
                "occurs.  When the invalid-operation exception occurs, ",
                "and if the exception is disabled, a default QNaN is ",
                "returned.  When an invalid-operation exception occurs, ",
                "no inexact exception is recognized.",
                "In the absence of an invalid-operation exception, if the ",
                "result differs in value from the operand in FRB[p], an ",
                "inexact exception is recognized.",
                "This operation causes neither an overflow nor an ",
                "underflow exception.",
                "Figure92 summarizes the actions for Reround.  The ",
                "table does not include the setting of FPRF.  FPRF is ",
                "always set to the class and sign of the result, except ",
                "for an enabled invalid-operation exception, in which ",
                "case the field remains unchanged.",
                "drrnd[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Round To DFP Long",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drdpq",
                    "regs": [ "FRTp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "770" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP extended operand in FRBp is converted and ",
                "rounded to DFP long format. The result concatenated ",
                "with 64 0s is placed in FRTp. The sign of the result is ",
                "the same as the sign of the source operand. The ideal ",
                "exponent is the exponent of the operand in FRBp.",
                "If the operand in FRBp is an SNaN, an invalid-operation ",
                "exception is recognized. If the exception is disabled, ",
                "the SNaN is converted to the corresponding QNaN in ",
                "DFP long format.",
                "Normally, the result is in the format and length of the ",
                "target.  However, when an overflow or underflow ",
                "exception occurs and if the exception is enabled, the ",
                "operation is completed by producing a wrapped ",
                "rounded result in the same format and length as the ",
                "source but rounded to the target-format precision.",
                "drdpq[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                "The DFP data-type conversion instructions are used to ",
                "convert data type between DFP and fixed.",
                "The data-type conversion instructions consist of Con",
                "vert From Fixed and Convert To Fixed."
            ]
        },
        {
            "description": "DFP Round To DFP Short",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drsp",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "770" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP long operand in FRB is converted and ",
                "rounded to DFP short format. The DFP short value is ",
                "extended on the left with zeros to form a 64-bit entity ",
                "and placed into FRT. The sign of the result is the same ",
                "as the sign of the source operand. The ideal exponent ",
                "is the exponent of the source operand.",
                "If the operand in FRB is an SNaN, it is converted to an ",
                "SNaN in DFP short format and does not cause an ",
                "invalid-operation exception.",
                "Normally, the result is in the format and length of the ",
                "target.  However, when an overflow or underflow ",
                "exception occurs and if the exception is enabled, the ",
                "operation is completed by producing a wrapped ",
                "rounded result in the same format and length as the ",
                "source but rounded to the target-format precision. ",
                "drsp[.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Round To FP Integer With Inexact",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drintx",
                    "regs": [ "R,FRT,FRB,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "R", "size": "1" },
                { "name": "FRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "99" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Round To FP Integer With Inexact Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drintxq",
                    "regs": [ "R,FRTp,FRBp,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "R", "size": "1" },
                { "name": "FRBp", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "99" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRB[p] is rounded to a ",
                "floating-point integer and placed into FRT[p].  The sign ",
                "of the result is the same as the sign of the operand in ",
                "FRB[p].  The ideal exponent is the larger value of zero ",
                "and the exponent of the operand in FRB[p].",
                "The rounding mode used is specified by RMC.  When ",
                "the RMC-encoding-selection (R) bit is zero, RMC field ",
                "contains the primary encoding; when the bit is one, the ",
                "field contains the secondary encoding.",
                "In addition to coercion of the converted value to fit the ",
                "target format, the special rounding used by Round To ",
                "FP Integer also coerces the target exponent to the ",
                "ideal exponent. ",
                "When the operand in FRB[p] is a finite number and the ",
                "exponent is less than zero, the operand is rounded to ",
                "the result with an exponent of zero.  When the ",
                "exponent is greater than or equal to zero, the result is ",
                "set to the numerical value and the form of the operand ",
                "in FRB[p]. ",
                "When the result differs in value from the operand in ",
                "FRB[p], an inexact exception is recognized.  No ",
                "underflow exception is recognized by this operation, ",
                "regardless of the value of the operand in FRB[p]. ",
                "Figure93 summarizes the actions for Round To FP ",
                "Integer With Inexact.  The table does not include the ",
                "setting of FPRF.  FPRF is always set to the class and sign ",
                "of the result, except for an enabled invalid-operation, in ",
                "which case the field remains unchanged. ",
                "drintx[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Round To FP Integer Without Inexact",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drintn",
                    "regs": [ "R,FRT,FRB,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "R", "size": "1" },
                { "name": "FRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "227" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Round To FP Integer Without Inexact Quad",
            "form": "Z23-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "drintnq",
                    "regs": [ "R,FRTp,FRBp,RMC", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "R", "size": "1" },
                { "name": "FRBp", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "227" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "This operation is the same as the Round To FP Integer ",
                "With Inexact operation, except that this operation does ",
                "not recognize an inexact exception.",
                "Figure94 summarizes the actions for Round To FP ",
                "Integer Without Inexact.  The table does not include ",
                "the setting of FPRF.  FPRF is always set to the class and ",
                "sign of the result, except for an enabled ",
                "invalid-operation, in which case the field remains ",
                "unchanged.",
                "drintn[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "DFP Shift Significand Left Immediate",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dscli",
                    "regs": [ "FRT,FRA,SH", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "SH", "size": "6" },
                { "name": "opcode", "size": "9", "value": "66" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Shift Significand Left Immediate Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dscliq",
                    "regs": [ "FRTp,FRAp,SH", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "SH", "size": "6" },
                { "name": "opcode", "size": "9", "value": "66" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The significand of the DFP operand in FRA[p] is shifted ",
                "left SH digits. For a NaN or infinity, all significand digits ",
                "are in the trailing significand field. SH is a 6-bit ",
                "unsigned binary integer. Digits shifted out of the ",
                "leftmost digit are lost. Zeros are supplied to the ",
                "vacated positions on the right. The result is placed into ",
                "FRT[p]. The sign of the result is the same as the sign ",
                "of the source operand in FRA[p].",
                "If the source operand in FRA[p] is a finite number, the ",
                "exponent of the result is the same as the exponent of ",
                "the source operand. ",
                "For an Infinity, QNaN or SNaN result, the target ",
                "format’s N-bit combination field is set as follows.",
                "dscli[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Shift Significand Right Immediate",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dscri",
                    "regs": [ "FRT,FRA,SH", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "SH", "size": "6" },
                { "name": "opcode", "size": "9", "value": "98" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Shift Significand Right Immediate Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dscriq",
                    "regs": [ "FRTp,FRAp,SH", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "SH", "size": "6" },
                { "name": "opcode", "size": "9", "value": "98" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The significand of the DFP operand in FRA[p] is shifted ",
                "right SH digits. For a NaN or infinity, all significand ",
                "digits are in the trailing significand field. SH is a 6-bit ",
                "unsigned binary integer. Digits shifted out of the units ",
                "digit are lost. Zeros are supplied to the vacated ",
                "positions on the left. The result is placed into FRT[p]. ",
                "The sign of the result is the same as the sign of the ",
                "source operand in FRA[p].",
                "If the source operand in FRA[p] is a finite number, the ",
                "exponent of the result is the same as the exponent of ",
                "the source operand. ",
                "For an Infinity, QNaN or SNaN result, the target ",
                "format’s N-bit combination field is set as follows.",
                "dscri[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Subtract",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dsub",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "514" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Subtract Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dsubq",
                    "regs": [ "FRTp,FRAp,FRBp", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRTp", "size": "5" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "514" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The DFP operand in FRB[p] is subtracted from the DFP ",
                "operand in FRA[p].",
                "The result is rounded to the target-format precision ",
                "under control of DRN (bits 29:31 of the FPSCR).  An ",
                "appropriate form of the rounded result is selected ",
                "based on the ideal exponent and is placed in FRT[p].  ",
                "The ideal exponent is the smaller exponent of the two ",
                "source operands. ",
                "The execution of Subtract is identical to that of Add, ",
                "except that the operand in FRB participates in the opera",
                "tion with its sign bit inverted.  See Figure80. The table ",
                "does not include the setting of FPRF. FPRF is always set ",
                "to the class and sign of the result, except for an ",
                "enabled invalid-operation exception, in which case the ",
                "field remains unchanged.",
                "dsub[q][.] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "DFP Test Data Class",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstdc",
                    "regs": [ "BF,FRA,DCM" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "DCM", "size": "5" },
                { "name": "opcode", "size": "10", "value": "194" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Test Data Class Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstdcq",
                    "regs": [ "BF,FRAp,DCM" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRAp", "size": "5" },
                { "name": "DCM", "size": "5" },
                { "name": "opcode", "size": "10", "value": "194" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let the DCM (Data Class Mask) field specify one or ",
                "more of the 6 possible data classes, where each bit ",
                "corresponds to a specific data class.",
                "CR field BF and FPCC are set to indicate the sign of the ",
                "DFP operand in FRA[p] and whether the data class of ",
                "the DFP operand in FRA[p] matches any of the data ",
                "classes specified by DCM.",
                "dtstdc[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Test Data Group",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstdg",
                    "regs": [ "BF,FRA,DGM" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "DGM", "size": "5" },
                { "name": "opcode", "size": "10", "value": "226" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Test Data Group Quad",
            "form": "Z22-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstdgq",
                    "regs": [ "BF,FRAp,DGM" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRAp", "size": "5" },
                { "name": "DGM", "size": "5" },
                { "name": "opcode", "size": "10", "value": "226" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let the DGM (Data Group Mask) field specify one or ",
                "more of the 6 possible data groups, where each bit ",
                "corresponds to a specific data group.",
                "The term extreme exponent means either the ",
                "maximum exponent, X<sub>max</sub>, or the minimum exponent, ",
                "X<sub>min</sub>. ",
                "CR field BF and FPCC are set to indicate the sign of the ",
                "DFP operand in FRA[p] and whether the data group of ",
                "the DFP operand in FRA[p] matches any of the data ",
                "groups specified by DGM.",
                "dtstdg[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. "
            ]
        },
        {
            "description": "DFP Test Exponent",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstex",
                    "regs": [ "BF,FRA,FRB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "162" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Test Exponent Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstexq",
                    "regs": [ "BF,FRAp,FRBp" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRAp", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "162" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The exponent value (Ea) of the DFP operand in FRA[p] ",
                "is compared to the exponent value (Eb) of the DFP ",
                "operand in FRB[p].  The result of the compare is placed ",
                "into CR field BF and the FPCC<sub>.</sub>",
                "The codes in the CR field BF and FPCC are defined for ",
                "the DFP Test Exponent operations as follows. "
            ]
        },
        {
            "description": "DFP Test Significance",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstsf",
                    "regs": [ "BF,FRA,FRB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "674" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Test Significance Immediate",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstsfi",
                    "regs": [ "BF,UIM,FRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "6" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "675" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "DFP Test Significance Immediate Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstsfiq",
                    "regs": [ "BF,UIM,FRBp" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "6" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "675" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let the value UIM specify the reference significance.",
                "For dtstsfi, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRB].",
                "For dtstsfiq, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRBp:FRBp+1].",
                "For this instruction, the number of significant digits of ",
                "the value 0 is considered to be zero.",
                "NSDb is compared to UIM. The result of the compare is ",
                "placed into CR field BF and the FPCC as follows. ",
                "dtstsfi[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "DFP Test Significance Quad",
            "form": "X-form",
            "category": "Decimal Floating-Point",
            "mnemonics": [
                {
                    "mnemonic": "dtstsfq",
                    "regs": [ "BF,FRA,FRBp" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRBp", "size": "5" },
                { "name": "opcode", "size": "10", "value": "674" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let k be the contents of bits 58:63 of FPR[FRA] that ",
                "specifies the reference significance.",
                "For dtstsf, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRB].",
                "For dtstsfq, let the value NSDb be the number of ",
                "significant digits of the DFP value in FPR[FRBp:FRBp+1].",
                "For this instruction, the number of significant digits of ",
                "the value 0 is considered to be zero.",
                "NSDb is compared to k. The result of the compare is ",
                "placed into CR field BF and the FPCC as follows. ",
                "dtstsf[q] are treated as Floating-Point instructions in ",
                "terms of resource availability. ",
                ""
            ]
        },
        {
            "description": "Decimal Add Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdadd.",
                    "regs": [ "VRT,VRA,VRB,PS" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := bcd_ADD(VSR[VRA+32],VSR[VRB+32],PS)",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := ox_flag | inv_flag"
            ],
            "body": [
                "Let src1 be the decimal integer value in VSR[VRA+32].",
                "src1 is added to src2.",
                "If the unbounded result is equal to zero, do the ",
                "following.",
                "If the unbounded result is greater than zero, do the ",
                "following.",
                "If the unbounded result is less than zero, do the ",
                "following.",
                "The low-order 31 digits of the magnitude of the result ",
                "are placed in bits 0:123 of VSR[VRT+32]. ",
                "The sign code is placed in bits 124:127 of VSR[VRT+32].",
                "If either src1 or src2 is an invalid encoding of a 31-digit ",
                "signed decimal value, the result is undefined and CR ",
                "field 6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert From National",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdcfn.",
                    "regs": [ "VRT,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "7" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src_sign := (VSR[VRB+32].hword[7] = 0x002D)",
                "eq_flag  := 1",
                "/* check for valid sign */",
                "inv_flag := (VSR[VRB+32].hword[7] != 0x002B) &",
                "          (VSR[VRB+32].hword[7] != 0x002D)",
                "",
                "do i = 0 to 6",
                "   eq_flag  := eq_flag  & (VSR[VRB+32].hword[i] = 0x0030)",
                "   /* check for valid digit */",
                "   inv_flag := inv_flag | (VSR[VRB+32].hword[i] < 0x0030)",
                "                      | (VSR[VRB+32].hword[i] > 0x0039)",
                "end",
                "",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "do i = 0 to 23",
                "   result.nibble[i] := 0x0",
                "end",
                "do i = 0 to 6",
                "   result.nibble[i+24] := VSR[VRB+32].hword[i].nibble[3]",
                "end",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag"
            ],
            "body": [
                "Let src be the national decimal value in VSR[VRB+32]. ",
                "src is placed in VSR[VRT+32] in packed decimal format.",
                "A valid encoding of a national decimal value requires ",
                "the following.",
                "National decimal values having a sign code of 0x002B ",
                "are interpreted as positive values.",
                "National decimal values having a sign code of 0x002D ",
                "are interpreted as negative values.",
                "For each integer value i from 0 to 23, do the following.",
                "For each integer value i from 0 to 6, do the following.",
                "For PS=0, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xC for positive values ",
                "and to 0xD for negative values.",
                "For PS=1, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xF for positive values ",
                "and to 0xD for negative values.",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a national decimal ",
                "value, the contents of VSR[VRT+32] are undefined and ",
                "CR field 6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert From Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdcfsq.",
                    "regs": [ "VRT,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "ox_flag := (EXTS(VSR[VRB+32]) >  1031-1) |",
                "         (EXTS(VSR[VRB+32]) < -1031-1)",
                "lt_flag := (EXTS(VSR[VRB+32]) <  0)",
                "gt_flag := (EXTS(VSR[VRB+32]) >  0)",
                "eq_flag := (EXTS(VSR[VRB+32]) =  0)",
                "",
                "if ox_flag=0 then",
                "   result := bcd_CONVERT_FROM_SI128(EXTS(VSR[VRB+32]),PS)",
                "else",
                "   result := 0xUUUU_UUUU_UUUU_UUUU_UUUU_UUUU_UUUU_UUUU",
                "",
                "VSR[VRT+32] := ox_flag ? undefined : result",
                "",
                "CR.bit[56] := lt_flag",
                "CR.bit[57] := gt_flag",
                "CR.bit[58] := eq_flag",
                "CR.bit[59] := ox_flag"
            ],
            "body": [
                "Let src be the signed integer value in VSR[VRB+32]. ",
                "src is placed into VSR[VRT+32] in signed packed ",
                "decimal format.",
                "For PS=0, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xC for values greater ",
                "than or equal to 0 and to 0xD for values less than 0.",
                "For PS=1, the contents of nibble element 31 (i.e., sign ",
                "code) of VSR[VRT+32] are set to 0xF for values greater ",
                "than or equal to 0 and to 0xD for values less than 0.",
                "If the signed integer value in VSR[VRB+32] is greater ",
                "than 1031-1 or less than -1031-1, the value is too large ",
                "to be represented in packed decimal format, and the ",
                "contents of VSR[VRT+32] are undefined.",
                "CR field 6 is set to reflect src compared to zero and ",
                "whether or not src is too large in magnitude to be ",
                "represented in packed decimal format."
            ]
        },
        {
            "description": "Decimal Convert From Zoned",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdcfz.",
                    "regs": [ "VRT,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "6" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "/* check for valid sign */",
                "inv_flag := ((VSR[VRB+32].byte[15].nibble[0] < 0xA) & (PS=1)) |",
                "           (VSR[VRB+32].byte[15].nibble[1] > 0x9)",
                "",
                "/* check for valid digits */",
                "MIN := (PS=0) ? 0x30 : 0xF0",
                "MAX := (PS=0) ? 0x39 : 0xF9",
                "do i = 0 to 14",
                "   inv_flag := inv_flag | (VSR[VRB+32].byte[i] < MIN)",
                "                      | (VSR[VRB+32].byte[i] > MAX)",
                "end",
                "",
                "if PS=0 then",
                "   src_sign :=  VSR[VRB+32].nibble[30].bit[1]",
                "else",
                "   src_sign := (VSR[VRB+32].nibble[30] = 0b1011) |",
                "             (VSR[VRB+32].nibble[30] = 0b1101)",
                "",
                "eq_flag  := 1",
                "",
                "do i = 0 to 14",
                "   result.nibble[i] := 0x0",
                "end",
                "do i = 0 to 15",
                "   result.nibble[i+15] := VSR[VRB+32].byte[i].nibble[1]",
                "   eq_flag := eq_flag & (VSR[VRB+32].byte[i].nibble[1]=0x0)",
                "end",
                "",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "result.nibble[31] := (src_sign=0) ? 0xC : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag"
            ],
            "body": [
                "Let src be the zoned decimal value in VSR[VRB+32]. ",
                "src is placed in VSR[VRT+32] in packed decimal format.",
                "When PS=0, do the following.",
                "When PS=1, do the following.",
                "Positive packed decimal results are returned with a ",
                "sign code of 0xC.",
                "Negative packed decimal results are returned with a ",
                "sign code of 0xD.",
                "For each integer value i from 0 to 14,",
                "For each integer value i from 0 to 15,",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a zoned decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert To National",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdctn.",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "ox_flag := 0",
                "do i = 0 to 23",
                "   ox_flag := ox_flag | (VSR[VRB+32].nibble[i] != 0x0)",
                "end",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "src.sign := (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "do i = 0 to 6",
                "   result.hword[i].nibble[0:2] := 0x003",
                "   result.hword[i].nibble[3]   := VSR[VRB+32].nibble[i+24]",
                "end",
                "",
                "result.hword[7] := (src_sign=1) ? 0x002D : 0x002B",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "src is placed into VSR[VRT+32] in national decimal ",
                "format.",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "Values greater in magnitude than 107-1 are too large ",
                "to be represented in national decimal format.",
                "For each integer value i from 0 to 6, do the following.",
                "The contents of halfword element 7 (i.e., sign code) of ",
                "VSR[VRT+32] are set to 0x002B for positive values and to ",
                "0x002D for negative values.",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not src is too large to be ",
                "represented in national decimal format.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert To Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdctsq.",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign    := (VSR[VRB+32].nibble[31] = 0xB) |",
                "             (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag     := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag     := (eq_flag=0) & (src_sign=1)",
                "gt_flag     := (eq_flag=0) & (src_sign=0)",
                "",
                "result      := si128_CONVERT_FROM_BCD(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "src is placed into VSR[VRT+32] in signed integer format.",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Convert To Zoned",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdctz.",
                    "regs": [ "VRT,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "ox_flag := 0",
                "do i = 0 to 15",
                "   ox_flag := ox_flag | (VSR[VRB+32].nibble[i] != 0x0)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "do i = 0 to 14",
                "   result.byte[i].nibble[0] := (PS=0) ? 0x3 : 0xF",
                "   result.byte[i].nibble[1] := VSR[VRB+32].nibble[i+15]",
                "end",
                "if src.sign=0 then",
                "   result.byte[15].nibble[0] := (PS=0) ? 0x3 : 0xC",
                "else",
                "   result.byte[15].nibble[0] := (PS=0) ? 0x7 : 0xD",
                "",
                "result.byte[15].nibble[1] := VSR[VRB+32].nibble[30]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "src is placed into  VSR[VRT+32] in zoned decimal ",
                "format.",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "Values greater in magnitude than 1016-1 are too large ",
                "to be represented in zoned decimal format.",
                "For PS=0, do the following.",
                "For PS=1, do the following.",
                "For each integer value i from 0 to 15, do the following.",
                "The result is placed into VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not src is too large to be ",
                "represented in zoned decimal format.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Copy Sign",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdcpsgn.",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "833" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRA+32].nibble[31] < 0xA) |",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRA+32].nibble[i] > 0x9)",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRA+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "result.nibble[0:30] := VSR[VRA+32].nibble[0:30]",
                "result.nibble[31]   := VSR[VRB+32].nibble[31]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "The decimal value in VSR[VRA+32] is placed into ",
                "VSR[VRT+32] with the sign code of the decimal value in ",
                "VSR[VRB+32].",
                "CR field 6 is set to reflect the result compared to zero.",
                "If either the decimal value in VSR[VRA+32] or the ",
                "decimal value in VSR[VRB+32] is an invalid encoding, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Set Sign",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdsetsgn.",
                    "regs": [ "VRT,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "31" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "385" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "result.nibble[0:30] := VSR[VRB+32].nibble[0:30]",
                "result.nibble[31]   := (src_sign=0) ? ((PS=0) ? 0xC:0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "Let src be the packed decimal value in VSR[VRB+32]. ",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "If src is negative, src is placed into VSR[VRT+32] with ",
                "the sign code set to 0xD.",
                "If src is positive and PS=0, src is placed into ",
                "VSR[VRT+32] with the sign code set to 0xC.",
                "If src is positive and PS=1, src is placed into ",
                "VSR[VRT+32] with the sign code set to 0xF.",
                "CR field 6 is set to reflect src compared to zero.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Shift",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcds.",
                    "regs": [ "VRT,VRA,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "193" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "if n > 0 then do     // shift left",
                "   shcnt               := (n<32) ? n : 31",
                "   src.nibble[0:30]    := VSR[VRB+32].nibble[0:30]",
                "   src.nibble[31:61]   := 0",
                "   result.nibble[0:30] := src.data.nibble[shcnt:shcnt+30]",
                "   ox_flag := (shcnt > 0) & (src.nibble[0:shcnt-1] != 0)",
                "end",
                "else do              // shift right",
                "   shcnt               := ((~n+1)<32) ? (~n+1) : 31",
                "   src.nibble[0:30]    := 0",
                "   src.nibble[31:61]   := VSR[VRB+32].nibble[0:30]",
                "   result.nibble[0:30] := src.nibble[31-shcnt:61-shcnt]",
                "   ox_flag := 0b0",
                "end",
                "",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let n be the signed integer value in byte element 7 of ",
                "VSR[VRA+32].",
                "Let src be the signed packed decimal value in ",
                "VSR[VRB+32].",
                "A valid encoding of a signed packed decimal value ",
                "requires the following.",
                "Packed decimal source operands with sign codes of ",
                "0xA, 0xC, 0xE, or 0xF are interpreted as positive values.",
                "Packed decimal source operands with sign codes of ",
                "0xB or 0xD are interpreted as negative values.",
                "If n is greater than zero, src is shifted left n digits. ",
                "Zeros are supplied to vacated digits on the right. If any ",
                "non-zero digits are shifted out, an overflow occurs.",
                "If n is less than zero, src is shifted right -n digits. Zeros ",
                "are supplied to vacated digits on the left.",
                "If the packed decimal value in VSR[VRB+32] is negative, ",
                "the sign code of the result is set to 0b1101.",
                "If the packed decimal value in VSR[VRB+32] is positive, ",
                "the sign code of the result is set to 0b1100 if PS=0 and is ",
                "set to 0b1111 if PS=1.",
                "The shifted result is placed into VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were shifted ",
                "out when the shift count is positive (i.e., left shift ",
                "operation).",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Shift & Round",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdsr.",
                    "regs": [ "VRT,VRA,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "449" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "if n > 0 then do     // shift left",
                "   shcnt := Clamp(n, 0, 31)",
                "   src.nibble[0:30]    := VSR[VRB+32].nibble[0:30]",
                "   src.nibble[31:61]   := 0",
                "   result.nibble[0:30] := src.nibble[shcnt:shcnt+30]",
                "   ox_flag := (shcnt > 0) & (src.nibble[0:shcnt-1] != 0)",
                "   g_flag  := 0",
                "end",
                "else do              // shift right",
                "   shcnt := Clamp(~n + 1, 0, 31)",
                "   src.nibble[0:30]    := 0",
                "   src.nibble[31:61]   := VSR[VRB+32].nibble[0:30]",
                "   result.nibble[0:30] := src.nibble[31-shcnt:61-shcnt]",
                "   ox_flag := 0",
                "   g_flag  := (shcnt > 0) & ",
                "              (EXTZ(src.nibble[62-shcnt]) >= 5)",
                "end",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "result := (g_flag=0) ? result : bcd_INCREMENT(result)",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let n be the signed integer value in byte element 7 of ",
                "VSR[VRA+32].",
                "Let src be the signed packed decimal value in ",
                "VSR[VRB+32].",
                "A valid encoding of a signed packed decimal source ",
                "operand requires the following.",
                "Packed decimal source operands with sign codes of ",
                "0xA, 0xC, 0xE, or 0xF are interpreted as positive values.",
                "Packed decimal source operands with sign codes of ",
                "0xB or 0xD are interpreted as negative values.",
                "If n is greater than zero, src is shifted left n digits. ",
                "Zeros are supplied to vacated digits on the right. If any ",
                "non-zero digits are shifted out, an overflow occurs.",
                "If n is less than zero, src is shifted right -n digits. Zeros ",
                "are supplied to vacated digits on the left. If the value of ",
                "the last nibble shifted out on the right was greater than ",
                "or equal to 5, the magnitude of the result is ",
                "incremented by 1.",
                "If src is negative, the sign code of the result is set to ",
                "0b1101.",
                "If src is positive, the sign code of the result is set to ",
                "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
                "The shifted and rounded result is placed into ",
                "VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were shifted ",
                "out when the shift count is positive (i.e., left shift ",
                "operation).",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Subtract Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdsub.",
                    "regs": [ "VRT,VRA,VRB,PS" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "65" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := bcd_SUBTRACT(VSR[VRA+32],VSR[VRB+32],PS)",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := ox_flag | inv_flag"
            ],
            "body": [
                "Let src1 be the decimal integer value in VSR[VRA+32].",
                "src1 is subtracted by src2.",
                "If the unbounded result is equal to zero, do the ",
                "following.",
                "If the unbounded result is greater than zero, do the ",
                "following.",
                "If the unbounded result is less than zero, do the ",
                "following.",
                "The low-order 31 digits of the magnitude of the result ",
                "are placed in bits 0:123 of VSR[VRT+32]. ",
                "The sign code is placed in bits 124:127 of VSR[VRT+32].",
                "If either src1 or src2 is an invalid encoding of a 31-digit ",
                "signed decimal value, the result is undefined and CR ",
                "field 6 is set to 0b0001.",
                "  ",
                "  ",
                "  "
            ]
        },
        {
            "description": "Decimal Truncate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdtrunc.",
                    "regs": [ "VRT,VRA,VRB,PS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "PS", "size": "1" },
                { "name": "opcode", "size": "9", "value": "257" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "length  := VSR[VRA+32].bit[48:63]",
                "",
                "ox_flag := 0",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "          (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  :=  src_sign & ~eq_flag",
                "gt_flag  := ~src_sign & ~eq_flag",
                "",
                "if length < 31 then do",
                "   do i = 0 to 30-length",
                "      if VSR[VRB+32].nibble[i]!=0b0000 then ox_flag := 1",
                "      result.nibble[i] := 0b0000",
                "   end",
                "   if length > 0 then do",
                "      do i = 31-length to 30",
                "         result.nibble[i] := VSR[VRB+32].nibble[i]",
                "      end",
                "   end",
                "end",
                "else result.nibble[0:30] := VSR[VRB+32].nibble[0:30]",
                "",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let length be the integer value in bits 48:63 of ",
                "VSR[VRA+32].",
                "Let src be the signed decimal value in VSR[VRB+32].",
                "A valid encoding of a packed decimal source operand ",
                "requires the following.",
                "Packed decimal values with sign codes of 0xA, 0xC, ",
                "0xE, or 0xF are interpreted as positive values.",
                "Packed decimal values with sign codes of 0xB or 0xD ",
                "are interpreted as negative values.",
                "If src is negative, the sign code of the result is set to ",
                "0b1101.",
                "If src is positive, the sign code of the result is set to ",
                "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
                "src is copied into VSR[VRT+32] with the leftmost ",
                "31-length digits each set to 0b0000. If any of the ",
                "leftmost 31-length digits of the signed decimal value in ",
                "VSR[VRB+32] are non-zero, an overflow occurs.",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were ",
                "truncated.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Unsigned Shift",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdus.",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "129" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := 0",
                "do i = 0 to 31",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:31] = 0)",
                "gt_flag  := (eq_flag=0)",
                "",
                "if n > 0 then do     // shift left",
                "   shcnt := (n<33) ? n : 32",
                "   src.nibble[0:31] := VSR[VRB+32]",
                "   src.nibble[32:63] := 0",
                "   result := src.nibble[shcnt:shcnt+31]",
                "   ox_flag := (shcnt > 0) & (src.nibble[0:shcnt-1] != 0)",
                "end",
                "else do              // shift right",
                "   shcnt := ((~n+1)<33) ? (~n+1) : 32",
                "   src.nibble[0:31]  := 0",
                "   src.nibble[32:63] := VSR[VRB+32]",
                "   result := src.nibble[32-shcnt:63-shcnt]",
                "   ox_flag := 0",
                "end",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := 0b0",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let n be the signed integer value in byte element 7 of ",
                "VSR[VRA+32].",
                "Let src be the unsigned packed decimal value in ",
                "VSR[VRB+32].",
                "A valid encoding of an unsigned packed decimal value ",
                "requires the contents of each nibble 0-31 must be a ",
                "value in the range 0x0 to 0x9.",
                "If n is greater than zero, src is shifted left n digits. ",
                "Zeros are supplied to vacated digits on the right. If any ",
                "non-zero digits are shifted out, an overflow occurs.",
                "If n is less than zero, src is shifted right -n digits. Zeros ",
                "are supplied to vacated digits on the left.",
                "The shifted result is placed into VSR[VRT+32].",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were shifted ",
                "out when the shift count is positive (i.e., left shift ",
                "operation).",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Decimal Unsigned Truncate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "bcdutrunc.",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "321" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := 0",
                "do i = 0 to 31",
                "    inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "length := VSR[VRA+32].bit[48:63]",
                "",
                "ox_flag := 0",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:31]  = 0)",
                "gt_flag  := (VSR[VRB+32].nibble[0:31] != 0)",
                "",
                "if length < 32 then do",
                "   do i = 0 to 31-length",
                "      if VSR[VRB+32].nibble[i]!=0b0000 then ox_flag := 1",
                "      result.nibble[i] := 0b0000",
                "   end",
                "   if length > 0 then do",
                "      do i = 32-length to 31",
                "         result.nibble[i] := VSR[VRB+32].nibble[i]",
                "      end",
                "   end",
                "end",
                "else result := VSR[VRB+32]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := 0b0",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "Let length be the integer value in bits 48:63 of ",
                "VSR[VRA+32].",
                "Let src be the unsigned decimal value in VSR[VRB+32].",
                "A valid encoding of a packed decimal source operand ",
                "requires the contents of each nibble 0-31 must be a ",
                "value in the range 0x0 to 0x9.",
                "src is copied into VSR[VRT+32] with the leftmost ",
                "32-length digits each set to 0b0000. If any of the ",
                "leftmost 32-length digits of the signed decimal value in ",
                "VSR[VRB+32] are non-zero, an overflow occurs.",
                "CR field 6 is set to reflect src compared to zero, ",
                "including whether or not significant digits were ",
                "truncated.",
                "If src is an invalid encoding of a packed decimal value, ",
                "the contents of VSR[VRT+32] are undefined and CR field ",
                "6 is set to 0b0001."
            ]
        },
        {
            "description": "Deliver A Random Number",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "darn",
                    "regs": [ "RT,L" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "reserved", "size": "3" },
                { "name": "L", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "755" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RT := random(L)",
                " ",
                " "
            ],
            "body": [
                "A random number is placed into register RT in a format ",
                "selected by L as shown in the following table.  The ",
                "value 0xFFFFFFFF_FFFFFFFF indicates an error condition.  ",
                "For L=0, the random number range is 0:0xFFFFFFFF.  For ",
                "L=1 and L=2, the random number range is ",
                "0:0xFFFFFFFF_FFFFFFFE.",
                " ",
                "",
                "",
                "",
                " ",
                ""
            ]
        },
        {
            "description": "Divide Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divd",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divd.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "489" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend ¸ divisor",
                "   0x8000_0000_0000_0000 ¸ -1",
                "      <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit quotient is placed into register RT. The ",
                "remainder is not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnegative, ",
                "and -|divisor| < r £ 0 if the dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1.",
                "  "
            ]
        },
        {
            "description": "Divide Doubleword Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divde",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divde.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "425" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:127</sub> := (RA) || <sup>64</sup>0",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend ¸ divisor",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 128-bit dividend is (RA) || 640. The 64-bit divisor is ",
                "(RB). If the quotient can be represented in 64 bits, it is ",
                "placed into register RT. The remainder is not supplied as ",
                "a result. ",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnega",
                "tive, and -|divisor| < r £ 0 if the dividend is negative.",
                "If the quotient cannot be represented in 64 bits, or if an ",
                "attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field ",
                "0. In these cases, if OE=1 then OV and ",
                "OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Doubleword Extended Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divdeu",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeu.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeuo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeuo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "393" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:127</sub> := (RA) || <sup>64</sup>0",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend ¸ divisor",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 128-bit dividend is (RA) || 640. The 64-bit divisor is ",
                "(RB). If the quotient can be represented in 64 bits, it is ",
                "placed into register RT. The remainder is not supplied as ",
                "a result. ",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero. The quotient is the unique unsigned integer ",
                "that satisfies",
                "where 0 £ r < divisor.",
                "If (RA) ³ (RB), or if an attempt is made to perform the ",
                "division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In these cases, if OE=1 then OV and OV32 ",
                "are set to 1.",
                "  "
            ]
        },
        {
            "description": "Divide Doubleword Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divdu",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdu.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divduo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divduo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "457" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend ¸ divisor",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit quotient is placed into register RT. The ",
                "remainder is not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero. The quotient is the unique unsigned integer ",
                "that satisfies",
                "where 0 £ r < divisor.",
                "If an attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In this case, if OE=1 then OV and OV32 ",
                "are set to 1."
            ]
        },
        {
            "description": "Divide Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divw",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divw.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "491" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend ¸ divisor",
                "RT<sub>0:31</sub> := undefined",
                "   0x8000_0000 ¸ -1",
                "   <anything> ¸ 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit quotient is placed into RT<sub>32:63</sub>. The ",
                "contents of RT<sub>0:31</sub> are undefined. The remainder is not ",
                "supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnega",
                "tive, and -|divisor| < r £ 0 if the dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined as are ",
                "(ifRc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then OV ",
                "and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divwe",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divwe.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "427" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)<sub>32:63</sub> || <sup>32</sup>0",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend ¸ divisor",
                "RT<sub>0:31</sub> := undefined",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA)<sub>32:63 </sub><sub>|| </sub><sub>32</sub><sub>0</sub>. The 32-bit divi",
                "sor is (RB)<sub>32:63</sub>. If the quotient can be represented in 32 ",
                "bits, it is placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> are ",
                "undefined. The remainder is not supplied as a result. ",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnega",
                "tive, and -|divisor| < r £ 0 if the dividend is negative.",
                "If the quotient cannot be represented in 32 bits, or if an ",
                "attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field ",
                "0. In these cases, if OE=1 then OV and ",
                "OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Extended Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divweu",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweu.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweuo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweuo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "395" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)<sub>32:63</sub> || <sup>32</sup>0",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend ¸ divisor",
                "RT<sub>0:31</sub> := undefined",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA)<sub>32:63 </sub><sub>|| </sub><sub>32</sub><sub>0</sub>. The 32-bit divi",
                "sor is (RB)<sub>32:63</sub>. If the quotient can be represented in 32 ",
                "bits, it is placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> are ",
                "undefined. The remainder is not supplied as a result. ",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero. The quotient is the unique unsigned inte",
                "ger that satisfies",
                "where 0 £ r < divisor.",
                "If (RA) ³ (RB), or if an attempt is made to perform the ",
                "division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In these cases, if OE=1 then OV and OV32 ",
                "are set to 1.",
                "Unsigned long division of a 64-bit dividend contained in ",
                "two 32-bit registers by a 32-bit divisor can be computed ",
                "as follows. The algorithm is shown first, followed by ",
                "Assembler code that implements the algorithm. The ",
                "dividend is Dh || Dl, the divisor is Dv, and the quotient ",
                "and remainder are Q and R respectively, where these ",
                "variables and all intermediate variables represent ",
                "unsigned 32-bit integers. It is assumed that Dv > Dh, ",
                "and that assigning a value to an intermediate variable ",
                "assigns the low-order 32 bits of the value and ignores ",
                "any higher-order bits of the value. (In both the algorithm ",
                "and the Assembler code, “r1” and “r2” refer to “remain",
                "der 1” and “remainder 2”, rather than to GPRs 1 and 2.)",
                "Algorithm:",
                "Assembler Code:",
                "Notes:"
            ]
        },
        {
            "description": "Divide Word Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divwu",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwu.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwuo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwuo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "459" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend ¸ divisor",
                "RT<sub>0:31</sub> := undefined",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 32 bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit quotient is placed into RT<sub>32:63</sub>. The ",
                "contents of RT<sub>0:31</sub> are undefined. The remainder is not ",
                "supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero. The quotient is the unique unsigned integer ",
                "that satisfies",
                "where 0 £ r < divisor.",
                "If an attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR Field 0",
                ". In this case, if OE=1 then OV and OV32 ",
                "are set to 1."
            ]
        },
        {
            "description": "Equivalent ",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "eqv",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "eqv.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "284" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := (RS) == (RB)"
            ],
            "body": [
                "The contents of register RS are XORed with the con",
                "tents of register RB and the complemented result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Extend Sign Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extsb",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "extsb.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "954" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "s := (RS)<sub>56</sub>",
                "RA<sub>56:63</sub> := (RS)<sub>56:63</sub>",
                "RA<sub>0:55</sub> := <sup>56</sup>s"
            ],
            "body": [
                "(RS)<sub>56:63</sub> are placed into RA<sub>56:63</sub>. RA<sub>0:55</sub> are filled with a ",
                "copy of (RS)<sub>56</sub>."
            ]
        },
        {
            "description": "Extend Sign Halfword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extsh",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "extsh.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "922" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "s := (RS)<sub>48</sub>",
                "RA<sub>48:63</sub> := (RS)<sub>48:63</sub>",
                "RA<sub>0:47</sub> := <sup>48</sup>s"
            ],
            "body": [
                "(RS)<sub>48:63</sub> are placed into RA<sub>48:63</sub>. RA<sub>0:47</sub> are filled with a ",
                "copy of (RS)<sub>48</sub>."
            ]
        },
        {
            "description": "Extend Sign Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extsw",
                    "regs": [ "RA,RS", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "extsw.",
                    "regs": [ "RA,RS", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "986" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "s := (RS)<sub>32</sub>",
                "RA<sub>32:63</sub> := (RS)<sub>32:63</sub>",
                "RA<sub>0:31</sub> := <sup>32</sup>s"
            ],
            "body": [
                "(RS)<sub>32:63</sub> are placed into RA<sub>32:63</sub>. RA<sub>0:31</sub> are filled with a ",
                "copy of (RS)<sub>32</sub>."
            ]
        },
        {
            "description": "Extend Sign Word and Shift Left Immediate",
            "form": "XS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extswsli",
                    "regs": [ "RA,RS,SH", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "extswsli.",
                    "regs": [ "RA,RS,SH", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "sh", "size": "5" },
                { "name": "opcode", "size": "9", "value": "445" },
                { "name": "sh", "size": "1" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n  := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r  := ROTL64(EXTS64(RS<sub>32:63</sub>), n)",
                "m  := MASK(0, 63-n)",
                "RA := r & m"
            ],
            "body": [
                "The contents of the low order 32 bits of RS are ",
                "sign-extended to 64 bits and then shifted left SH bits. ",
                "Bits shifted out of bit 0 are lost. Zeros are supplied to ",
                "vacated bits on the right. The result is placed in ",
                "register RA."
            ]
        },
        {
            "description": "Floating Absolute Value",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fabs",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fabs.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "264" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of register FRB with bit 0 set to zero are ",
                "placed into register FRT."
            ]
        },
        {
            "description": "Floating Add",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fadd",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fadd.",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "21" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Add Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fadds",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fadds.",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "21" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRA is added to ",
                "the floating-point operand in register FRB.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Floating-point addition is based on exponent compari",
                "son and addition of the two significands. The exponents ",
                "of the two operands are compared, and the significand ",
                "accompanying the smaller exponent is shifted right, ",
                "with its exponent increased by one for each bit shifted, ",
                "until the two exponents are equal. The two significands ",
                "are then added or subtracted as appropriate, depend",
                "ing on the signs of the operands, to form an intermedi",
                "ate sum. All 53 bits of the significand as well as all three ",
                "guard bits (G, R, and X) enter into the computation.",
                "If a carry occurs, the sum’s significand is shifted right ",
                "one bit position and the exponent is increased by one.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Compare Ordered",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcmpo",
                    "regs": [ "BF,FRA,FRB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "32" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if (FRA) is a NaN or",
                "   (FRB) is a NaN then c := 0b0001",
                "else if (FRA) < (FRB) then c := 0b1000",
                "else if (FRA) > (FRB) then c := 0b0100",
                "else                       c := 0b0010",
                "FPCC := c",
                "CR<sub>4</sub>*<sub>BF:4</sub>*<sub>BF+3</sub> := c",
                "if (FRA) is an SNaN or",
                "   (FRB) is an SNaN then",
                "     VXSNAN := 1",
                "     if VE = 0 then VXVC := 1",
                "else if (FRA) is a QNaN or",
                "   (FRB) is a QNaN then VXVC := 1"
            ],
            "body": [
                "The floating-point operand in register FRA is compared ",
                "to the floating-point operand in register FRB. The result ",
                "of the compare is placed into CR field BF and the FPCC.",
                "If either of the operands is a NaN, either quiet or signal",
                "ing, then CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling NaN, ",
                "then VXSNAN is set and, if Invalid Operation is disabled ",
                "(VE=0), VXVC is set. If neither operand is a Signaling NaN ",
                "but at least one operand is a Quiet NaN, then VXVC is ",
                "set."
            ]
        },
        {
            "description": "Floating Compare Unordered",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcmpu",
                    "regs": [ "BF,FRA,FRB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "0" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if (FRA) is a NaN or",
                "   (FRB) is a NaN then c := 0b0001",
                "else if (FRA) < (FRB) then c := 0b1000",
                "else if (FRA) > (FRB) then c := 0b0100",
                "else                       c := 0b0010",
                "FPCC := c",
                "CR<sub>4</sub>*<sub>BF:4</sub>*<sub>BF+3</sub> := c",
                "if (FRA) is an SNaN or",
                "   (FRB) is an SNaN then",
                "     VXSNAN := 1"
            ],
            "body": [
                "The floating-point operand in register FRA is compared ",
                "to the floating-point operand in register FRB. The result ",
                "of the compare is placed into CR field BF and the FPCC.",
                "If either of the operands is a NaN, either quiet or signal",
                "ing, then CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling NaN, ",
                "then VXSNAN is set."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Signed Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctid",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fctid.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "814" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x8000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 263-1, then the ",
                "result is 0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 263, then ",
                "the result is 0x8000_0000_0000_0000 and VXCVI is set to ",
                "1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Signed Word format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctiw",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P2"
                },
                {
                    "mnemonic": "fctiw.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P2"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "14" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x8000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 231-1, then the ",
                "result is 0x7FFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than -231, then ",
                "the result is 0x8000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Unsigned Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctidu",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctidu.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "942" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x0000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 264-1, then the ",
                "result is 0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0, then the ",
                "result is 0x0000_0000_0000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Double-Precision To Unsigned Word format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctiwu",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctiwu.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "142" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x0000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode specified by RN.",
                "If the rounded value is greater than 232-1, then the ",
                "result is 0xFFFF_FFFF and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0,  then the ",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with round Signed Doubleword to Double-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcfid",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fcfid.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "846" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 64-bit signed fixed-point operand in register FRB is ",
                "converted to an infinitely precise floating-point integer. ",
                "The result of the conversion is rounded to double-preci",
                "sion, using the rounding mode specified by RN, and ",
                "placed into register FRT.",
                "The conversion is described fully in SectionA.3, “Float",
                "ing-Point Convert from Integer Model”.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " "
            ]
        },
        {
            "description": "Floating Convert with round Signed Doubleword to Single-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcfids",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fcfids.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "846" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 64-bit signed fixed-point operand in register FRB is ",
                "converted to an infinitely precise floating-point integer. ",
                "The result of the conversion is rounded to single-preci",
                "sion, using the rounding mode specified by RN, and ",
                "placed into register FRT.",
                "The conversion is described fully in SectionA.3, “Float",
                "ing-Point Convert from Integer Model”.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " "
            ]
        },
        {
            "description": "Floating Convert with round Unsigned Doubleword to Double-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcfidu",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fcfidu.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "974" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 64-bit unsigned fixed-point operand in register FRB ",
                "is converted to an infinitely precise floating-point inte",
                "ger. The result of the conversion is rounded to dou",
                "ble-precision, using the rounding mode specified by RN, ",
                "and placed into register FRT.",
                "The conversion is described fully in SectionA.3, “Float",
                "ing-Point Convert from Integer Model”.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " "
            ]
        },
        {
            "description": "Floating Convert with round Unsigned Doubleword to Single-Precision format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcfidus",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fcfidus.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "974" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The 64-bit unsigned fixed-point operand in register FRB ",
                "is converted to an infinitely precise floating-point inte",
                "ger. The result of the conversion is rounded to sin",
                "gle-precision, using the rounding mode specified by RN, ",
                "and placed into register FRT.",
                "The conversion is described fully in SectionA.3, “Float",
                "ing-Point Convert from Integer Model”.",
                "FPRF is set to the class and sign of the result. FR is set if ",
                "the result is incremented when rounded. FI is set if the ",
                "result is inexact.",
                " ",
                "The Floating Round to Integer instructions provide ",
                "direct support for rounding functions found in high level ",
                "languages. For example, frin, friz, frip, and frim imple",
                "ment C++ round(), trunc(), ceil(), and floor(), respec",
                "tively. Note that frin does not implement the IEEE ",
                "Round to Nearest function, which is often further ",
                "described as “ties to even.” The rounding performed by ",
                "these instructions is described fully in SectionA.4, ",
                "“Floating-Point Round to Integer Model” on page1018. ",
                "  ",
                "  ",
                "  "
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Signed Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctidz",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fctidz.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "815" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x8000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 263-1, then the ",
                "result is 0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 263, then ",
                "the result is 0x8000_0000_0000_0000 and VXCVI is set to ",
                "1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Signed Word fomat",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctiwz",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P2"
                },
                {
                    "mnemonic": "fctiwz.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P2"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "15" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x8000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 231-1, then the ",
                "result is 0x7FFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than -231, then ",
                "the result is 0x8000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit signed-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Unsigned Doubleword format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctiduz",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctiduz.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "943" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is ",
                "0x0000_0000_0000_0000, VXCVI is set to 1, and, if src is ",
                "an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 264-1, then the ",
                "result is 0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0, then the ",
                "result is 0x0000_0000_0000_0000, and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT.",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Convert with truncate Double-Precision To Unsigned Word format",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fctiwuz",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "fctiwuz.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "143" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src be the double-precision floating-point value in ",
                "FRB.",
                "If src is a NaN, then the result is 0x0000_0000, VXCVI is ",
                "set to 1, and, if src is an SNaN, VXSNAN is set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round toward Zero.",
                "If the rounded value is greater than 232-1, then the ",
                "result is 0xFFFF_FFFF and VXCVI is set to 1. ",
                "Otherwise, if the rounded value is less than 0.0,  then ",
                "the result is 0x0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit unsigned-integer format, and XX is set to 1 if the ",
                "result is inexact.",
                "If an enabled Invalid Operation Exception does not ",
                "occur, then the result is placed into FRT<sub>32:63</sub> and FRT<sub>0:31</sub> ",
                "is undefined,",
                "The conversion is described fully in SectionA.2, “Float",
                "ing-Point Convert to Integer Model” on page1013.",
                "Except for enabled Invalid Operation Exceptions, FPRF ",
                "is undefined. FR is set if the result is incremented when ",
                "rounded. FI is set if the result is inexact."
            ]
        },
        {
            "description": "Floating Copy Sign",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fcpsgn",
                    "regs": [ "FRT, FRA, FRB", "(", "Rc=0", ")" ],
                    "release": "v2.05"
                },
                {
                    "mnemonic": "fcpsgn.",
                    "regs": [ "FRT, FRA, FRB", "(", "Rc=1", ")" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "8" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of register FRB with bit 0 set to the value of ",
                "bit 0 of register FRA are placed into register FRT."
            ]
        },
        {
            "description": "Floating Divide",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fdiv",
                    "regs": [ "FRT,FRA,FRB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fdiv.",
                    "regs": [ "FRT,FRA,FRB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "18" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Divide Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fdivs",
                    "regs": [ "FRT,FRA,FRB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fdivs.",
                    "regs": [ "FRT,FRA,FRB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "18" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRA is divided by ",
                "the floating-point operand in register FRB. The remain",
                "der is not supplied as a result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Floating-point division is based on exponent subtrac",
                "tion and division of the significands.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1 and Zero ",
                "Divide Exceptions when ZE=1."
            ]
        },
        {
            "description": "Floating Merge Even Word",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmrgew",
                    "regs": [ "FRT,FRA,FRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "966" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.FP=0 then FP_Unavailable()",
                "FPR[FRT].word[0] := FPR[FRA].word[0]",
                "FPR[FRT].word[1] := FPR[FRB].word[0]"
            ],
            "body": [
                "The contents of word element 0 of FPR[FRA] are placed ",
                "into word element 0 of FPR[FRT].",
                "The contents of word element 0 of FPR[FRB] are placed ",
                "into word element 1 of FPR[FRT].",
                "fmrgew is treated as a Floating-Point instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Floating Merge Odd Word",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmrgow",
                    "regs": [ "FRT,FRA,FRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "838" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.FP=0 then FP_Unavailable()",
                "FPR[FRT].word[0] := FPR[FRA].word[1]",
                "FPR[FRT].word[1] := FPR[FRB].word[1]"
            ],
            "body": [
                "The contents of word element 1 of FPR[FRA] are placed ",
                "into word element 0 of FPR[FRT].",
                "The contents of word element 1 of FPR[FRB] are placed ",
                "into word element 1 of FPR[FRT].",
                "fmrgow is treated as a Floating-Point instruction in ",
                "terms of resource availability.",
                "  "
            ]
        },
        {
            "description": "Floating Move Register",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmr",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmr.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "72" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of register FRB are placed into register FRT."
            ]
        },
        {
            "description": "Floating Multiply",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmul",
                    "regs": [ "FRT,FRA,FRC", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmul.",
                    "regs": [ "FRT,FRA,FRC", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "25" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Multiply Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmuls",
                    "regs": [ "FRT,FRA,FRC", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fmuls.",
                    "regs": [ "FRT,FRA,FRC", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "25" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Floating-point multiplication is based on exponent addi",
                "tion and multiplication of the significands.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Multiply-Add",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmadd",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmadd.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "29" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Multiply-Add Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmadds",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fmadds.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "29" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is added to this inter",
                "mediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Multiply-Subtract",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmsub",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fmsub.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "28" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Multiply-Subtract Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fmsubs",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fmsubs.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "28" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is subtracted from this ",
                "intermediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Negate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fneg",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fneg.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "40" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of register FRB with bit 0 inverted are ",
                "placed into register FRT."
            ]
        },
        {
            "description": "Floating Negative Absolute Value",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fnabs",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fnabs.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "136" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of register FRB with bit 0 set to one are ",
                "placed into register FRT."
            ]
        },
        {
            "description": "Floating Negative Multiply-Add",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fnmadd",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fnmadd.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "31" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Negative Multiply-Add Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fnmadds",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fnmadds.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "31" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is added to this inter",
                "mediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN, then negated ",
                "and placed into register FRT.",
                "This instruction produces the same result as would be ",
                "obtained by using the Floating Multiply-Add instruction ",
                "and then negating the result, with the following excep",
                "tions.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Negative Multiply-Subtract",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fnmsub",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fnmsub.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "30" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Negative Multiply-Subtract Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fnmsubs",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fnmsubs.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "30" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The operation",
                "The floating-point operand in register FRA is multiplied ",
                "by the floating-point operand in register FRC. The float",
                "ing-point operand in register FRB is subtracted from this ",
                "intermediate result.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN, then negated ",
                "and placed into register FRT.",
                "This instruction produces the same result as would be ",
                "obtained by using the Floating Multiply-Subtract ",
                "instruction and then negating the result, with the follow",
                "ing exceptions.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Reciprocal Estimate",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fre",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "fre.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "24" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Reciprocal Estimate Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fres",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fres.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "24" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "An estimate of the reciprocal of the floating-point ",
                "operand in register FRB is placed into register FRT. ",
                "Unless the reciprocal would be a zero, an infinity, the ",
                "result of a trap-disabled Overflow exception, or a ",
                "QNaN, the estimate is correct to a precision of one ",
                "part in 256 of the reciprocal of (FRB), i.e.,",
                "where x is the initial value in FRB. ",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1 and Zero ",
                "Divide Exceptions when ZE=1.",
                "The results of executing this instruction may vary ",
                "between implementations, and between different exe",
                "cutions on the same implementation.",
                "  "
            ]
        },
        {
            "description": "Floating Reciprocal Square Root Estimate",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "frsqrte",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "frsqrte.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "26" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Reciprocal Square Root Estimate Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "frsqrtes",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frsqrtes.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "26" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "A estimate of the reciprocal of the square root of the ",
                "floating-point operand in register FRB is placed into reg",
                "ister FRT. The estimate placed into register FRT is correct ",
                "to a precision of one part in 32 of the reciprocal of the ",
                "square root of (FRB), i.e.,",
                "where x is the initial value in FRB. ",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1 and Zero ",
                "Divide Exceptions when ZE=1.",
                "The results of executing this instruction may vary ",
                "between implementations, and between different exe",
                "cutions on the same implementation.",
                "  "
            ]
        },
        {
            "description": "Floating Round to Integer Minus",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "frim",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frim.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "488" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value using the rounding mode round ",
                "toward -infinity, and the result is placed into register FRT. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Round to Integer Nearest",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "frin",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frin.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "392" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value as follows, with the result placed into ",
                "register FRT. If the sign of the operand is positive, ",
                "(FRB)+0.5 is truncated to an integral value, otherwise ",
                "(FRB)-0.5 is truncated to an integral value. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1. "
            ]
        },
        {
            "description": "Floating Round to Integer Plus",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "frip",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "frip.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "456" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value using the rounding mode round ",
                "toward +infinity, and the result is placed into register ",
                "FRT. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Round to Integer Toward Zero",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "friz",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "v2.02"
                },
                {
                    "mnemonic": "friz.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "424" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "an integral value using the rounding mode round ",
                "toward zero, and the result is placed into register FRT. ",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE = 1."
            ]
        },
        {
            "description": "Floating Round to Single-Precision",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "frsp",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "frsp.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "12" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRB is rounded to ",
                "single-precision, using the rounding mode specified by ",
                "RN, and placed into register FRT.",
                "The rounding is described fully in SectionA.1, “Float",
                "ing-Point Round to Single-Precision Model” on ",
                "page1009.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Select",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fsel",
                    "regs": [ "FRT,FRA,FRC,FRB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fsel.",
                    "regs": [ "FRT,FRA,FRC,FRB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "FRC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "23" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "if (FRA) ³ 0.0 then FRT := (FRC)",
                "else FRT := (FRB)"
            ],
            "body": [
                "The floating-point operand in register FRA is compared ",
                "to the value zero. If the operand is greater than or equal ",
                "to zero, register FRT is set to the contents of register ",
                "FRC. If the operand is less than zero or is a NaN, regis",
                "ter FRT is set to the contents of register FRB. The com",
                "parison ignores the sign of zero (i.e., regards +0 as ",
                "equal to -0).",
                "fsel Usage Notes ",
                "This section gives examples of how the Floating Select instruction can be used to implement certain simple forms of ",
                "if-then-else constructions, without branching.",
                "The examples show program fragments in an imaginary, C-like, high-level programming language, and the corre",
                "sponding program fragment using fsel and other Power ISA instructions. In the examples, a, b, x, y, and z are ",
                "floating-point variables, which are assumed to be in FPRs fa, fb, fx, fy, and fz. FPR fs is assumed to be available for ",
                "scratch space.",
                "Warning: Care must be taken in using fsel if IEEE compatibility is required, or if the values being tested can be NaNs ",
                "or infinities; see Section.",
                "Comparison to Zero",
                "Simple if-then-else Constructions",
                "Notes:",
                "The following Notes apply to the preceding examples ",
                "and to the corresponding cases using the other three ",
                "arithmetic relations (<, £, and ¹). They should also be ",
                "considered when any other use of fsel is contemplated.",
                "In these Notes, the “optimized program” is the Power ",
                "ISA program shown, and the “unoptimized pro",
                "gram” (not shown) is the corresponding Power ISA ",
                "program that uses fcmpu and Branch Conditional ",
                "instructions instead of fsel.",
                ""
            ]
        },
        {
            "description": "Floating Square Root",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fsqrt",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "P2"
                },
                {
                    "mnemonic": "fsqrt.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "P2"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "22" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Square Root Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fsqrts",
                    "regs": [ "FRT,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fsqrts.",
                    "regs": [ "FRT,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "22" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The square root of the floating-point operand in register ",
                "FRB is placed into register FRT.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "FPSCR<sub>FPRF</sub> is set to the class and sign of the result, ",
                "except for Invalid Operation Exceptions when ",
                "FPSCR<sub>VE</sub><sub>=1</sub>."
            ]
        },
        {
            "description": "Floating Subtract",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fsub",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "fsub.",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "20" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Floating Subtract Single",
            "form": "A-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "fsubs",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "fsubs.",
                    "regs": [ "FRT,FRA,FRB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "FRT", "size": "5" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "5", "value": "20" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The floating-point operand in register FRB is subtracted ",
                "from the floating-point operand in register FRA.",
                "If the most significant bit of the resultant significand is ",
                "not 1, the result is normalized. The result is rounded to ",
                "the target precision under control of RN and placed into ",
                "register FRT.",
                "The execution of the Floating Subtract instruction is ",
                "identical to that of Floating Add, except that the con",
                "tents of FRB participate in the operation with the sign bit ",
                "(bit 0) inverted.",
                "FPRF is set to the class and sign of the result, except for ",
                "Invalid Operation Exceptions when VE=1."
            ]
        },
        {
            "description": "Floating Test for software Divide ",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "f",
                    "regs": [ "tdiv", "BF,FRA,FRB" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "FRA", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "128" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let e_a be the unbiased exponent of the double-preci",
                "sion floating-point operand in register FRA.",
                "Let e_b be the unbiased exponent of the double-preci",
                "sion floating-point operand in register FRB.",
                "fe_flag is set to 1 if any of the following conditions ",
                "occurs.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 if either of the following conditions ",
                "occurs.",
                "Otherwise fg_flag is set to 0.",
                "If the implementation guarantees a relative error of ",
                "fre[s][.] of less than or equal to 2-14, then fl_flag is set ",
                "to 1. Otherwise fl_flag is set to 0.",
                "CR field BF is set to the value ",
                "fl_flag||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "Floating Test for software Square Root",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "f",
                    "regs": [ "tsqrt", "BF,FRB" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "160" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let e_b be the unbiased exponent of the double-preci",
                "sion floating-point operand in register FRB.",
                "fe_flag is set to 1 if either of the following conditions ",
                "occurs.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 if the following condition occurs.",
                "Otherwise fg_flag is set to 0.",
                "If the implementation guarantees a relative error of ",
                "frsqrte[s][.] of less than or equal to 2-14, then fl_flag is ",
                "set to 1. Otherwise fl_flag is set to 0.",
                "CR field BF is set to the value ",
                "fl_flag||fg_flag||fe_flag||0b0.",
                " ",
                "",
                "These instructions combine a multiply and an add oper",
                "ation without an intermediate rounding operation. The ",
                "fraction part of the intermediate product is 106 bits wide ",
                "(L bit, FRACTION), and all 106 bits take part in the add/",
                "subtract portion of the instruction.",
                "Status bits are set as follows."
            ]
        },
        {
            "description": "Integer Select",
            "form": "A-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "isel",
                    "regs": [ "RT,RA,RB,BC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "BC", "size": "5" },
                { "name": "opcode", "size": "5", "value": "15" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA=0 then a := 0 else a := (RA)",
                "if CR<sub>BC+32</sub>=1 then",
                "   RT := a",
                "else ",
                "   RT := (RB)"
            ],
            "body": [
                "If the contents of bit BC+32 of the Condition Register are ",
                "equal to 1, then the contents of register RA (or 0) are ",
                "placed into register RT. Otherwise, the contents of regis",
                "ter RB are placed into register RT.",
                "Examples of extended mnemonics for Integer Select:"
            ]
        },
        {
            "description": "Load Byte and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbz",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "34" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “lbz”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plbz” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plbz” & R=1 then7",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 1))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lbz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plbz with R=0, let EA be the sum of the contents of ",
                "register RA, or the value 0 if RA=0, and the value d0||d1, ",
                "sign-extended to 64 bits.",
                "For plbz with R=1, let EA be the sum of the address of ",
                "the instruction and the value d0||d1, sign-extended to 64 ",
                "bits.",
                "The byte in storage addressed by EA is loaded into ",
                "RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "",
                "For plbz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Byte and Zero:"
            ]
        },
        {
            "description": "Prefixed Load Byte and Zero",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "plbz",
                    "regs": [ "RT,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "34" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lbz”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plbz” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plbz” & R=1 then7",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 1))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lbz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plbz with R=0, let EA be the sum of the contents of ",
                "register RA, or the value 0 if RA=0, and the value d0||d1, ",
                "sign-extended to 64 bits.",
                "For plbz with R=1, let EA be the sum of the address of ",
                "the instruction and the value d0||d1, sign-extended to 64 ",
                "bits.",
                "The byte in storage addressed by EA is loaded into ",
                "RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "",
                "For plbz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Byte and Zero:"
            ]
        },
        {
            "description": "Load Byte and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbzx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "87" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The byte in storage addressed by EA ",
                "is loaded into RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0."
            ]
        },
        {
            "description": "Load Byte and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbzu",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "35" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "The byte in storage addressed by EA is loaded into ",
                "RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Byte and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbzux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "119" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The byte in storage addressed by EA is ",
                "loaded into RT<sub>56:63</sub>. RT<sub>0:55</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Doubleword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ld",
                    "regs": [ "RT,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "58" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "0" }
            ],
            "code": [
                "if “ld”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pld” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pld” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For ld, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pld with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pld with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into RT.",
                "",
                "For pld, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Doubleword:"
            ]
        },
        {
            "description": "Prefixed Load Doubleword",
            "form": "8LS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pld",
                    "regs": [ "RT,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "57" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “ld”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pld” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pld” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For ld, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pld with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pld with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into RT.",
                "",
                "For pld, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Doubleword:"
            ]
        },
        {
            "description": "Load Doubleword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldbrx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "532" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 8)",
                "RT :=  load_data<sub>56:63</sub> || load_data<sub>48:55</sub>",
                "|| load_data<sub>40:47</sub> || load_data<sub>32:39</sub>",
                "|| load_data<sub>24:31</sub> || load_data<sub>16:23</sub>",
                "|| load_data<sub>8:15</sub>  || load_data<sub>0:7</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "Bits 0:7 of the doubleword in storage addressed by EA ",
                "are loaded into RT<sub>56:63</sub>. ",
                "Bits 8:15 of the doubleword in storage addressed by EA ",
                "are loaded into RT<sub>48:55</sub>. ",
                "Bits 16:23 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>40:47</sub>. ",
                "Bits 24:31 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>32:39</sub>. ",
                "Bits 32:39 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>24:31</sub>. ",
                "Bits 40:47 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>16:23</sub>. ",
                "Bits 48:55 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>8:15</sub>. ",
                "Bits 56:63 of the doubleword in storage addressed by ",
                "EA are loaded into RT<sub>0:7</sub>."
            ]
        },
        {
            "description": "Load Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "21" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The doubleword in storage ",
                "addressed by EA is loaded into RT."
            ]
        },
        {
            "description": "Load Doubleword with Update",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldu",
                    "regs": [ "RT,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "58" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "1" }
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(DS||0b00)</sub>. The doubleword in storage ",
                "addressed by EA is loaded into RT.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Doubleword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "53" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The doubleword in storage addressed ",
                "by EA is loaded into RT.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfd",
                    "regs": [ "FRT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "50" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “lfd”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plfd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plfd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "",
                "For plfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Prefixed Load Floating-Point Double",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "lfd", "FRT,D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "50" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lfd”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plfd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plfd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "",
                "For plfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Load Floating-Point Double Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfdx",
                    "regs": [ "FRT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "599" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT."
            ]
        },
        {
            "description": "Load Floating-Point Double Pair",
            "form": "DS-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfdp",
                    "regs": [ "FRTp,DS(RA)" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "57" },
                { "name": "FRTp", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "0" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b :=(RA)",
                "EA := b + EXTS(DS||0b00)",
                "FRTp<sub>even</sub> := MEM(EA,8)",
                "FRTp<sub>odd </sub> := MEM(EA+8, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(DS||0b00)</sub>. ",
                "The doubleword in storage addressed by EA is placed ",
                "into the even-numbered register of FRTp. ",
                "The doubleword in storage addressed by EA+8 is placed ",
                "into the odd-numbered register of FRTp. ",
                "If FRTp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double Pair Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfdpx",
                    "regs": [ "FRTp,RA,RB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRTp", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "791" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRTp<sub>even</sub> := MEM(EA,8)",
                "FRTp<sub>odd </sub> := MEM(EA+8, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "The doubleword in storage addressed by EA is placed ",
                "into the even-numbered register of FRTp. ",
                "The doubleword in storage addressed by EA+8 is placed ",
                "into the odd-numbered register of FRTp. ",
                "If FRTp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfdu",
                    "regs": [ "FRT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "51" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "FRT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Double with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfdux",
                    "regs": [ "FRT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "631" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "FRT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The doubleword in storage addressed by EA is loaded ",
                "into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Single",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfs",
                    "regs": [ "FRT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "48" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “lfs”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plfs” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plfs” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is interpreted as ",
                "a floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "",
                "For plfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Prefixed Load Floating-Point Single",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "lfs", "FRT,D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "48" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lfs”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plfs” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plfs” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is interpreted as ",
                "a floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "",
                "For plfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Load Floating-Point Single Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfsx",
                    "regs": [ "FRT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "535" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is interpreted as a ",
                "floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT."
            ]
        },
        {
            "description": "Load Floating-Point Single with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfsu",
                    "regs": [ "FRT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "49" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "FRT := DOUBLE(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The word in storage addressed by EA is interpreted as a ",
                "floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point Single with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfsux",
                    "regs": [ "FRT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "567" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "FRT := DOUBLE(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is interpreted as a ",
                "floating-point single-precision operand. This word is ",
                "converted to floating-point double format (see ",
                "page163) and placed into register FRT.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Floating-Point as Integer Word & Zero Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfiwzx",
                    "regs": [ "FRT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "887" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := 320 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is loaded into ",
                "FRT<sub>32:63</sub>. FRT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Load Floating-Point as Integer Word Algebraic Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lfiwax",
                    "regs": [ "FRT,RA,RB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "855" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The word in storage addressed by EA is loaded into ",
                "FRT<sub>32:63</sub>. FRT<sub>0:31</sub> are filled with a copy of bit 0 of the ",
                "loaded word."
            ]
        },
        {
            "description": "Load Halfword Algebraic",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lha",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "42" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “lha”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plha” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plha” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lha, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plha with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plha with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of bit 0 of the loaded ",
                "halfword.",
                "",
                "For plha, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword Alge",
                "braic:"
            ]
        },
        {
            "description": "Prefixed Load Halfword Algebraic",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "plha",
                    "regs": [ "RT,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "42" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lha”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plha” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plha” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lha, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plha with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plha with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of bit 0 of the loaded ",
                "halfword.",
                "",
                "For plha, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword Alge",
                "braic:"
            ]
        },
        {
            "description": "Load Halfword Algebraic Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhax",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "343" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The halfword in storage addressed ",
                "by EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy ",
                "of bit 0 of the loaded halfword."
            ]
        },
        {
            "description": "Load Halfword Algebraic with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhau",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "43" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA) +<sub>D</sub>. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of bit 0 of the loaded ",
                "halfword.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword Algebraic with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhaux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "375" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The halfword in storage addressed by ",
                "EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are filled with a copy of ",
                "bit 0 of the loaded halfword.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhbrx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "790" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 2)",
                "RT := <sup>48</sup>0 || load_data<sub>8:15</sub> || load_data<sub>0:7</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "Bits 0:7 of the halfword in storage addressed by EA are ",
                "loaded into RT<sub>56:63</sub>. ",
                "Bits 8:15 of the halfword in storage addressed by EA are ",
                "loaded into RT<sub>48:55</sub>. ",
                "RT<sub>0:47</sub> are set to 0."
            ]
        },
        {
            "description": "Load Halfword and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhz",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "40" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “lhz”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plhz” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plhz” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lhz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plhz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plhz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "",
                "For plhz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword and ",
                "Zero:"
            ]
        },
        {
            "description": "Prefixed Load Halfword and Zero",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "plhz",
                    "regs": [ "RT,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "40" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lhz”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plhz” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plhz” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 2))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lhz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plhz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plhz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "",
                "For plhz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Halfword and ",
                "Zero:"
            ]
        },
        {
            "description": "Load Halfword and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhzx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "279" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The halfword in storage addressed ",
                "by EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0."
            ]
        },
        {
            "description": "Load Halfword and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhzu",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "41" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhzux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "311" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The halfword in storage addressed by ",
                "EA is loaded into RT<sub>48:63</sub>. RT<sub>0:47</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Multiple Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lmw",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "46" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RT",
                "do while r <= 31",
                "   GPR(r) := <sup>32</sup>0 || MEM(EA, 4)",
                "   r := r + 1",
                "   EA := EA + 4"
            ],
            "body": [
                "Let n = (32-RT). Let the effective address (EA) be the ",
                "sum (RA|0)+<sub>D</sub>.",
                "n consecutive words starting at EA are loaded into the ",
                "low-order 32 bits of GPRs RT through 31. The ",
                "high-order 32 bits of these GPRs are set to zero.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Load String Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lswi",
                    "regs": [ "RT,RA,NB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "NB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "597" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RT - 1",
                "i := 32",
                "do while n > 0",
                "   if i = 32 then",
                "      r := r + 1 (mod 32)",
                "      GPR(r) := 0",
                "   GPR(r)<sub>i:i+7</sub> := MEM(EA, 1)",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB¹0, n = 32 if NB=0; n is the number of bytes to load. Let ",
                "nr=CEIL(n/4); nr is the number of registers to receive ",
                "data.",
                "n consecutive bytes starting at EA are loaded into GPRs ",
                "RT through RT+nr-1. Data are loaded into the low-order ",
                "four bytes of each GPR; the high-order four bytes are ",
                "set to 0.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If the low-order four bytes of register RT+nr-1 ",
                "are only partially filled, the unfilled low-order byte(s) of ",
                "that register are set to 0.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Load String Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lswx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "533" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER<sub>57:63</sub>",
                "r := RT - 1",
                "i := 32",
                "RT := undefined",
                "do while n > 0",
                "   if i = 32 then",
                "      r := r + 1 (mod 32)",
                "      GPR(r) := 0",
                "   GPR(r)<sub>i:i+7</sub> := MEM(EA, 1)",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. Let n=XER<sub>57:63</sub>; n is the number of ",
                "bytes to load. Let nr=CEIL(n/4); nr is the number of reg",
                "isters to receive data.",
                "If n>0, n consecutive bytes starting at EA are loaded into ",
                "GPRs RT through RT+nr-1. Data are loaded into the ",
                "low-order four bytes of each GPR; the high-order four ",
                "bytes are set to 0.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If the low-order four bytes of register RT+nr-1 ",
                "are only partially filled, the unfilled low-order byte(s) of ",
                "that register are set to 0.",
                "If n=0, the contents of register RT are undefined.",
                "If RA or RB is in the range of registers to be loaded, ",
                "including the case in which RA=0, the instruction is ",
                "treated as if the instruction form were invalid. If RT=RA or ",
                "RT=RB, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode and n>0, the sys",
                "tem alignment error handler is invoked."
            ]
        },
        {
            "description": "Load VSX Scalar Doubleword",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsd",
                    "regs": [ "VRT,DS(RA)" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "57" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "2" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “lxsd”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “plxsd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plxsd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[VRT+32].dword[0] ~ MEM(EA,8)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxsd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxsd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, let ",
                "load_data be the contents of the doubleword in storage ",
                "at address EA such that;",
                "load_data is placed into doubleword element 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxsd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Prefixed Load VSX Scalar Doubleword",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "lxsd", "VRT", ",D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "42" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “lxsd”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “plxsd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plxsd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[VRT+32].dword[0] ~ MEM(EA,8)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxsd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxsd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, let ",
                "load_data be the contents of the doubleword in storage ",
                "at address EA such that;",
                "load_data is placed into doubleword element 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxsd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Load VSX Scalar Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsdx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "588" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "VSR[32×TX+T].dword[0] ~ MEM(EA,8)",
                "VSR[32×TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "load_data is placed into doubleword element 0 of ",
                "VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar Single-Precision",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxssp",
                    "regs": [ "VRT,DS(RA)" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "57" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "3" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if “lxssp”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “plxssp” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plxssp” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "load_data ~ MEM(EA,4)",
                "result ~ bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] ~ bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For plxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data, interpreted as a single-precision ",
                "floating-point value, is placed into doubleword element ",
                "0 of VSR[VRT+32] in double-precision format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Single:"
            ]
        },
        {
            "description": "Prefixed Load VSX Scalar Single-Precision",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "lxssp", "VRT", ",D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "43" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if “lxssp”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “plxssp” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plxssp” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "load_data ~ MEM(EA,4)",
                "result ~ bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] ~ bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value VRT + 32.",
                "For lxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For plxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For plxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data, interpreted as a single-precision ",
                "floating-point value, is placed into doubleword element ",
                "0 of VSR[VRT+32] in double-precision format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "",
                "For plxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Scalar ",
                "Single:"
            ]
        },
        {
            "description": "Load VSX Scalar Single-Precision Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsspx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "524" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "load_data ~ MEM(EA,4)",
                "result ~ bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] ~ bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data, interpreted as a single-precision ",
                "floating-point value, is placed in doubleword element 0 ",
                "of VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Byte & Zero Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsibzx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "781" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T].dword[0] ~ EXTZ64(MEM(EA,1))",
                "VSR[32×TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The unsigned integer in the byte in storage addressed ",
                "by EA is placed in doubleword element 0 of VSR[XT]. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Halfword & Zero Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsihzx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "813" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T].dword[0] ~ EXTZ64(MEM(EA,2))",
                "VSR[32×TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The unsigned integer in the halfword in storage ",
                "addressed by EA is placed in doubleword element 0 of ",
                "VSR[XT]. The contents of doubleword element 1 of ",
                "VSR[XT] are set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Word & Zero Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsiwzx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "12" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T].dword[0] := ExtendZero(MEM(EA,4))",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is zero-extended and placed in doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Scalar as Integer Word Algebraic Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxsiwax",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "76" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T].dword[0] := EXTS64(MEM(EA,4))",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is sign-extended to a doubleword and ",
                "placed in doubleword element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Vector",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxv",
                    "regs": [ "XT,DQ(RA)" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "61" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DQ", "size": "12" },
                { "name": "TX", "size": "1" },
                { "name": "opcode", "size": "3", "value": "1" }
            ],
            "code": [
                "if “lxv” & TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if “lxv” & TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "if “plxv” & MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “lxv”  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if “plxv” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plxv” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[32×TX+T] ~ MEM(EA,16)"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "For lxv, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For plxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into VSR[XT].",
                "",
                "For plxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Vector:"
            ]
        },
        {
            "description": "Prefixed Load VSX Vector",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pl",
                    "regs": [ "xv", "XT", ",D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "5", "value": "25" },
                { "name": "TX", "size": "1" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lxv” & TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if “lxv” & TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "if “plxv” & MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “lxv”  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if “plxv” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plxv” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[32×TX+T] ~ MEM(EA,16)"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "For lxv, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For plxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into VSR[XT].",
                "",
                "For plxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load VSX Vector:"
            ]
        },
        {
            "description": "Load VSX Vector Byte*16 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvb16x",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "876" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 15",
                "   VSR[32×TX+T].byte[i] ~ MEM(EA+i, 1)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 15, do the following.",
                "  ",
                "Loading a vector of 16 byte elements from Big-Endian ",
                "storage in VSR[XT] using lxvb16x, retaining left-to-right ",
                "element ordering.",
                "Loading a vector of 16 byte elements from ",
                "Little-Endian storage in VSR[XT] using lxvb16x, ",
                "retaining left-to-right element ordering."
            ]
        },
        {
            "description": "Load VSX Vector Doubleword & Splat Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvdsx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "332" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data ~ MEM(EA, 8)",
                "",
                "VSR[32×TX+T].dword[0] ~ load_data",
                "VSR[32×TX+T].dword[1] ~ load_data"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "load_data is copied into each doubleword element of ",
                "VSR[XT]."
            ]
        },
        {
            "description": "Load VSX Vector Doubleword*2 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvd2x",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "844" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T].dword[0] ~ MEM(EA, 8)",
                "VSR[32×TX+T].dword[1] ~ MEM(EA+8, 8)"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 1, do the following.",
                "  "
            ]
        },
        {
            "description": "Load VSX Vector Halfword*8 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvh8x",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "812" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 7",
                "   VSR[32×TX+T].hword[i] ~ MEM(EA+2×i, 2)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 7, do the following.",
                "  ",
                "Loading a vector of 8 halfword elements from ",
                "Big-Endian storage in VSR[XT] using lxvh8x, retaining ",
                "left-to-right element ordering.",
                "Loading a vector of 8 halfword elements from ",
                "Little-Endian storage in VSR[XT] using lxvh8x, retaining ",
                "left-to-right element ordering."
            ]
        },
        {
            "description": "Load VSX Vector Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "4", "value": "4" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "5", "value": "12" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T] ~ MEM(EA,16)"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into VSR[XT].",
                "Loading 16 bytes of data from Big-Endian storage in ",
                "VSR[XT] using lxvx.",
                "Loading 16 bytes of data from Little-Endian storage in ",
                "VSR[XT] using lxvx."
            ]
        },
        {
            "description": "Load VSX Vector Paired",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvp",
                    "regs": [ "XTp,DQ(RA)" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "6" },
                { "name": "Tp", "size": "4" },
                { "name": "TX", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "DQ", "size": "12" },
                { "name": "opcode", "size": "4", "value": "0" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if “lxvp” then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if “plxvp” then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "if “lxvp”        then EA ~ EAbase + EAdisp",
                "if “plxvp” & R=0 then EA ~ EAbase + EAdisp",
                "if “plxvp” & R=1 then EA ~ CIA    + EAdisp",
                "",
                "load_data ~ MEM(EA, 32)",
                "",
                "VSR[32×TX+2×Tp]   ~ load_data.bit[  0:127]",
                "VSR[32×TX+2×Tp+1] ~ load_data.bit[128:255]"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XTp be the value 32×TX + 2×Tp (i.e., only even ",
                "values of XTp can be encoded in the instruction).",
                "Let EAbase be the contents of GPR[RA], or 0 if RA=0.",
                "For lxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0, and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For plxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For plxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "Bits 0-127 of load_data are placed into VSR[XTp].",
                "",
                "",
                "For plxvp, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Load VSX Vector Paired Pre",
                "fixed:"
            ]
        },
        {
            "description": "Prefixed Load VSX Vector Paired",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "plxvp",
                    "regs": [ "XTp,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "58" },
                { "name": "Tp", "size": "4" },
                { "name": "TX", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if “lxvp” then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if “plxvp” then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "if “lxvp”        then EA ~ EAbase + EAdisp",
                "if “plxvp” & R=0 then EA ~ EAbase + EAdisp",
                "if “plxvp” & R=1 then EA ~ CIA    + EAdisp",
                "",
                "load_data ~ MEM(EA, 32)",
                "",
                "VSR[32×TX+2×Tp]   ~ load_data.bit[  0:127]",
                "VSR[32×TX+2×Tp+1] ~ load_data.bit[128:255]"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XTp be the value 32×TX + 2×Tp (i.e., only even ",
                "values of XTp can be encoded in the instruction).",
                "Let EAbase be the contents of GPR[RA], or 0 if RA=0.",
                "For lxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0, and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For plxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For plxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "Bits 0-127 of load_data are placed into VSR[XTp].",
                "",
                "",
                "For plxvp, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Load VSX Vector Paired Pre",
                "fixed:"
            ]
        },
        {
            "description": "Load VSX Vector Paired Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvpx",
                    "regs": [ "XTp,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "Tp", "size": "4" },
                { "name": "TX", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "333" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data ~ MEM(EA,32)",
                "VSR[32×TX+2×Tp]   ~ load_data.bit[  0:127]",
                "VSR[32×TX+2×Tp+1] ~ load_data.bit[128:255]"
            ],
            "body": [
                "Let XTp be the value 32×TX + 2×Tp (i.e., only even ",
                "values of XTp can be encoded in the instruction).",
                "Let the effective address (EA) be the sum of the integer ",
                "value in GPR[RA], or 0 if RA=0, and the integer value in ",
                "GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the octword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "Bits 0-127 of load_data are placed into VSR[XTp]."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Byte Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvrbx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "13" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32×TX+T] = EXTZ128(MEM(EA,1))"
            ],
            "body": [
                "Let XT be the value of 32×TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Load the contents of the byte in storage at address EA ",
                "into byte element 15 of VSR[XT]. The contents of byte ",
                "elements 0-14 of VSR[XT] are set to 0."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvrdx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "109" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32×TX+T] = EXTZ128(MEM(EA,8))"
            ],
            "body": [
                "Let XT be the value of 32×TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Load the contents of the doubleword in storage at ",
                "address EA into doubleword element 1 of VSR[XT]. The ",
                "contents of doubleword element 0 of VSR[XT] are set to ",
                "0.",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the doubleword in storage at address EA ",
                "are placed into load_data in such an order that;",
                "load_data is placed into doubleword element 1 of ",
                "VSR[XT]. The contents of doubleword element 0 of ",
                "VSR[XT] are set to 0."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Halfword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvrhx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "45" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32×TX+T] = EXTZ128(MEM(EA,2))"
            ],
            "body": [
                "Let XT be the value of 32×TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the halfword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the halfword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into halfword element 7 of VSR[XT]. ",
                "The contents of halfword elements 0-6 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "Load VSX Vector Rightmost Word Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvrwx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "77" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32×TX+T] = EXTZ128(MEM(EA,4))"
            ],
            "body": [
                "Let XT be the value of 32×TX + T.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is placed into word element 3 of VSR[XT]. ",
                "The contents of word elements 0-2 of VSR[XT] are set ",
                "to 0."
            ]
        },
        {
            "description": "Load VSX Vector Special Value Quadword",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvkq",
                    "regs": [ "XT,UIM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "31" },
                { "name": "UIM", "size": "5" },
                { "name": "opcode", "size": "10", "value": "360" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if UIM=0b00001 then VSR[32×TX+T] := 0x3FFF_0000_0000_0000_0000_0000_0000_0000  /* QP +1.0  */",
                "if UIM=0b00010 then VSR[32×TX+T] := 0x4000_0000_0000_0000_0000_0000_0000_0000  /* QP +2.0  */",
                "if UIM=0b00011 then VSR[32×TX+T] := 0x4000_8000_0000_0000_0000_0000_0000_0000  /* QP +3.0  */",
                "if UIM=0b00100 then VSR[32×TX+T] := 0x4001_0000_0000_0000_0000_0000_0000_0000  /* QP +4.0  */",
                "if UIM=0b00101 then VSR[32×TX+T] := 0x4001_4000_0000_0000_0000_0000_0000_0000  /* QP +5.0  */",
                "if UIM=0b00110 then VSR[32×TX+T] := 0x4001_8000_0000_0000_0000_0000_0000_0000  /* QP +6.0  */",
                "if UIM=0b00111 then VSR[32×TX+T] := 0x4001_C000_0000_0000_0000_0000_0000_0000  /* QP +7.0  */",
                "if UIM=0b01000 then VSR[32×TX+T] := 0x7FFF_0000_0000_0000_0000_0000_0000_0000  /* QP +Inf  */",
                "if UIM=0b01001 then VSR[32×TX+T] := 0x7FFF_8000_0000_0000_0000_0000_0000_0000  /* QP dQNaN */",
                "if UIM=0b10000 then VSR[32×TX+T] := 0x8000_0000_0000_0000_0000_0000_0000_0000  /* QP -0.0  */",
                "if UIM=0b10001 then VSR[32×TX+T] := 0xBFFF_0000_0000_0000_0000_0000_0000_0000  /* QP -1.0  */",
                "if UIM=0b10010 then VSR[32×TX+T] := 0xC000_0000_0000_0000_0000_0000_0000_0000  /* QP -2.0  */",
                "if UIM=0b10011 then VSR[32×TX+T] := 0xC000_8000_0000_0000_0000_0000_0000_0000  /* QP -3.0  */",
                "if UIM=0b10100 then VSR[32×TX+T] := 0xC001_0000_0000_0000_0000_0000_0000_0000  /* QP -4.0  */",
                "if UIM=0b10101 then VSR[32×TX+T] := 0xC001_4000_0000_0000_0000_0000_0000_0000  /* QP -5.0  */",
                "if UIM=0b10110 then VSR[32×TX+T] := 0xC001_8000_0000_0000_0000_0000_0000_0000  /* QP -6.0  */",
                "if UIM=0b10111 then VSR[32×TX+T] := 0xC001_C000_0000_0000_0000_0000_0000_0000  /* QP -7.0  */",
                "if UIM=0b11000 then VSR[32×TX+T] := 0xFFFF_0000_0000_0000_0000_0000_0000_0000  /* QP -Inf  */"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "UIM specifies one of a set of common values that is placed into VSR[XT]. Unspecified values of UIM are reserved."
            ]
        },
        {
            "description": "Load VSX Vector Word & Splat Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvwsx",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "364" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data ~ MEM(EA,4)",
                "",
                "do i = 0 to 3",
                "   VSR[32×TX+T].word[i] ~ load_data",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, the ",
                "contents of the word in storage at address EA are ",
                "placed into load_data in such an order that;",
                "When Little-Endian byte ordering is employed, the ",
                "contents of the quadword in storage at address EA are ",
                "placed into load_data in such an order that;",
                "load_data is copied into each word element of VSR[XT].",
                "Loading scalar word data from Big-Endian storage in ",
                "VSR[XT] using lxvwsx.",
                "Loading scalar word data from Little-Endian storage in ",
                "VSR[XT] using lxvwsx."
            ]
        },
        {
            "description": "Load VSX Vector Word*4 Indexed ",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvw4x",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "780" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32×TX+T].word[0] ~ MEM(EA, 4)",
                "VSR[32×TX+T].word[1] ~ MEM(EA+4, 4)",
                "VSR[32×TX+T].word[2] ~ MEM(EA+8, 4)",
                "VSR[32×TX+T].word[3] ~ MEM(EA+12, 4)"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 3, do the following.",
                "  "
            ]
        },
        {
            "description": "Load VSX Vector with Length",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvl",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "269" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ (RA=0) ? 0 : GPR[RA]",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb ~ 16",
                "",
                "load_data ~ 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "",
                "if MSR.LE = 0 then  // Big-Endian byte-ordering",
                "   load_data.byte[0:nb-1]   ~ MEM(EA,nb)",
                "else                // Little-Endian byte-ordering",
                "   load_data.byte[16-nb:15] ~ MEM(EA,nb)",
                "",
                "VSR[32×TX+T] ~ load_data"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed ",
                "and the contents of VSR[XT] are set to 0.",
                "Otherwise, when Big-Endian byte-ordering is ",
                "employed, do the following.",
                "Otherwise, when Little-Endian byte ordering is ",
                "employed, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Loading less than 16-byte data from Big-Endian ",
                "storage in VSR[XT] using lxvl.",
                "Loading less than 16-byte data from Little-Endian ",
                "storage in VSR[XT] using lxvl."
            ]
        },
        {
            "description": "Load VSX Vector with Length Left-justified",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "lxvll",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "301" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := (RA=0) ? 0 : GPR[RA]",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb ~ 16",
                "if nb>0 then do i = 0 to nb-1",
                "   VSR[32×TX+T].byte[i] := MEM(EA+i,1)",
                "end",
                "if nb<16 then do i = nb to 15",
                "   VSR[32×TX+T].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed ",
                "and the contents of VSR[XT] are set to 0.",
                "Otherwise, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Loading less than 16-byte data from storage in ",
                "VSR[XT], left-justified, using lxvll."
            ]
        },
        {
            "description": "Load Vector Element Byte Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvebx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "7" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "eb := EA.bit[60:63]",
                " ",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then ",
                "   VSR[VRT+32].byte[eb] := MEM(EA,1)",
                "else",
                "   VSR[VRT+32].byte[15-eb] := MEM(EA,1)"
            ],
            "body": [
                "Let EA be the sum of the contents of GPR[RA], or 0 if ",
                "RA=0, and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, the contents of the byte in storage at address ",
                "EA are placed into byte eb of VSR[VRT+32]. The ",
                "remaining bytes of VSR[VRT+32] are set to undefined ",
                "values.",
                "If Little-Endian byte ordering is used for the storage ",
                "access, the contents of the byte in storage at address ",
                "EA are placed into byte 15-eb of VSR[VRT+32]. The ",
                "remaining bytes of VSR[VRT+32] are set to undefined ",
                "values."
            ]
        },
        {
            "description": "Load Vector Element Halfword Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvehx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "39" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFE",
                "eb := EA.bit[60:63]",
                " ",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then ",
                "   VSR[VRT+32].byte[eb:eb+1] := MEM(EA,2)",
                "else",
                "   VSR[VRT+32].byte[14-eb:15-eb] := MEM(EA,2)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If Little-Endian byte ordering is used for the storage ",
                "access, "
            ]
        },
        {
            "description": "Load Vector Element Word Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvewx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "71" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFC",
                "eb := EA.bit[60:63]",
                "",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then ",
                "   VSR[VRT+32].byte[eb:eb+3] := MEM(EA,4)",
                "else",
                "   VSR[VRT+32].byte[12-eb:15-eb] := MEM(EA,4)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If if Little-Endian byte ordering is used for the storage ",
                "access, "
            ]
        },
        {
            "description": "Load Vector Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "103" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "VSR[VRT+32] := MEM(EA, 16)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of the quadword in storage at address EA ",
                "are placed into VSR[VRT+32]. "
            ]
        },
        {
            "description": "Load Vector Indexed Last",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvxl",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "359" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "VSR[VRT+32] := MEM(EA, 16)",
                "",
                "mark_as_not_likely_to_be_needed_again_anytime_soon(EA)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of the quadword in storage at address EA ",
                "are placed into VSR[VRT+32]. ",
                "lvxl provides a hint that the quadword in storage ",
                "addressed by EA will probably not be needed again by ",
                "the program in the near future.",
                ""
            ]
        },
        {
            "description": "Load Vector for Shift Left Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvsl",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "6" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "sh := (((RA=0) ? 0 : GPR[RA]) + GPR[RB]).bit[60:63]",
                "",
                "switch(sh)",
                "   case(0x0): VSR[VRT+32]:=0x000102030405060708090A0B0C0D0E0F",
                "   case(0x1): VSR[VRT+32]:=0x0102030405060708090A0B0C0D0E0F10",
                "   case(0x2): VSR[VRT+32]:=0x02030405060708090A0B0C0D0E0F1011",
                "   case(0x3): VSR[VRT+32]:=0x030405060708090A0B0C0D0E0F101112",
                "   case(0x4): VSR[VRT+32]:=0x0405060708090A0B0C0D0E0F10111213",
                "   case(0x5): VSR[VRT+32]:=0x05060708090A0B0C0D0E0F1011121314",
                "   case(0x6): VSR[VRT+32]:=0x060708090A0B0C0D0E0F101112131415",
                "   case(0x7): VSR[VRT+32]:=0x0708090A0B0C0D0E0F10111213141516",
                "   case(0x8): VSR[VRT+32]:=0x08090A0B0C0D0E0F1011121314151617",
                "   case(0x9): VSR[VRT+32]:=0x090A0B0C0D0E0F101112131415161718",
                "   case(0xA): VSR[VRT+32]:=0x0A0B0C0D0E0F10111213141516171819",
                "   case(0xB): VSR[VRT+32]:=0x0B0C0D0E0F101112131415161718191A",
                "   case(0xC): VSR[VRT+32]:=0x0C0D0E0F101112131415161718191A1B",
                "   case(0xD): VSR[VRT+32]:=0x0D0E0F101112131415161718191A1B1C",
                "   case(0xE): VSR[VRT+32]:=0x0E0F101112131415161718191A1B1C1D",
                "   case(0xF): VSR[VRT+32]:=0x0F101112131415161718191A1B1C1D1E"
            ],
            "body": [
                "Let sh be bits 60:63 of the sum of the contents of ",
                "GPR[RA], or 0 if RA=0, and the contents of GPR[RB].",
                "Let X be the 32-byte value 0x00 || 0x01 || 0x02 || … || 0x1D || ",
                "0x1E || 0x1F.",
                "Bytes sh to sh+15 of X are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Load Vector for Shift Right Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "lvsr",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "38" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "sh := (((RA=0) ? 0 : GPR[RA]) + GPR[RB]).bit[60:63]",
                "",
                "switch(sh)",
                "   case(0x0): VSR[VRT+32]:=0x101112131415161718191A1B1C1D1E1F",
                "   case(0x1): VSR[VRT+32]:=0x0F101112131415161718191A1B1C1D1E",
                "   case(0x2): VSR[VRT+32]:=0x0E0F101112131415161718191A1B1C1D",
                "   case(0x3): VSR[VRT+32]:=0x0D0E0F101112131415161718191A1B1C",
                "   case(0x4): VSR[VRT+32]:=0x0C0D0E0F101112131415161718191A1B",
                "   case(0x5): VSR[VRT+32]:=0x0B0C0D0E0F101112131415161718191A",
                "   case(0x6): VSR[VRT+32]:=0x0A0B0C0D0E0F10111213141516171819",
                "   case(0x7): VSR[VRT+32]:=0x090A0B0C0D0E0F101112131415161718",
                "   case(0x8): VSR[VRT+32]:=0x08090A0B0C0D0E0F1011121314151617",
                "   case(0x9): VSR[VRT+32]:=0x0708090A0B0C0D0E0F10111213141516",
                "   case(0xA): VSR[VRT+32]:=0x060708090A0B0C0D0E0F101112131415",
                "   case(0xB): VSR[VRT+32]:=0x05060708090A0B0C0D0E0F1011121314",
                "   case(0xC): VSR[VRT+32]:=0x0405060708090A0B0C0D0E0F10111213",
                "   case(0xD): VSR[VRT+32]:=0x030405060708090A0B0C0D0E0F101112",
                "   case(0xE): VSR[VRT+32]:=0x02030405060708090A0B0C0D0E0F1011",
                "   case(0xF): VSR[VRT+32]:=0x0102030405060708090A0B0C0D0E0F10"
            ],
            "body": [
                "Let sh be bits 60:63 of the sum of the contents of ",
                "GPR[RA], or 0 if RA=0, and the contents of GPR[RB].",
                "Let X be the 32-byte value 0x00 || 0x01 || 0x02 || … || 0x1D || ",
                "0x1E || 0x1F.",
                "Bytes 16-sh to 31-sh of X are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Load Word Algebraic",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwa",
                    "regs": [ "RT,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "58" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "2" }
            ],
            "code": [
                "if “lwa”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “plwa” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plwa” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwa, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For plwa with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwa with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit 0 of the loaded ",
                "word.",
                "",
                "For plwa, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word Alge",
                "braic:"
            ]
        },
        {
            "description": "Prefixed Load Word Algebraic",
            "form": "8LS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "plwa",
                    "regs": [ "RT,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "41" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lwa”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “plwa” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plwa” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwa, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For plwa with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwa with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit 0 of the loaded ",
                "word.",
                "",
                "For plwa, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word Alge",
                "braic:"
            ]
        },
        {
            "description": "Load Word Algebraic Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwax",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "341" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit ",
                "0 of the loaded word."
            ]
        },
        {
            "description": "Load Word Algebraic with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwaux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "373" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are filled with a copy of bit ",
                "0 of the loaded word.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwbrx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "534" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 4)",
                "RT := <sup>32</sup>0 || load_data<sub>24:31</sub> || load_data<sub>16:23</sub>",
                "         || load_data<sub>8:15</sub> || load_data<sub>0:7</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "Bits 0:7 of the word in storage addressed by EA are ",
                "loaded into RT<sub>56:63</sub>. ",
                "Bits 8:15 of the word in storage addressed by EA are ",
                "loaded into RT<sub>48:55</sub>. ",
                "Bits 16:23 of the word in storage addressed by EA are ",
                "loaded into RT<sub>40:47</sub>. ",
                "Bits 24:31 of the word in storage addressed by EA are ",
                "loaded into RT<sub>32:39</sub>. ",
                "RT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Load Word and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwz",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "32" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “lwz”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plwz” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plwz” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plwz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "",
                "For plwz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Prefixed Load Word and Zero",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "plwz",
                    "regs": [ "RT,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "32" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “lwz”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “plwz” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “plwz” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For lwz, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For plwz with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For plwz with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "",
                "For plwz, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Load Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Load Word and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "23" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. The word in storage addressed by EA ",
                "is loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Load Word and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzu",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "33" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA) +<sub>D</sub>. ",
                "The word in storage addressed by EA is loaded into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "55" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. The word in storage addressed by EA is ",
                "loaded into RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "19" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2nn",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "210" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvf16ger2” | “xvf16ger2pp” | “xvf16ger2pn” | “xvf16ger2np” | “xvf16ger2nn” then do",
                "   PMSK := 0b11",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] & YMSK.bit[j] then do",
                "         reset_flags()",
                "",
                "         src10 := bfp_CONVERT_FROM_BFP16((PMSK.bit[0]=0) ? 0x0000 : VSR[32×AX+A].word[i].hword[0])",
                "         src11 := bfp_CONVERT_FROM_BFP16((PMSK.bit[1]=0) ? 0x0000 : VSR[32×AX+A].word[i].hword[1])",
                "         src20 := bfp_CONVERT_FROM_BFP16((PMSK.bit[0]=0) ? 0x0000 : VSR[32×BX+B].word[j].hword[0])",
                "         src21 := bfp_CONVERT_FROM_BFP16((PMSK.bit[1]=0) ? 0x0000 : VSR[32×BX+B].word[j].hword[1])",
                "",
                "         p1    := bfp_MULTIPLY(src10, src20)",
                "         v1    := bfp_MULTIPLY_ADD(src11, src21, p1)",
                "         r1    := bfp_ROUND_TO_BFP32_NO_TRAP(FPSCR.RN, v1)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if ox_flag=1 then SetFX(FPSCR.OX)",
                "         if ux_flag=1 then SetFX(FPSCR.UX)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "         reset_flags()",
                "",
                "         if “[pm]xvf16ger2” then",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r1)",
                "",
                "         else do",
                "            acc := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "            if “[pm]xvf16ger2pp” then v2 := bfp_ADD(r1, acc)",
                "            if “[pm]xvf16ger2pn” then v2 := bfp_ADD(r1, bfp_NEGATE(acc))",
                "            if “[pm]xvf16ger2np” then v2 := bfp_ADD(bfp_NEGATE(r1), acc)",
                "            if “[pm]xvf16ger2nn” then v2 := bfp_ADD(bfp_NEGATE(r1), bfp_NEGATE(acc))",
                "",
                "            r2 := bfp_ROUND_TO_BFP32_NO_TRAP(FPSCR.RN, v2)",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "            if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "            if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "            if ox_flag=1 then SetFX(FPSCR.OX)",
                "            if ux_flag=1 then SetFX(FPSCR.UX)",
                "            if xx_flag=1 then SetFX(FPSCR.XX)",
                "         end",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of single-precision floating-point values.",
                "Let result be a 4×4 matrix of word elements to be used as a temporary Accumulator.",
                "For xvf16ger2, xvf16ger2pp, xvf16ger2pn, xvf16ger2np, or xvf16ger2nn, let PMSK=0b11, XMSK=0b1111, and ",
                "YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following.",
                "Unlike other VSX Vector Floating-Point instructions, ACC[AT] is always updated by the execution of the instruction, ",
                "even when a trap-enabled exception occurs. For every multiply-add operation that is performed as part of the ",
                "execution of this instruction, if an exception occurs as the result of that particular multiply-add operation, the ",
                "trap-disabled exception result is returned, even if that exception type is trap-enabled. Exception detection is based ",
                "on the trap-disable definition. Exception status is accumulated and the appropriate exception status bits in the ",
                "FPSCR are updated at the completion of execution of the instruction. Otherwise, behavior is the same as any vector ",
                "floating-point instruction that can cause an exception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2np",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "82" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2pn",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "146" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf16ger2pp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "18" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "75" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2pp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "107" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvi16ger2s” | “xvi16ger2spp” then do",
                "   PMSK := 0b11",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] & YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].hword[0]) * EXTS(VSR[32×BX+B].word[j].hword[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].hword[1]) * EXTS(VSR[32×BX+B].word[j].hword[1])",
                "",
                "         psum  := prod0 + prod1",
                "",
                "         if “[pm]xvi16ger2”   then ACC[AT][i].word[j] := CHOP32(psum)",
                "         if “[pm]xvi16ger2pp” then ACC[AT][i].word[j] := CHOP32(psum + EXTS(ACC[AT][i].word[j])",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of 32-bit signed integer values.",
                "For xvi16ger2 or xvi16ger2pp, let PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3 and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2s",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "43" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi16ger2spp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "42" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvi16ger2s” | “xvi16ger2spp” then do",
                "   PMSK := 0b11",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "sat_flag := 0",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] & YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].hword[0]) * EXTS(VSR[32×BX+B].word[j].hword[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].hword[1]) * EXTS(VSR[32×BX+B].word[j].hword[1])",
                "",
                "         psum  := prod0 + prod1",
                "",
                "         if “[pm]xvi16ger2s” then",
                "            ACC[AT][i].word[j] := si32_CLAMP( psum )",
                "         if “[pm]xvi16ger2spp” then",
                "            ACC[AT][i].word[j] := si32_CLAMP( psum + EXTS(ACC[AT][i].word[j] )",
                "",
                "         if sat_flag=1 then VSCR.SAT := 1",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of 32-bit signed integer values.",
                "For xvi16ger2s or xvi16ger2spp, let PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3 and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32ger",
                    "regs": [ "AT,XA,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "27" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gernn",
                    "regs": [ "AT,XA,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "218" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvf32ger” | “xvf32gerpp” | “xvf32gerpn” | “xvf32gernp” | “xvf32gernn” then do",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i]=1 & YMSK.bit[j]=1 then do",
                "         reset_flags()",
                "",
                "         src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "         src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[j])",
                "         acc  := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "         if “[pm]xvf32ger”   then v := bfp_MULTIPLY( src1, src2 )",
                "         if “[pm]xvf32gerpp” then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "         if “[pm]xvf32gerpn” then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if “[pm]xvf32gernp” then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if “[pm]xvf32gernn” then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "",
                "         r := bfp_ROUND_TO_BFP32_NO_TRAP(v)",
                "",
                "         if “[pm]xvf32gernp” then r := bfp_NEGATE(r)",
                "         if “[pm]xvf32gernn” then r := bfp_NEGATE(r)",
                "",
                "         ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if ox_flag=1 then SetFX(FPSCR.OX)",
                "         if ux_flag=1 then SetFX(FPSCR.UX)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "      end",
                "      else",
                "         ACC[AT][i].word[j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of single-precision floating-point values.",
                "For xvf32ger, xvf32gerpp, xvf32gerpn, xvf32gernp, or xvf32gernn, let XMSK=0b1111 and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following.",
                "Unlike other vector floating-point instructions, ACC[AT] is always updated by the execution of the instruction, even ",
                "when a trap-enabled exception occurs. For every multiply-add operation that is performed as part of the execution of ",
                "this instruction, if an exception occurs as the result of that particular multiply-add operation, the trap-disabled ",
                "exception result is returned, even if that exception type is trap-enabled. Exception detection is based on the ",
                "trap-disable definition. Exception status is  and the appropriate exception status bits in the FPSCR are updated at ",
                "the completion of execution of the instruction. Otherwise, behavior is the same as any vector floating-point ",
                "instruction that can cause an eaccumulatedxception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gernp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "90" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gerpn",
                    "regs": [ "AT,XA,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "154" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf32gerpp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "26" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 4-bit Signed Integer GER ( rank-8 update )",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi4ger8",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "35" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 4-bit Signed Integer GER ( rank-8 update ) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi4ger8pp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "34" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvi4ger8” | “xvi4ger8pp” then do",
                "   PMSK := 0b11111111",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] & YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[0]) * EXTS(VSR[32×BX+B].word[j].nibble[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[1]) * EXTS(VSR[32×BX+B].word[j].nibble[1])",
                "         prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[2]) * EXTS(VSR[32×BX+B].word[j].nibble[2])",
                "         prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[3]) * EXTS(VSR[32×BX+B].word[j].nibble[3])",
                "         prod4 := (PMSK.bit[4]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[4]) * EXTS(VSR[32×BX+B].word[j].nibble[4])",
                "         prod5 := (PMSK.bit[5]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[5]) * EXTS(VSR[32×BX+B].word[j].nibble[5])",
                "         prod6 := (PMSK.bit[6]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[6]) * EXTS(VSR[32×BX+B].word[j].nibble[6])",
                "         prod7 := (PMSK.bit[7]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].nibble[7]) * EXTS(VSR[32×BX+B].word[j].nibble[7])",
                "",
                "         psum  := prod0 + prod1 + prod2 + prod3 + prod4 + prod5 + prod6 + prod7",
                "",
                "         if “[pm]xvi4ger8”   then ACC[AT][i].word[j] := CHOP32( psum )",
                "         if “[pm]xvi4ger8pp” then ACC[AT][i].word[j] := CHOP32( psum + EXTS(ACC[AT][i].word[j]) )",
                "      end",
                "      else",
                "         ACC[AT][i].word[j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of 32-bit signed integer values. ",
                "For xvi4ger8 or xvi4ger8pp, let PMSK=0b11111111, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64ger",
                    "regs": [ "AT,XAp,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "59" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gernn",
                    "regs": [ "AT,XAp,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "250" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvf64ger” | “xvf64gerpp” | “xvf64gerpn” | “xvf64gernp” | “xvf64gernn” then do",
                "   XMSK := 0b1111",
                "   YMSK := 0b11",
                "end",
                "vsrc1.qword[0] := VSR[32×AX+Ap]",
                "vsrc1.qword[1] := VSR[32×AX+Ap+1]",
                "vsrc2          := VSR[32×BX+B]",
                "do i = 0 to 3",
                "   do j = 0 to 1",
                "      if XMSK.bit[i]=1 & YMSK.bit[j]=1 then do",
                "         reset_flags()",
                "",
                "         src1 := bfp_CONVERT_FROM_BFP64(vsrc1.dword[i])",
                "         src2 := bfp_CONVERT_FROM_BFP64(vsrc2.dword[j])",
                "         acc  := bfp_CONVERT_FROM_BFP64(ACC[AT][i].dword[j])",
                "",
                "         if “[pm]xvf64ger”   then v := bfp_MULTIPLY( src1, src2 )",
                "         if “[pm]xvf64gerpp” then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "         if “[pm]xvf64gerpn” then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if “[pm]xvf64gernp” then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "         if “[pm]xvf64gernn” then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "",
                "         r := bfp_ROUND_TO_BFP64_NO_TRAP(v)",
                "",
                "         if “[pm]xvf64gernp” then r := bfp_NEGATE(r)",
                "         if “[pm]xvf64gernn” then r := bfp_NEGATE(r)",
                "",
                "         ACC[AT][i].dword[j] := bfp64_CONVERT_FROM_BFP(r)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if ox_flag=1 then SetFX(FPSCR.OX)",
                "         if ux_flag=1 then SetFX(FPSCR.UX)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "      end",
                "      else",
                "         ACC[AT][i].dword[j] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XAp be the value of 32×AX + Ap. If XAp is odd, or is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×2 matrix of double-precision floating-point values.",
                "Let vsrcX be the concatenation of the contents of VSR[XAp] and VSR[XAp+1].",
                "For xvf64ger, xvf64gerpp, xvf64gerpn, xvf64gernp, and xvf64gernn, let XMSK=0b1111 and YMSK=0b11.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 1, do the following.",
                "Unlike other vector floating-point instructions, ACC[AT] is always updated by the execution of the instruction, even ",
                "when a trap-enabled exception occurs. For every multiply-add operation that is performed as part of the execution of ",
                "this instruction, if an exception occurs as the result of that particular multiply-add operation, the trap-disabled ",
                "exception result is returned, even if that exception type is trap-enabled. Exception detection is based on the ",
                "trap-disable definition. Exception status is accumulated and the appropriate exception status bits in the FPSCR are ",
                "updated at the completion of execution of the instruction. Otherwise, behavior is the same as any vector ",
                "floating-point instruction that can cause an exception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gernp",
                    "regs": [ "AT,XAp,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "122" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gerpn",
                    "regs": [ "AT,XAp,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "186" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvf64gerpp",
                    "regs": [ "AT,XAp,XB,XMSK,YMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "8" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "58" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi8ger4",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "4" },
                { "name": "reserved", "size": "4" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "3" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi8ger4pp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "4" },
                { "name": "reserved", "size": "4" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "2" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvi8ger4” | “xvi8ger4pp” then do",
                "   PMSK := 0b1111",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] & YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[0]) * EXTZ(VSR[32×BX+B].word[j].byte[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[1]) * EXTZ(VSR[32×BX+B].word[j].byte[1])",
                "         prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[2]) * EXTZ(VSR[32×BX+B].word[j].byte[2])",
                "         prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[3]) * EXTZ(VSR[32×BX+B].word[j].byte[3])",
                "",
                "         psum  := prod0 + prod1 + prod2 + prod3",
                "",
                "         if “[pm]xvi8ger4”   then ACC[AT][i].word[j] := CHOP32( psum )",
                "         if “[pm]xvi8ger4pp” then ACC[AT][i].word[j] := CHOP32( psum + EXTS(ACC[AT][i].word[j]) )",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of 32-bit signed integer values. ",
                "For xvi8ger4 or xvi8ger4pp, let PMSK=0b1111, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturate Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvi8ger4spp",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "4" },
                { "name": "reserved", "size": "4" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "99" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvi8ger4pps” then do",
                "   PMSK := 0b1111",
                "   XMSK := 0b1111",
                "   YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i] & YMSK.bit[j] then do",
                "         prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[0]) * EXTZ(VSR[32×BX+B].word[j].byte[0])",
                "         prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[1]) * EXTZ(VSR[32×BX+B].word[j].byte[1])",
                "         prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[2]) * EXTZ(VSR[32×BX+B].word[j].byte[2])",
                "         prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32×AX+A].word[i].byte[3]) * EXTZ(VSR[32×BX+B].word[j].byte[3])",
                "",
                "         psum  := prod0 + prod1 + prod2 + prod3",
                "",
                "         ACC[AT][i].word[j] := si32_CLAMP( psum + EXTS(ACC[AT][i].word[j] )",
                "",
                "         if sat_flag=1 then VSCR.SAT := 1",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of 32-bit signed integer values. ",
                "For xvi8ger4spp, let PMSK=0b1111, XMSK=0b1111, and YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update)",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "51" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pmxvbf16ger2nn",
                    "regs": [ "AT,XA,XB,XMSK,YMSK,PMSK" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "242" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “xvbf16ger2” | “xvbf16ger2pp” | “xvbf16ger2pn” | “xvbf16ger2np” | “xvbf16ger2nn” then do",
                "   PMSK := 0b11      // enable all rank updates",
                "   XMSK := 0b1111    // enable all ACC[AT] rows",
                "   YMSK := 0b1111    // enable all ACC[AT] columns",
                "end",
                "",
                "do i = 0 to 3",
                "   do j = 0 to 3",
                "      if XMSK.bit[i]=1 & YMSK.bit[j]=1 then do",
                "         src11 := (PMSK.bit[0]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32×AX+A].word[i].hword[0])",
                "         src21 := (PMSK.bit[0]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32×BX+B].word[j].hword[0])",
                "         src12 := (PMSK.bit[1]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32×AX+A].word[i].hword[1])",
                "         src22 := (PMSK.bit[1]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32×BX+B].word[j].hword[1])",
                "",
                "         reset_flags()",
                "",
                "         p1 := bfp_MULTIPLY(src11, src21)",
                "         v1 := bfp_MULTIPLY_ADD(src12, src22, p1)",
                "         r1 := bfp_ROUND_TO_BFP32_SIGNIFICAND(v1)",
                "",
                "         if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "         if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "         if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "         if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "         if “[pm]xvbf16ger2” then do",
                "            reset_flags()",
                "",
                "            r2 := bfp_ROUND_TO_BFP32_NO_TRAP(r1)",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "            if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "            if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "            if ox_flag=1 then SetFX(FPSCR.OX)",
                "            if ux_flag=1 then SetFX(FPSCR.UX)",
                "            if xx_flag=1 then SetFX(FPSCR.XX)",
                "         end",
                "",
                "         else do",
                "            acc := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "            reset_flags()",
                "",
                "            if “[pm]xvbf16ger2pp” then v := bfp_ADD(r1, acc)",
                "            if “[pm]xvbf16ger2pn” then v := bfp_ADD(r1, bfp_NEGATE(acc))",
                "            if “[pm]xvbf16ger2np” then v := bfp_ADD(bfp_NEGATE(r1), acc)",
                "            if “[pm]xvbf16ger2nn” then v := bfp_ADD(bfp_NEGATE(r1), bfp_NEGATE(acc))",
                "",
                "            r2 := bfp_ROUND_TO_BFP32_NO_TRAP(v)",
                "            ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "            if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "            if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "            if ox_flag=1 then SetFX(FPSCR.OX)",
                "            if ux_flag=1 then SetFX(FPSCR.UX)",
                "            if xx_flag=1 then SetFX(FPSCR.XX)",
                "         end",
                "      end",
                "      else",
                "         ACC[AT][i][j] := 0x0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XA be the value of 32×AX + A. If XA is in the range 4×AT to 4×AT+3, the instruction form is invalid.",
                "Let the contents of ACC[AT] be a 4×4 matrix of single-precision floating-point values.",
                "For xvbf16ger2, xvbf16ger2pp, xvbf16ger2pn, xvbf16ger2np, or xvbf16ger2nn, let PMSK=0b11, XMSK=0b1111, and ",
                "YMSK=0b1111.",
                "For each integer value i from 0 to 3, and each integer value j from 0 to 3, do the following.",
                "Unlike other VSX Vector Floating-Point instructions, ACC[AT] is always updated by the execution of the instruction, ",
                "even when a trap-enabled exception occurs. For every rounding operation that is performed as part of the execution ",
                "of this instruction, if an exception occurs as the result of that particular rounding operation, the trap-disabled ",
                "exception result is returned, even if that exception type is trap-enabled. Exception detection is based on the ",
                "trap-disabled definition. Exception status is accumulated and the appropriate exception status bits in the FPSCR are ",
                "updated at the completion of execution of the instruction. Otherwise, behavior is the same as any vector ",
                "floating-point instruction that can cause an exception. Taking a Program interrupt on a trap-enabled exception when ",
                "interrupts are enabled by MSR.FE0 and MSR.FE1 is still supported, albeit with the ACC[AT] updated based on a ",
                "trap-disabled result."
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "",
                    "regs": [  ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "114" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "",
                    "regs": [  ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "178" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "MMIRR:XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "",
                    "regs": [  ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "1" },
                { "name": "reserved", "size": "1" },
                { "name": "PMSK", "size": "2" },
                { "name": "reserved", "size": "6" },
                { "name": "XMSK", "size": "4" },
                { "name": "YMSK", "size": "4" },
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "50" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix:"
            ]
        },
        {
            "description": "Modulo Signed Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "modsd",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "777" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "remainder = dividend - (quotient × divisor)",
                "<anything> % 0",
                "   0x8000_0000_0000_0000 % -1"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit remainder of the dividend divided by the ",
                "divisor is placed into register RT. The quotient is not ",
                "supplied as a result.",
                "Both operands and the remainder are interpreted as ",
                "signed integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 £ remainder < |divisor| if the dividend is ",
                "nonnegative, and -|divisor| < remainder £ 0 if the ",
                "dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Signed Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "modsw",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "779" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31 </sub>  := (RB)<sub>32:63</sub>-",
                "RT<sub>32:63</sub>       := dividend % divisor",
                "RT<sub>0:31 </sub>       := undefined",
                "remainder = dividend - (quotient × divisor)",
                "0x8000_0000 % -1",
                "<anything> % 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit remainder of the dividend divided ",
                "by the divisor is placed into RT<sub>32:63</sub>. The contents of ",
                "RT<sub>0:31</sub> are undefined. The quotient is not supplied as a ",
                "result.",
                "Both operands and the remainder are interpreted as ",
                "signed integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 £ remainder < |divisor| if the dividend is ",
                "nonnegative, and -|divisor| < remainder £ 0 if the ",
                "dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Unsigned Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "modud",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "265" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "remainder = dividend - (quotient × divisor)",
                "<anything> % 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit remainder of the dividend divided by the ",
                "divisor is placed into register RT. The quotient is not ",
                "supplied as a result.",
                "Both operands and the remainder are interpreted as ",
                "unsigned integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 £ remainder < divisor.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Unsigned Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "moduw",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "267" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31 </sub>  := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub>       := dividend % divisor",
                "RT<sub>0:31 </sub>       := undefined",
                "remainder = dividend - (quotient × divisor)",
                "<anything> % 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)<sub>32:63</sub>. The 32-bit divisor is ",
                "(RB)<sub>32:63</sub>. The 32-bit remainder of the dividend divided ",
                "by the divisor is placed into RT<sub>32:63</sub>. The contents of ",
                "RT<sub>0:31</sub> are undefined. The quotient is not supplied as a ",
                "result.",
                "Both operands and the remainder are interpreted as ",
                "unsigned integers. The remainder is the unique signed ",
                "integer that satisfies",
                "where 0 £ remainder < divisor.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Move Condition Register Field",
            "form": "XL-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "mcrf",
                    "regs": [ "BF,BFA" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "19" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "BFA", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "0" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>4</sub>*<sub>BF+32:4</sub>*<sub>BF+35</sub> := CR<sub>4</sub>*<sub>BFA+32:4</sub>*<sub>BFA+35</sub>"
            ],
            "body": [
                "The contents of Condition Register field BFA are cop",
                "ied to Condition Register field BF.",
                "These instructions provide the means by which a pro",
                "gram can call upon the system to perform a service.",
                "",
                ""
            ]
        },
        {
            "description": "Move From Condition Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfcr",
                    "regs": [ "RT" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "8" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "10", "value": "19" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "   RT := <sup>32</sup>0 || CR"
            ],
            "body": [
                "The contents of the Condition Register are placed into ",
                "RT<sub>32:63</sub>. RT<sub>0:31</sub> are set to 0."
            ]
        },
        {
            "description": "Move From FPSCR",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffs",
                    "regs": [ "FRT", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mffs.",
                    "regs": [ "FRT", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of the FPSCR are placed into register ",
                "FRT.",
                "If Rc=1, CR field 1 is set to the value FX||FEX||VX||OX."
            ]
        },
        {
            "description": "Move From FPSCR & Clear Enables",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffsce",
                    "regs": [ "FRT" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of the FPSCR are placed into register FRT.",
                "The contents of bits 56:60 (VE, OE, UE, ZE, XE) of the ",
                "FPSCR are set to 0."
            ]
        },
        {
            "description": "Move From FPSCR Control & Set DRN",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffscdrn",
                    "regs": [ "FRT,FRB" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "20" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let new_DRN be the contents of bits 29:31 of register ",
                "FRB.",
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "are placed into the corresponding bits in register FRT. All ",
                "other bits in register FRT are set to 0.",
                "new_DRN is placed into bits 62:64 of the FPSCR (DRN).",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Control & Set DRN Immediate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffscdrni",
                    "regs": [ "FRT,DRM" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "21" },
                { "name": "reserved", "size": "2" },
                { "name": "DRM", "size": "3" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "are placed into the corresponding bits in register FRT. All ",
                "other bits in register FRT are set to 0.",
                "The contents of bits 29:31 of the FPSCR (DRN) are set ",
                "to the value of DRM.",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Control & Set RN",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffscrn",
                    "regs": [ "FRT,FRB" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "22" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let new_RN be the contents of bits 62:63 of register ",
                "FRB.",
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, ",
                "RN), are placed into the corresponding bits in register ",
                "FRT. All other bits in register FRT are set to 0.",
                "new_RN is placed into bits 62:63 of the FPSCR (RN).",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Control & Set RN Immediate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffscrni",
                    "regs": [ "FRT,RM" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "23" },
                { "name": "reserved", "size": "3" },
                { "name": "RM", "size": "2" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "are placed into the corresponding bits in register FRT. All ",
                "other bits in register FRT are set to 0.",
                "The contents of bits 62:63 of the FPSCR (RN) are set to ",
                "the value of RM.",
                "  "
            ]
        },
        {
            "description": "Move From FPSCR Lightweight",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mffsl",
                    "regs": [ "FRT" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "FRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "24" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "583" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of the control bits in the FPSCR, that is, ",
                "bits 29:31 (DRN) and bits 56:63 (VE, OE, UE, ZE, XE, NI, RN), ",
                "and the non-sticky status bits in the FPSCR, that is, bits ",
                "45:51 (FR, FI, C, FL, FG, FE, FU), are placed into the cor",
                "responding bits in register FRT. All other bits in register ",
                "FRT are set to 0.",
                "  "
            ]
        },
        {
            "description": "Move From One Condition Register Field",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfocrf",
                    "regs": [ "RT,FXM" ],
                    "release": "v2.01"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "FXM", "size": "8" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "10", "value": "19" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RT := undefined",
                "count := 0",
                "do i = 0 to 7",
                "   if FXM<sub>i</sub> = 1 then",
                "      n := i",
                "      count := count + 1",
                "if count = 1 then",
                "   RT := <sup>64</sup>0",
                "   RT<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub> := CR<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub>"
            ],
            "body": [
                "If exactly one bit of the FXM field is set to 1, let n be the ",
                "position of that bit in the field (0 £ n £ 7). The contents ",
                "of CR field n (CR bits 4*n+32:4*n+35) are placed into ",
                "bits 4´n+32:4´n+35 of register RT, and the contents of ",
                "the remaining bits of register RT are undefined. ",
                "Otherwise, the contents of register RT are undefined.",
                "If exactly one bit of the FXM field is set to 1, the ",
                "contents of the remaining bits of register RT are set to ",
                "0s instead of being undefined as specified above.",
                "  "
            ]
        },
        {
            "description": "Move From Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfspr",
                    "regs": [ "RT,SPR" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "spr", "size": "10" },
                { "name": "opcode", "size": "10", "value": "339" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "   case(808, 809, 810, 811):",
                "   default:",
                "      if length(SPR(n)) = 64 then",
                "         RT := SPR(n)",
                "      else",
                "         RT := <sup>32</sup>0 || SPR(n)"
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in the table below.  If the SPR field ",
                "contains a value from 808 through 811, the instruction ",
                "specifies a reserved SPR, and is treated as a no-op; ",
                "see Section1.3.3, “Reserved Fields, Reserved Values, ",
                "and Reserved SPRs”.  Otherwise, the contents of the ",
                "designated Special Purpose Register are placed into ",
                "register RT. For Special Purpose Registers that are 32 ",
                "bits long, the low-order 32 bits of RT receive the con",
                "tents of the Special Purpose Register and the ",
                "high-order 32 bits of RT are set to zero.",
                "If execution of this instruction is attempted specifying ",
                "an SPR number that is not shown above, one of the fol",
                "lowing occurs.",
                "A complete description of this instruction can be found ",
                "in Book III.",
                "Examples of extended mnemonics for Move From Spe",
                "cial Purpose Register:",
                " "
            ]
        },
        {
            "description": "Move From VSR Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrd",
                    "regs": [ "RA,XS" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "51" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.FP=0 then FP_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := VSR[32×SX+S].dword[0]"
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "The contents of doubleword element 0 of VSR[XS] are ",
                "placed into GPR[RA].",
                "For SX=0, mfvsrd is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For SX=1, mfvsrd is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move From VSR Double",
                "word:"
            ]
        },
        {
            "description": "Move From VSR Lower Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrld",
                    "regs": [ "RA,XS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "307" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := VSR[32×SX+S].dword[1]"
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "The contents of doubleword 1 of VSR[XS] are placed ",
                "into GPR[RA].",
                "For SX=0, mfvsrld is treated as a VSX instruction in ",
                "terms of resource availability.",
                "For SX=1, mfvsrld is treated as a Vector instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Move From VSR Word and Zero",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrwz",
                    "regs": [ "RA,XS" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "115" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.FP=0 then FP_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := EXTZ64(VSR[32×SX+S].word[1])"
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "The contents of word element 1 of VSR[XS] are placed ",
                "into bits 32:63 of GPR[RA]. The contents of bits 0:31 of ",
                "GPR[RA] are set to 0.",
                "For SX=0, mfvsrwz is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For SX=1, mfvsrwz is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Move From Vector Status and Control Register",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mfvscr",
                    "regs": [ "VRT" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1540" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := EXTZ128(VSCR)"
            ],
            "body": [
                "The contents of the VSCR are placed into word ",
                "element 3 of VSR[VRT+32].",
                "The remaining word elements in VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Move To Condition Register Fields",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtcrf",
                    "regs": [ "FXM,RS" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "FXM", "size": "8" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "10", "value": "144" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "mask := <sup>4</sup>(FXM<sub>0</sub>) || <sup>4</sup>(FXM<sub>1</sub>) || ... <sup>4</sup>(FXM<sub>7</sub>)",
                "CR := ((RS)<sub>32:63</sub> & mask) | (CR & ~mask)"
            ],
            "body": [
                "The contents of bits 32:63 of register RS are placed into ",
                "the Condition Register under control of the field mask ",
                "specified by FXM. The field mask identifies the 4-bit ",
                "fields affected. Let i be an integer in the range 0-7. If ",
                "FXM<sub>i</sub><sub>=1</sub> then CR field i (CR bits 4´i+32:4´i+35) is set to ",
                "the contents of the corresponding field of the low-order ",
                "32 bits of RS.",
                "Example of extended mnemonics for Move To Condi",
                "tion Register Fields:"
            ]
        },
        {
            "description": "Move To FPSCR Bit 0",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtfsb0",
                    "regs": [ "BT", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsb0.",
                    "regs": [ "BT", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "70" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Bit BT+32 of the FPSCR is set to 0.",
                "  "
            ]
        },
        {
            "description": "Move To FPSCR Bit 1",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtfsb1",
                    "regs": [ "BT", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsb1.",
                    "regs": [ "BT", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "38" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Bit BT+32 of the FPSCR is set to 1.",
                "   ",
                ""
            ]
        },
        {
            "description": "Move To FPSCR Field Immediate",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtfsfi",
                    "regs": [ "BF,U,W", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsfi.",
                    "regs": [ "BF,U,W", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "4" },
                { "name": "W", "size": "1" },
                { "name": "U", "size": "4" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "10", "value": "134" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The value of the U field is placed into FPSCR field ",
                "BF+8*(1-W).",
                "FX is altered only if BF=0 and W=0.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Move To FPSCR Fields",
            "form": "XFL-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtfsf",
                    "regs": [ "FLM,FRB,L,W", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mtfsf.",
                    "regs": [ "FLM,FRB,L,W", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "L", "size": "1" },
                { "name": "FLM", "size": "8" },
                { "name": "W", "size": "1" },
                { "name": "FRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "711" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The FPSCR is modified as specified by the FLM, L, and ",
                "W fields.",
                "L=0",
                "L=1",
                "FX is not altered implicitly by this instruction.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Move To One Condition Register Field",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtocrf",
                    "regs": [ "FXM,RS" ],
                    "release": "v2.01"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "FXM", "size": "8" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "10", "value": "144" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "count := 0",
                "do i = 0 to 7",
                "   if FXM<sub>i</sub> = 1 then",
                "      n := i",
                "   count := count + 1",
                "if count = 1 then",
                "   CR<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub> := (RS)<sub>4</sub>*<sub>n+32:4</sub>*<sub>n+35</sub>",
                "else",
                "   CR := undefined"
            ],
            "body": [
                "If exactly one bit of the FXM field is set to 1, let n be the ",
                "position of that bit in the field (0 £ n £ 7). The contents ",
                "of bits 4´n+32:4´n+35 of register RS are placed into CR ",
                "field n (CR bits 4´n+32:4´n+35). Otherwise, the contents ",
                "of the Condition Register are undefined."
            ]
        },
        {
            "description": "Move To Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtspr",
                    "regs": [ "SPR,RS" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "spr", "size": "10" },
                { "name": "opcode", "size": "10", "value": "467" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "   case(13): see Book III",
                "   case(808, 809, 810, 811):",
                "   default:",
                "      if length(SPR(n)) = 64 then",
                "         SPR(n) := (RS)",
                "      else",
                "         SPR(n) := (RS)<sub>32:63</sub>"
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in the table below. If the SPR field ",
                "contains a value from 808 through 811, the instruction ",
                "specifies a reserved SPR, and is treated as a no-op;  ",
                "see Section1.3.3, “Reserved Fields, Reserved Values, ",
                "and Reserved SPRs”.  Otherwise, unless the SPR field ",
                "contains 13 (denoting the AMR), the contents of register ",
                "RS are placed into the designated Special Purpose Reg",
                "ister. For Special Purpose Registers that are 32 bits ",
                "long, the low-order 32 bits of RS are placed into the ",
                "SPR. ",
                "The AMR (Authority Mask Register) is used for “stor",
                "age protection.” This use, and operation of mtspr for ",
                "the AMR, are described in Book III.",
                "If execution of this instruction is attempted specifying ",
                "an SPR number that is not shown above, one of the fol",
                "lowing occurs.",
                "A complete description of this instruction can be found ",
                "in Book III.",
                "Examples of extended mnemonics for Move To Special ",
                "Purpose Register:",
                "     ",
                "  ",
                " "
            ]
        },
        {
            "description": "Move To VSR Byte Mask Immediate",
            "form": "DX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrbmi",
                    "regs": [ "VRT,bm" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "b1", "size": "5" },
                { "name": "b0", "size": "10" },
                { "name": "opcode", "size": "5", "value": "10" },
                { "name": "b2", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "bm.bit[0:9]   := b0",
                "bm.bit[10:14] := b1",
                "bm.bit[15]    := b2",
                "do i = 0 to 15",
                "   if bm.bit[i]=0 then",
                "      VSR[VRT+32].byte[i] := 0x00",
                "   else",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "end"
            ],
            "body": [
                "Let bm be the concatenation of b0, b1 and b2.",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Move To VSR Double Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrdd",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "435" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if RA=0 then",
                "   VSR[32×TX+T].dword[0] := 0x0000_0000_0000_0000",
                "else",
                "   VSR[32×TX+T].dword[0] := GPR[RA]",
                "",
                "VSR[32×TX+T].dword[1] := GPR[RB]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of GPR[RA], or the value 0 if RA=0, are ",
                "placed into doubleword 0 of  VSR[XT].",
                "The contents of GPR[RB] are placed into doubleword 1 ",
                "of  VSR[XT].",
                "For TX=0, mtvsrdd is treated as a VSX instruction in ",
                "terms of resource availability.",
                "For TX=1, mtvsrdd is treated as a Vector instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Move To VSR Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrd",
                    "regs": [ "XT,RA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "179" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.FP=0 then FP_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32×TX+T].dword[0] := GPR[RA]",
                "VSR[32×TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of GPR[RA] are placed into doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "undefined.",
                "For TX=0, mtvsrd is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For TX=1, mtvsrd is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Doubleword:"
            ]
        },
        {
            "description": "Move To VSR Word & Splat",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrws",
                    "regs": [ "XT,RA" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "403" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32×TX+T].word[0] := GPR[RA].bit[32:63]",
                "VSR[32×TX+T].word[1] := GPR[RA].bit[32:63]",
                "VSR[32×TX+T].word[2] := GPR[RA].bit[32:63]",
                "VSR[32×TX+T].word[3] := GPR[RA].bit[32:63]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of bits 32:63 of GPR[RA] are placed into ",
                "each word element of  VSR[XT].",
                "For TX=0, mtvsrws is treated as a VSX instruction in ",
                "terms of resource availability.",
                "For TX=1, mtvsrws is treated as a Vector instruction in ",
                "terms of resource availability."
            ]
        },
        {
            "description": "Move To VSR Word Algebraic",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwa",
                    "regs": [ "XT,RA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "211" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.FP=0 then FP_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32×TX+T].dword[0] := EXTS64(GPR[RA].bit[32:63])",
                "VSR[32×TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The two’s-complement integer in bits 32:63 of GPR[RA] ",
                "is sign-extended to 64 bits and placed into doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "undefined.",
                "For TX=0, mtvsrwa is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For TX=1, mtvsrwa is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Word Alge",
                "braic:"
            ]
        },
        {
            "description": "Move To VSR Word and Zero",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwz",
                    "regs": [ "XT,RA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "243" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.FP=0 then FP_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32×TX+T].dword[0] := EXTZ64(GPR[RA].word[1])",
                "VSR[32×TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of bits 32:63 of GPR[RA] are placed into ",
                "word element 1 of VSR[XT]. The contents of word ",
                "element 0 of VSR[XT] are set to 0.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "undefined.",
                "For TX=0, mtvsrwz is treated as a Floating-Point ",
                "instruction in terms of resource availability.",
                "For TX=1, mtvsrwz is treated as a Vector instruction in ",
                "terms of resource availability.",
                "Extended mnemonics for Move To VSR Word and ",
                "Zero:"
            ]
        },
        {
            "description": "Move To Vector Status and Control Register",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvscr",
                    "regs": [ "VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1604" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSCR := VSR[VRB+32].word[3]"
            ],
            "body": [
                "The contents of word element 3 of VSR[VRB+32] are ",
                "placed into the VSCR."
            ]
        },
        {
            "description": "Move to CR from XER Extended",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mcrxrx",
                    "regs": [ "BF" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "576" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "CR<sub>4×BF+32:4×BF+35</sub> := XER<sub>OV OV32 CA CA32</sub>"
            ],
            "body": [
                "The contents of the OV, OV32, CA, and CA32 are copied to ",
                "Condition Register field BF."
            ]
        },
        {
            "description": "Move to Condition Register from FPSCR",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mcrfs",
                    "regs": [ "BF,BFA" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "BFA", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "64" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "The contents of FPSCR<sub>32:63</sub> field BFA are copied to Condi",
                "tion Register field BF. All exception bits copied are set to ",
                "0 in the FPSCR. If the FX bit is copied, it is set to 0 in ",
                "the FPSCR."
            ]
        },
        {
            "description": "Move to VSR Byte Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrbm",
                    "regs": [ "VRT,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "16" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   if GPR[RB].bit[48+i]=0 then",
                "      VSR[VRT+32].byte[i] := 0x00",
                "   else",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 48:63 of GPR[RB].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Move to VSR Doubleword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrdm",
                    "regs": [ "VRT,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "19" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   if GPR[RB].bit[62+i]=0 then",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "   else",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 62:63 of GPR[RB].",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Move to VSR Halfword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrhm",
                    "regs": [ "VRT,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "17" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   if GPR[RB].bit[56+i]=0 then",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "   else",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 56:63 of GPR[RB].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Move to VSR Quadword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrqm",
                    "regs": [ "VRT,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "20" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if GPR[RB].bit[63]=0 then",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "else",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF"
            ],
            "body": [
                "Let bm be the contents of bits 63 of GPR[RB].",
                "The contents of VSR[VRT+32] is set to all 0s if bm is ",
                "equal to 0.",
                "The contents of VSR[VRT+32] is set to all 1s if bm is ",
                "equal to 1."
            ]
        },
        {
            "description": "Move to VSR Word Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwm",
                    "regs": [ "VRT,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "18" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   if GPR[RB].bit[60+i]=0 then",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "   else",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "end"
            ],
            "body": [
                "Let bm be the contents of bits 60:63 of GPR[RB].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Multiply High Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhd",
                    "regs": [ "RT,RA,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhd.",
                    "regs": [ "RT,RA,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "73" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The high-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Doubleword Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhdu",
                    "regs": [ "RT,RA,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhdu.",
                    "regs": [ "RT,RA,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "9" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The high-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "Both operands and the product are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero."
            ]
        },
        {
            "description": "Multiply High Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhw",
                    "regs": [ "RT,RA,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhw.",
                    "regs": [ "RT,RA,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "75" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "prod<sub>0:63</sub> := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := prod<sub>0:31</sub>",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA and ",
                "of RB. The high-order 32 bits of the 64-bit product of the ",
                "operands are placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> ",
                "are undefined.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Word Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhwu",
                    "regs": [ "RT,RA,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhwu.",
                    "regs": [ "RT,RA,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "opcode", "size": "9", "value": "11" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "prod<sub>0:63</sub> := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := prod<sub>0:31</sub>",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA and ",
                "of RB. The high-order 32 bits of the 64-bit product of the ",
                "operands are placed into RT<sub>32:63</sub>. The contents of RT<sub>0:31</sub> ",
                "are undefined.",
                "Both operands and the product are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three bits ",
                "of CR Field 0 are set by signed comparison of the result ",
                "to zero."
            ]
        },
        {
            "description": "Multiply Low Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulld",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulld.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulldo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulldo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "233" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>64:127</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The low-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "If OE=1 then OV and OV32 are set to 1 if the product can",
                "not be represented in 64 bits.",
                "Both operands and the product are interpreted as ",
                "signed integers.",
                "  "
            ]
        },
        {
            "description": "Multiply Low Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulli",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "7" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * EXTS(SI)",
                "RT := prod<sub>64:127</sub>"
            ],
            "body": [
                "The 64-bit first operand is (RA). The 64-bit second ",
                "operand is the sign-extended value of the SI field. The ",
                "low-order 64 bits of the 128-bit product of the operands ",
                "are placed into register RT.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply Low Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mullw",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullw.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullwo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullwo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "235" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA and ",
                "of RB. The 64-bit product of the operands is placed into ",
                "register RT.",
                "If OE=1 then OV and OV32 are set to 1 if the product can",
                "not be represented in 32 bits.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply-Add High Doubleword",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "maddhd",
                    "regs": [ "RT,RA.RB,RC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "48" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) × (RB)",
                "sum<sub>0:127</sub>  := prod + EXTS(RC)",
                "RT := sum<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is added ",
                "to (RC). The high-order 64 bits of the 128-bit sum are ",
                "placed into register RT.",
                "All three operands and the result are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply-Add High Doubleword Unsigned",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "maddhdu",
                    "regs": [ "RT,RA.RB,RC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "49" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) × (RB)",
                "sum<sub>0:127</sub>  := prod + EXTZ(RC)",
                "RT := sum<sub>0:63</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is added ",
                "to (RC). The high-order 64 bits of the 128-bit sum are ",
                "placed into register RT.",
                "All three operands and the result are interpreted as ",
                "unsigned integers."
            ]
        },
        {
            "description": "Multiply-Add Low Doubleword",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "maddld",
                    "regs": [ "RT,RA.RB,RC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "51" }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) × (RB)",
                "sum<sub>0:127</sub>  := prod + EXTS(RC)",
                "RT := sum<sub>64:127</sub>"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is added ",
                "to (RC). The low-order 64 bits of the 128-bit sum are ",
                "placed into register RT.",
                "All three operands and the result are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "NAND",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "nand",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nand.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "476" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := ~((RS) & (RB))"
            ],
            "body": [
                "The contents of register RS are ANDed with the con",
                "tents of register RB and the complemented result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "NOR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "nor",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nor.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "124" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := ~((RS) | (RB))"
            ],
            "body": [
                "The contents of register RS are ORed with the contents ",
                "of register RB and the complemented result is placed ",
                "into register RA.",
                "Example of extended mnemonics for NOR:"
            ]
        },
        {
            "description": "Negate",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "neg",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "neg.",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nego",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nego.",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "104" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := ~(RA) + 1"
            ],
            "body": [
                "The sum ¬(RA) + 1 is placed into register RT.",
                "If the processor is in 64-bit mode and register RA con",
                "tains the most negative 64-bit number ",
                "(0x8000_0000_0000_0000), the result is the most nega",
                "tive number and, if OE=1, OV is set to 1. If (RA)<sub>32:63</sub> con",
                "tain the most negative 32-bit number (0x8000_0000) and ",
                "OE=1, OV32 is set to 1.",
                "Similarly, if the processor is in 32-bit mode and ",
                "(RA)<sub>32:63</sub> contain the most negative 32-bit number ",
                "(0x8000_0000), the low-order 32 bits of the result contain ",
                "the most negative 32-bit number and, if OE=1, OV and ",
                "OV32 are set to 1. "
            ]
        },
        {
            "description": "Prefixed Nop",
            "form": "MRR:*-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pnop",
                    "regs": [  ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "opcode", "size": "18", "value": "0" },
                { "name": "any value", "size": "32" }
            ],
            "code": [

            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "No operation is performed.",
                "  ",
                "  ",
                "  ",
                " "
            ]
        },
        {
            "description": "OR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "or",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "or.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "444" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := (RS) | (RB)"
            ],
            "body": [
                "The contents of register RS are ORed with the contents ",
                "of register RB and the result is placed into register RA.",
                "Some forms of or Rx,Rx,Rx provide special functions; ",
                "see Section 3.2 and Section 4.3.3, both in Book II.",
                "Example of extended mnemonics for OR:"
            ]
        },
        {
            "description": "OR Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ori",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "24" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "RA := (RS) | (<sup>48</sup>0 || UI)",
                "ori   0,0,0"
            ],
            "body": [
                "The contents of register RS are ORed with 480||UI ",
                "and the result is placed into register RA.",
                "The preferred “no-op” (an instruction that does nothing) ",
                "is:",
                "Example of extended mnemonics for OR Immediate:",
                "  "
            ]
        },
        {
            "description": "OR Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "oris",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "25" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "RA := (RS) | (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "The contents of register RS are ORed with ",
                "320||UI||160 and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "OR with Complement ",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "orc",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "orc.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "412" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := (RS) | ~(RB)"
            ],
            "body": [
                "The contents of register RS are ORed with the comple",
                "ment of the contents of register RB and the result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Parallel Bits Deposit Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pdepd",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "156" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "result := 0",
                "mask := (RB)",
                "m := 0",
                "k := 0",
                "do while(m < 64)",
                "   if(mask<sub>63-m</sub> == 1) then do",
                "      result<sub>63-m</sub> := (RS)<sub>63-k</sub>",
                "      k := k + 1",
                "   end",
                "   m := m + 1",
                "end",
                "RA := result"
            ],
            "body": [
                "Let mask be the contents of register RB.",
                "Let n be the number of bits in mask having the value 1.",
                "The contents of the rightmost n bits of register RS are ",
                "placed into register RA under control of mask as follows. ",
                "The contents of bits in register RA corresponding to bits ",
                "in mask that contain a 0 are set to 0."
            ]
        },
        {
            "description": "Parallel Bits Extract Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pextd",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "188" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "result := 0",
                "mask := (RB)",
                "m := 0",
                "k := 0",
                "do while(m < 64)",
                "   if((RB)<sub>63-m</sub> == 1) then do",
                "      result<sub>63-k</sub> := (RS)<sub>63-m</sub>",
                "      k := k + 1",
                "   end",
                "   m := m + 1",
                "end",
                "RA := result"
            ],
            "body": [
                "Let mask be the contents of register RB.",
                "The contents of the bits in register RS corresponding to ",
                "bits in mask containing a 1 are packed into an n-bit ",
                "value. The extracted value is placed into register RA."
            ]
        },
        {
            "description": "Parity Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "prtyd",
                    "regs": [ "RA,RS" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "186" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "s := 0",
                "do i = 0 to 7",
                "   s := s ^ (RS)<sub>i</sub><sub>%</sub><sub>8+7</sub>",
                "RA := 630 || s"
            ],
            "body": [
                "The least significant bit in each byte of the contents of ",
                "register RS is examined. If there is an odd number of ",
                "one bits the value 1 is placed into register RA; otherwise ",
                "the value 0 is placed into register RA."
            ]
        },
        {
            "description": "Parity Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "prtyw",
                    "regs": [ "RA,RS" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "154" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "s := 0",
                "t := 0",
                "do i = 0 to 3",
                "   s := s ^ (RS)<sub>i</sub><sub>%</sub><sub>8+7</sub>",
                "do i = 4 to 7",
                "   t := t ^ (RS)<sub>i</sub><sub>%</sub><sub>8+7</sub>",
                "RA<sub>0:31</sub> := 310 || s ",
                "RA<sub>32:63</sub> := 310 || t"
            ],
            "body": [
                "The least significant bit in each byte of (RS)<sub>0:31</sub> is ",
                "examined. If there is an odd number of one bits the ",
                "value 1 is placed into RA<sub>0:31</sub>; otherwise the value 0 is ",
                "placed into RA<sub>0:31</sub>. The least significant bit in each byte ",
                "of (RS)<sub>32:63</sub> is examined. If there is an odd number of ",
                "one bits the value 1 is placed into RA<sub>32:63</sub>; otherwise the ",
                "value 0 is placed into RA<sub>32:63</sub>.",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "Population Count Bytes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "popcntb",
                    "regs": [ "RA, RS" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "122" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "do i = 0 to 7",
                "   n := 0",
                "   do j = 0 to 7",
                "      if (RS)<sub>(i</sub>*<sub>8)+j</sub> = 1 then",
                "          n := n+1",
                "   RA<sub>(i</sub>*<sub>8):(i</sub>*<sub>8)+7</sub> := n"
            ],
            "body": [
                "A count of the number of one bits in each byte of regis",
                "ter RS is placed into the corresponding byte of register ",
                "RA. This number ranges from 0 to 8, inclusive."
            ]
        },
        {
            "description": "Population Count Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "popcntd",
                    "regs": [ "RA, RS" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "506" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "n := 0",
                "do i = 0 to 63",
                "   if (RS)<sub>i</sub> = 1 then",
                "   n := n+1",
                "RA := n"
            ],
            "body": [
                "A count of the number of one bits in register RS is ",
                "placed into register RA. This number ranges from 0 to ",
                "64, inclusive."
            ]
        },
        {
            "description": "Population Count Words",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "popcntw",
                    "regs": [ "RA, RS" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "378" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "do i = 0 to 1",
                "   n := 0",
                "   do j = 0 to 31",
                "      if (RS)<sub>(i</sub>*<sub>32)+j</sub> = 1 then",
                "          n := n+1",
                "   RA<sub>(i</sub>*<sub>32):(i</sub>*<sub>32)+31</sub> := n"
            ],
            "body": [
                "A count of the number of one bits in each word of regis",
                "ter RS is placed into the corresponding word of register ",
                "RA. This number ranges from 0 to 32, inclusive."
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldic",
                    "regs": [ "RA,RS,SH,MB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldic.",
                    "regs": [ "RA,RS,SH,MB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "30" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "sh", "size": "5" },
                { "name": "mb", "size": "6" },
                { "name": "opcode", "size": "3", "value": "2" },
                { "name": "sh", "size": "1" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, ~n)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63-SH and 0-bits elsewhere. The rotated data are ",
                "ANDed with the generated mask and the result is ",
                "placed into register RA.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear Left",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldicl",
                    "regs": [ "RA,RS,SH,MB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldicl.",
                    "regs": [ "RA,RS,SH,MB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "30" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "sh", "size": "5" },
                { "name": "mb", "size": "6" },
                { "name": "opcode", "size": "3", "value": "0" },
                { "name": "sh", "size": "1" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, 63)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63 and 0-bits elsewhere. The rotated data are ANDed ",
                "with the generated mask and the result is placed into ",
                "register RA.",
                "Examples of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear Left:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear Right",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldicr",
                    "regs": [ "RA,RS,SH,ME", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldicr.",
                    "regs": [ "RA,RS,SH,ME", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "30" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "sh", "size": "5" },
                { "name": "me", "size": "6" },
                { "name": "opcode", "size": "3", "value": "1" },
                { "name": "sh", "size": "1" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "e := me<sub>5</sub> || me<sub>0:4</sub>",
                "m := MASK(0, e)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit 0 through bit ",
                "ME and 0-bits elsewhere. The rotated data are ANDed ",
                "with the generated mask and the result is placed into ",
                "register RA.",
                "Examples of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear Right:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Mask Insert",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldimi",
                    "regs": [ "RA,RS,SH,MB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldimi.",
                    "regs": [ "RA,RS,SH,MB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "30" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "sh", "size": "5" },
                { "name": "mb", "size": "6" },
                { "name": "opcode", "size": "3", "value": "3" },
                { "name": "sh", "size": "1" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, ~n)",
                "RA := r&m | (RA) & ~m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63-SH and 0-bits elsewhere. The rotated data are ",
                "inserted into register RA under control of the generated ",
                "mask.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Mask Insert:",
                "  ",
                "The instructions in this section perform left and right ",
                "shifts.",
                "Immediate-form logical (unsigned) shift operations are ",
                "obtained by specifying appropriate masks and shift val",
                "ues for certain Rotate instructions. A set of extended ",
                "mnemonics is provided to make coding of such shifts ",
                "simpler and easier to understand. Some of these are ",
                "shown as examples with the Rotate instructions. See ",
                "AppendixC, “Assembler Extended Mnemonics” on ",
                "page1025 for additional extended mnemonics."
            ]
        },
        {
            "description": "Rotate Left Doubleword then Clear Left",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldcl",
                    "regs": [ "RA,RS,RB,MB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldcl.",
                    "regs": [ "RA,RS,RB,MB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "30" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "mb", "size": "6" },
                { "name": "opcode", "size": "4", "value": "8" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, 63)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left the num",
                "ber of bits specified by (RB)<sub>58:63</sub>. A mask is generated ",
                "having 1-bits from bit MB through bit 63 and 0-bits else",
                "where. The rotated data are ANDed with the generated ",
                "mask and the result is placed into register RA.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword then Clear Left:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword then Clear Right",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldcr",
                    "regs": [ "RA,RS,RB,ME", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldcr.",
                    "regs": [ "RA,RS,RB,ME", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "30" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "me", "size": "6" },
                { "name": "opcode", "size": "4", "value": "9" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "e := me<sub>5</sub> || me<sub>0:4</sub>",
                "m := MASK(0, e)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>64</sub> left the num",
                "ber of bits specified by (RB)<sub>58:63</sub>. A mask is generated ",
                "having 1-bits from bit 0 through bit ME and 0-bits else",
                "where. The rotated data are ANDed with the generated ",
                "mask and the result is placed into register RA.",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word Immediate then AND with Mask",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rlwinm",
                    "regs": [ "RA,RS,SH,MB,ME", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwinm.",
                    "regs": [ "RA,RS,SH,MB,ME", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "21" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SH", "size": "5" },
                { "name": "MB", "size": "5" },
                { "name": "ME", "size": "5" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>32</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB+32 through ",
                "bit ME+32 and 0-bits elsewhere. The rotated data are ",
                "ANDed with the generated mask and the result is ",
                "placed into register RA.",
                "Examples of extended mnemonics for Rotate Left Word ",
                "Immediate then AND with Mask:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word Immediate then Mask Insert",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rlwimi",
                    "regs": [ "RA,RS,SH,MB,ME", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwimi.",
                    "regs": [ "RA,RS,SH,MB,ME", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "20" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SH", "size": "5" },
                { "name": "MB", "size": "5" },
                { "name": "ME", "size": "5" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r&m | (RA) & ~m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>32</sub> left SH bits. A ",
                "mask is generated having 1-bits from bit MB+32 through ",
                "bit ME+32 and 0-bits elsewhere. The rotated data are ",
                "inserted into register RA under control of the generated ",
                "mask.",
                "Example of extended mnemonics for Rotate Left Word ",
                "Immediate then Mask Insert:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word then AND with Mask",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rlwnm",
                    "regs": [ "RA,RS,RB,MB,ME", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwnm.",
                    "regs": [ "RA,RS,RB,MB,ME", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "23" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "MB", "size": "5" },
                { "name": "ME", "size": "5" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated<sub>32</sub> left the num",
                "ber of bits specified by (RB)<sub>59:63</sub>. A mask is generated ",
                "having 1-bits from bit MB+32 through bit ME+32 and 0-bits ",
                "elsewhere. The rotated data are ANDed with the gener",
                "ated mask and the result is placed into register RA.",
                "Example of extended mnemonics for Rotate Left Word ",
                "then AND with Mask:",
                "  "
            ]
        },
        {
            "description": "Set Boolean",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "setb",
                    "regs": [ "RT,BFA" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "BFA", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "128" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if CR<sub>4×BFA+32</sub>=1 then",
                "   RT := 0xFFFF_FFFF_FFFF_FFFF",
                "",
                "else if CR<sub>4×BFA+33</sub>=1 then",
                "   RT := 0x0000_0000_0000_0001",
                "",
                "else",
                "   RT := 0x0000_0000_0000_0000"
            ],
            "body": [
                "If the contents of bit 0 of CR field BFA are equal to 0b1, ",
                "the contents of register RT are set to ",
                "0xFFFF_FFFF_FFFF_FFFF.",
                "Otherwise, if the contents of bit 1 of CR field BFA are ",
                "equal to 0b1, the contents of register RT are set to ",
                "0x0000_0000_0000_0001.",
                "Otherwise, the contents of register RT are set to ",
                "0x0000_0000_0000_0000."
            ]
        },
        {
            "description": "Set Boolean Condition",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "setbc",
                    "regs": [ "RT,BI" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "384" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  1 :  0"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 1. ",
                "Otherwise, register RT is set to 0."
            ]
        },
        {
            "description": "Set Boolean Condition Reverse",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "setbcr",
                    "regs": [ "RT,BI" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "416" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  0 :  1"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 0. ",
                "Otherwise, register RT is set to 1."
            ]
        },
        {
            "description": "Set Negative Boolean Condition",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "setnbc",
                    "regs": [ "RT,BI" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "448" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ? -1 :  0"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 1. ",
                "Otherwise, register RT is set to 0."
            ]
        },
        {
            "description": "Set Negative Boolean Condition Reverse",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "setnbcr",
                    "regs": [ "RT,BI" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "BI", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "480" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  0 : -1"
            ],
            "body": [
                "If bit BI of the CR contains a 1, register RT is set to 0. ",
                "Otherwise, register RT is set to -1."
            ]
        },
        {
            "description": "Shift Left Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sld",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "sld.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "27" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "if (RB)<sub>57</sub> = 0 then",
                "     m := MASK(0, 63-n)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are shifted left the number ",
                "of bits specified by (RB)<sub>57:63</sub>. Bits shifted out of position ",
                "0 are lost. Zeros are supplied to the vacated positions ",
                "on the right. The result is placed into register RA. Shift ",
                "amounts from 64 to 127 give a zero result."
            ]
        },
        {
            "description": "Shift Left Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "slw",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "slw.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "24" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "if (RB)<sub>58</sub> = 0 then",
                "     m := MASK(32, 63-n)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted left the number of bits specified by (RB)<sub>58:63</sub>. ",
                "Bits shifted out of position 32 are lost. Zeros are sup",
                "plied to the vacated positions on the right. The 32-bit ",
                "result is placed into RA<sub>32:63</sub>. RA<sub>0:31</sub> are set to zero. Shift ",
                "amounts from 32 to 63 give a zero result."
            ]
        },
        {
            "description": "Shift Right Algebraic Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srad",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "srad.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "794" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "if (RB)<sub>57</sub> = 0 then",
                "    m := MASK(n, 63)",
                "else m := <sup>64</sup>0",
                "s := (RS)<sub>0</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m) != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of register RS are shifted right the number ",
                "of bits specified by (RB)<sub>57:63</sub>. Bits shifted out of position ",
                "63 are lost. Bit 0 of RS is replicated to fill the vacated ",
                "positions on the left. The result is placed into register ",
                "RA. CA and CA32 are set to 1 if (RS) is negative and any ",
                "1-bits are shifted out of position 63; otherwise CA and ",
                "CA32 are set to 0. A shift amount of zero causes RA to be ",
                "set equal to (RS), and CA and CA32 to be set to 0. Shift ",
                "amounts from 64 to 127 give a result of 64 sign bits in ",
                "RA, and cause CA and CA32 to receive the sign bit of ",
                "(RS).",
                "",
                ""
            ]
        },
        {
            "description": "Shift Right Algebraic Doubleword Immediate",
            "form": "XS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sradi",
                    "regs": [ "RA,RS,SH", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "sradi.",
                    "regs": [ "RA,RS,SH", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "sh", "size": "5" },
                { "name": "opcode", "size": "9", "value": "413" },
                { "name": "sh", "size": "1" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "m := MASK(n, 63)",
                "s := (RS)<sub>0</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m) != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of register RS are shifted right SH bits. Bits ",
                "shifted out of position 63 are lost. Bit 0 of RS is repli",
                "cated to fill the vacated positions on the left. The result ",
                "is placed into register RA. CA and CA32 are set to 1 if (RS) ",
                "is negative and any 1-bits are shifted out of position 63; ",
                "otherwise CA and CA32 are set to 0. A shift amount of ",
                "zero causes RA to be set equal to (RS), and CA and CA32 ",
                "to be set to 0.",
                "",
                "",
                "Special Registers Altered:"
            ]
        },
        {
            "description": "Shift Right Algebraic Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sraw",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "sraw.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "792" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "if (RB)<sub>58</sub> = 0 then",
                "    m := MASK(n+32, 63)",
                "else m := <sup>64</sup>0",
                "s := (RS)<sub>32</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m)<sub>32:63</sub> != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right the number of bits specified by (RB)<sub>58:63</sub>. ",
                "Bits shifted out of position 63 are lost. Bit 32 of RS is ",
                "replicated to fill the vacated positions on the left. The ",
                "32-bit result is placed into RA<sub>32:63</sub>. Bit 32 of RS is repli",
                "cated to fill RA<sub>0:31</sub>. CA and CA32 are set to 1 if the ",
                "low-order 32 bits of (RS) contain a negative number ",
                "and any 1-bits are shifted out of position 63; otherwise ",
                "CA and CA32 are set to 0. A shift amount of zero causes ",
                "RA to receive EXTS((RS)<sub>32:63</sub><sub>)</sub>, and CA and CA32 to be set ",
                "to 0. Shift amounts from 32 to 63 give a result of 64 ",
                "sign bits, and cause CA and CA32 to receive the sign bit ",
                "of (RS)<sub>32:63</sub>.",
                "",
                "",
                ""
            ]
        },
        {
            "description": "Shift Right Algebraic Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srawi",
                    "regs": [ "RA,RS,SH", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "srawi.",
                    "regs": [ "RA,RS,SH", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SH", "size": "5" },
                { "name": "opcode", "size": "10", "value": "824" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "m := MASK(n+32, 63)",
                "s := (RS)<sub>32</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m)<sub>32:63</sub> != 0 )",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right SH bits. Bits shifted out of position 63 are ",
                "lost. Bit 32 of RS is replicated to fill the vacated positions ",
                "on the left. The 32-bit result is placed into RA<sub>32:63</sub>. Bit 32 ",
                "of RS is replicated to fill RA<sub>0:31</sub>. CA and CA32 are set to 1 if ",
                "the low-order 32 bits of (RS) contain a negative number ",
                "and any 1-bits are shifted out of position 63; otherwise ",
                "CA and CA32 are set to 0. A shift amount of zero causes ",
                "RA to receive EXTS((RS)<sub>32:63</sub><sub>)</sub>, and CA and CA32 to be set ",
                "to 0.",
                "",
                ""
            ]
        },
        {
            "description": "Shift Right Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srd",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "srd.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "539" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "if (RB)<sub>57</sub> = 0 then",
                "    m := MASK(n, 63)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are shifted right the number ",
                "of bits specified by (RB)<sub>57:63</sub>. Bits shifted out of position ",
                "63 are lost. Zeros are supplied to the vacated positions ",
                "on the left. The result is placed into register RA. Shift ",
                "amounts from 64 to 127 give a zero result."
            ]
        },
        {
            "description": "Shift Right Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srw",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "srw.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "536" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "if (RB)<sub>58</sub> = 0 then",
                "    m := MASK(n+32, 63)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right the number of bits specified by (RB)<sub>58:63</sub>. ",
                "Bits shifted out of position 63 are lost. Zeros are sup",
                "plied to the vacated positions on the left. The 32-bit ",
                "result is placed into RA<sub>32:63</sub>. RA<sub>0:31</sub> are set to zero. Shift ",
                "amounts from 32 to 63 give a zero result."
            ]
        },
        {
            "description": "Store Byte",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stb",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "38" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “stb”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstb” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstb” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stb, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstb with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstb with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>56:63</sub> are stored into the byte in storage addressed ",
                "by EA.",
                "",
                "For pstb, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Byte:"
            ]
        },
        {
            "description": "Prefixed Store Byte",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pstb",
                    "regs": [ "RS,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "38" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “stb”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstb” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstb” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stb, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstb with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstb with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>56:63</sub> are stored into the byte in storage addressed ",
                "by EA.",
                "",
                "For pstb, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Byte:"
            ]
        },
        {
            "description": "Store Byte Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stbx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "215" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. (RS)<sub>56:63</sub> are stored into the byte in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Byte with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stbu",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "39" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "(RS)<sub>56:63</sub> are stored into the byte in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Byte with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stbux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "247" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. (RS)<sub>56:63</sub> are stored into the byte in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Doubleword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "std",
                    "regs": [ "RS,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "62" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "0" }
            ],
            "code": [
                "if “std”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pstd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For std, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pstd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "",
                "For pstd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Doubleword:"
            ]
        },
        {
            "description": "Prefixed Store Doubleword",
            "form": "8LS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pstd",
                    "regs": [ "RS,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "61" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “std”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pstd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For std, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value DS||0b00, sign-extended to 64 bits.",
                "For pstd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "",
                "For pstd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Doubleword:"
            ]
        },
        {
            "description": "Store Doubleword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdbrx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "660" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>",
                "|| (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub>",
                "|| (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub>",
                "|| (RS)<sub>8:15</sub>  || (RS)<sub>0:7</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. ",
                "(RS)<sub>56:63</sub> are stored into bits 0:7 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>48:55</sub> are stored into bits 8:15 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>40:47</sub> are stored into bits 16:23 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>32:39</sub> are stored into bits 23:31 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>24:31</sub> are stored into bits 32:39 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>16:23</sub> are stored into bits 40:47 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>8:15</sub> are stored into bits 48:55 of the doubleword in ",
                "storage addressed by EA. ",
                "(RS)<sub>0:7</sub> are stored into bits 56:63 of the doubleword in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "149" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA."
            ]
        },
        {
            "description": "Store Doubleword with Update",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdu",
                    "regs": [ "RS,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "62" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "1" }
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "MEM(EA, 8) := (RS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(DS||0b00)</sub>.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Doubleword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "181" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (RS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "(RS) is stored into the doubleword in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfd",
                    "regs": [ "FRS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "54" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “stfd”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstfd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstfd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (FRS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "",
                "For pstfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Prefixed Store Floating-Point Double",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "stfd", "FRS,D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "54" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “stfd”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstfd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstfd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (FRS)",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfd, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfd with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfd with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "",
                "For pstfd, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Double:"
            ]
        },
        {
            "description": "Store Floating-Point Double Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfdx",
                    "regs": [ "FRS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "727" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (FRS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA."
            ]
        },
        {
            "description": "Store Floating-Point Double Pair",
            "form": "DS-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfdp",
                    "regs": [ "FRSp,DS(RA)" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "61" },
                { "name": "FRSp", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "0" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS||0b00)",
                "MEM(EA, 8)   := FRSp<sub>even</sub>",
                "MEM(EA+8, 8) := FRSp<sub>odd</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(DS||0b00)</sub>. ",
                "The contents of the even-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by EA.",
                "The contents of the odd-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by ",
                "EA+8.",
                "If FRSp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double Pair Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfdpx",
                    "regs": [ "FRSp,RA,RB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRSp", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "919" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8)   := FRSp<sub>even</sub>",
                "MEM(EA+8, 8) := FRSp<sub>odd</sub>"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(DS||0b00)</sub>. ",
                "The contents of the even-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by ",
                "EA.",
                "The contents of the odd-numbered register of FRSp are ",
                "stored into the doubleword in storage addressed by ",
                "EA+8.",
                "If FRSp is odd, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfdu",
                    "regs": [ "FRS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "55" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 8) := (FRS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Double with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfdux",
                    "regs": [ "FRS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "759" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (FRS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The contents of register FRS are stored into the double",
                "word in storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Single",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfs",
                    "regs": [ "FRS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "52" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “stfs”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstfs” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstfs” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := SINGLE((FRS))",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "",
                "For pstfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Prefixed Store Floating-Point Single",
            "form": "MLS:D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "stfs", "FRS,D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "52" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “stfs”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstfs” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstfs” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := SINGLE((FRS))",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stfs, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstfs with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstfs with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "",
                "For pstfs, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Floating-Point ",
                "Single:"
            ]
        },
        {
            "description": "Store Floating-Point Single Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfsx",
                    "regs": [ "FRS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "663" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := SINGLE((FRS))",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA."
            ]
        },
        {
            "description": "Store Floating-Point Single with Update",
            "form": "D-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfsu",
                    "regs": [ "FRS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "53" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := SINGLE((FRS))",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point Single with Update Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfsux",
                    "regs": [ "FRS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "695" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := SINGLE((FRS))",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>.",
                "The contents of register FRS are converted to single for",
                "mat (see page168) and stored into the word in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Floating-Point as Integer Word Indexed",
            "form": "X-form",
            "category": "Floating-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stfiwx",
                    "regs": [ "FRS,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "FRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "983" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (FRS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(FRS)<sub>32:63</sub> are stored, without conversion, into the word ",
                "in storage addressed by EA.",
                "If the contents of register FRS were produced, either ",
                "directly or indirectly, by a Load Floating-Point Single ",
                "instruction, a single-precision Arithmetic instruction, or ",
                "frsp, then the value stored is undefined. (The contents ",
                "of register FRS are produced directly by such an instruc",
                "tion if FRS is the target register for the instruction. The ",
                "contents of register FRS are produced indirectly by such ",
                "an instruction if FRS is the final target register of a ",
                "sequence of one or more Floating-Point Move instruc",
                "tions, with the input to the sequence having been pro",
                "duced directly by such an instruction.)",
                "  "
            ]
        },
        {
            "description": "Store Halfword",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sth",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "44" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “sth”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “psth” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “psth” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For sth, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For psth with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For psth with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>48:63</sub> are stored into the halfword in storage ",
                "addressed by EA.",
                "",
                "For psth, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Halfword:"
            ]
        },
        {
            "description": "Prefixed Store Halfword",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "psth",
                    "regs": [ "RS,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "44" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “sth”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “psth” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “psth” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For sth, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For psth with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For psth with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>48:63</sub> are stored into the halfword in storage ",
                "addressed by EA.",
                "",
                "For psth, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Halfword:"
            ]
        },
        {
            "description": "Store Halfword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthbrx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "918" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(RS)<sub>56:63</sub> are stored into bits 0:7 of the halfword in stor",
                "age addressed by EA. ",
                "(RS)<sub>48:55</sub> are stored into bits 8:15 of the halfword in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Halfword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "407" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. (RS)<sub>48:63</sub> are stored into the halfword ",
                "in storage addressed by EA."
            ]
        },
        {
            "description": "Store Halfword with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthu",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "45" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "(RS)<sub>48:63</sub> are stored into the halfword in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Halfword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "439" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. (RS)<sub>48:63</sub> are stored into the halfword in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Multiple Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stmw",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "47" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RS",
                "do while r <= 31",
                "   MEM(EA, 4) := GPR(r)<sub>32:63</sub>",
                "",
                "   r := r + 1",
                "   EA := EA + 4"
            ],
            "body": [
                "Let n = (32-RS). Let the effective address (EA) be the ",
                "sum (RA|0)+<sub>D</sub>.",
                "n consecutive words starting at EA are stored from the ",
                "low-order 32 bits of GPRs RS through 31.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Store String Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stswi",
                    "regs": [ "RS,RA,NB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "NB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "725" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RS - 1",
                "i := 32",
                "do while n > 0",
                "   if i = 32 then r := r + 1 (mod 32)",
                "   MEM(EA, 1) := GPR(r)<sub>i:i+7</sub>",
                "",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB¹0, n=32 if NB=0; n is the number of bytes to store. ",
                "Let nr=CEIL(n/4); nr is the number of registers to ",
                "supply data.",
                "n consecutive bytes starting at EA are stored from ",
                "GPRs RS through RS+nr-1. Data are stored from the ",
                "low-order four bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Store String Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stswx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "661" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER<sub>57:63</sub>",
                "r := RS - 1",
                "i := 32",
                "do while n > 0",
                "   if i = 32 then r := r + 1 (mod 32)",
                "   MEM(EA, 1) := GPR(r)<sub>i:i+7</sub>",
                "",
                "   i := i + 8",
                "   if i = 64 then i := 32",
                "   EA := EA + 1",
                "   n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. Let n = XER<sub>57:63</sub>; n is the number of ",
                "bytes to store. Let nr = CEIL(n/4); nr is the number of ",
                "registers to supply data.",
                "If n>0, n consecutive bytes starting at EA are stored from ",
                "GPRs RS through RS+nr-1. Data are stored from the ",
                "low-order four bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "If n=0, no bytes are stored.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode and n>0, the sys",
                "tem alignment error handler is invoked."
            ]
        },
        {
            "description": "Store VSX Scalar Doubleword",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxsd",
                    "regs": [ "VRS,DS(RA)" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "61" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "2" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if “stxsd”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pstxsd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstxsd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,8)    := VSR[VRS+32].dword[0]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxsd with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxsd with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of doubleword element ",
                "0 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "",
                "For pstxsd, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Prefixed Store VSX Scalar Doubleword",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "stxsd", "VRS", ",D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "46" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if “stxsd”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pstxsd” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstxsd” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,8)    := VSR[VRS+32].dword[0]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxsd, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxsd with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxsd with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of doubleword element ",
                "0 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "",
                "For pstxsd, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Doubleword:"
            ]
        },
        {
            "description": "Store VSX Scalar Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxsdx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "716" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,8)    := VSR[XS].dword[0]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "Let store_data be the contents of doubleword element ",
                "0 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the doubleword in storage at ",
                "address EA in such order that;"
            ]
        },
        {
            "description": "Store VSX Scalar Single - Precision Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxsspx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "652" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,4) ~ bfp32_CONVERT_FROM_BFP64(VSR[32×SX+S].dword[0])",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "Let store_data be the double-precision floating-point ",
                "value in doubleword element 0 of VSR[XS] converted to ",
                "single-precision format",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;"
            ]
        },
        {
            "description": "Store VSX Scalar Single-Precision",
            "form": "DS-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxssp",
                    "regs": [ "VRS,DS(RA)" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "61" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DS", "size": "14" },
                { "name": "opcode", "size": "2", "value": "3" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if “stxsso”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pstxssp” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstxssp” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,4) ~ bfp32_CONVERT_FROM_BFP64(VSR[VRS+32].dword[0])",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the double-precision floating-point ",
                "value in doubleword element 0 of VSR[XS] converted to ",
                "single-precision format",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "",
                "For pstxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Single-Precision:"
            ]
        },
        {
            "description": "Prefixed Store VSX Scalar Single-Precision",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "stxssp", "VRS", ",D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "47" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if “stxsso”  then",
                "   EA := (RA|0) + EXTS64(DS||0b00)",
                "if “pstxssp” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstxssp” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,4) ~ bfp32_CONVERT_FROM_BFP64(VSR[VRS+32].dword[0])",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value VRS + 32.",
                "For stxssp, let the effective address (EA) be the sum of ",
                "the contents of register RA, or the value 0 if RA=0, and ",
                "the value DS||0b00, sign-extended to 64 bits.",
                "For pstxssp with R=0, let the effective address (EA) be ",
                "the sum of the contents of register RA, or the value 0 if ",
                "RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "For pstxssp with R=1, let the effective address (EA) be ",
                "the sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the double-precision floating-point ",
                "value in doubleword element 0 of VSR[XS] converted to ",
                "single-precision format",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "",
                "For pstxssp, if R is equal to 1 and RA is not equal to 0, ",
                "the instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Scalar ",
                "Single-Precision:"
            ]
        },
        {
            "description": "Store VSX Scalar as Integer Byte Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxsibx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "909" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,1) ~ VSR[32×SX+S].byte[7]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The contents of byte element 7 of VSR[XS] are placed ",
                "into the byte in storage addressed by EA."
            ]
        },
        {
            "description": "Store VSX Scalar as Integer Halfword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxsihx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "941" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,2) ~ VSR[32×SX+S].hword[3]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be sum of the contents of ",
                "GPR[RA], or 0 if RA is equal to 0, and the contents of ",
                "GPR[RB].",
                "The contents of halfword element 3 of VSR[XS] are ",
                "placed into the halfword in storage addressed by EA."
            ]
        },
        {
            "description": "Store VSX Scalar as Integer Word Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxsiwx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "140" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ( (RA=0) ? 0 : GPR[RA] ) + GPR[RB]",
                "",
                "MEM(EA,4) := VSR[32×SX+S].word[1]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "Let store_data be the contents of word element 1 of ",
                "VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed in the word in storage at address ",
                "EA in such order that;"
            ]
        },
        {
            "description": "Store VSX Vector",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxv",
                    "regs": [ "XS,DQ(RA)" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "61" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "DQ", "size": "12" },
                { "name": "SX", "size": "1" },
                { "name": "opcode", "size": "3", "value": "5" }
            ],
            "code": [
                "if stxv” & SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if stxv” & SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "if “pstxv” & MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “stxv”  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if “pstxv” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstxv” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,16) := VSR[32×SX+S]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value 32×SX + S.",
                "For stxv, let the effective address (EA) be the sum of ",
                "the contents of GPR[RA], or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For pstxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of GPR[RA], or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "",
                "For pstxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Vector:"
            ]
        },
        {
            "description": "Prefixed Store VSX Vector",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "p",
                    "regs": [ "stxv", "XS", ",D(RA),R" ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "5", "value": "27" },
                { "name": "SX", "size": "1" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if stxv” & SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if stxv” & SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "if “pstxv” & MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if “stxv”  then",
                "   EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if “pstxv” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstxv” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,16) := VSR[32×SX+S]",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XS be the value 32×SX + S.",
                "For stxv, let the effective address (EA) be the sum of ",
                "the contents of GPR[RA], or the value 0 if RA=0, and the ",
                "value DQ||0b0000, sign-extended to 64 bits.",
                "For pstxv with R=0, let the effective address (EA) be the ",
                "sum of the contents of GPR[RA], or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstxv with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "",
                "For pstxv, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store VSX Vector:"
            ]
        },
        {
            "description": "Store VSX Vector Byte*16 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvb16x",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "1004" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "do i = 0 to 15",
                "   MEM(EA+i,1) ~ VSR[32×SX+S].byte[i]",
                "end",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 15, do the following.",
                "  ",
                "Storing a vector of 16 byte elements from VSR[XS] into ",
                "Big-Endian storage using sxvb16x, retaining ",
                "left-to-right element ordering.",
                "Loading a vector of 16 byte elements from ",
                "Little-Endian storage in VSR[XT] using lxvb16x, ",
                "retaining left-to-right element ordering."
            ]
        },
        {
            "description": "Store VSX Vector Doubleword*2 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvd2x",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "972" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,8)     := VSR[32×SX+S].dword[0]",
                "MEM(EA+8,8)   := VSR[32×SX+S].dword[1]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Store VSX Vector Halfword*8 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvh8x",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "940" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "do i = 0 to 7",
                "   MEM(EA+2×i,2) ~ VSR[32×SX+S].hword[i]",
                "end",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "For each integer value from 0 to 7, do the following.",
                "For each integer value from 0 to 7, do the following.",
                "Storing a vector of 8 halfword elements from VSR[X] ",
                "into Big-Endian storage using stxvh8x, retaining ",
                "left-to-right element ordering.",
                "Storing a vector of 8 halfword elements from VSR[X] ",
                "into Little-Endian storage using stxvh8x, retaining ",
                "left-to-right element ordering."
            ]
        },
        {
            "description": "Store VSX Vector Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "396" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,16) ~ VSR[32×SX+S]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be the sum of the ",
                "contents of GPR[RA], or 0 if RA is equal to 0, and the ",
                "contents of GPR[RB].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the quadword in storage at ",
                "address EA in such an order that;",
                "  ",
                "Storing 16 bytes of data into Big-Endian storage from ",
                "VSR[XS] using stxvx.",
                "Storing 16 bytes of data into Little-Endian storage from ",
                "VSR[XS] using stxvx."
            ]
        },
        {
            "description": "Store VSX Vector Paired",
            "form": "DQ-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvp",
                    "regs": [ "XSp,DQ(RA)" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "6" },
                { "name": "Sp", "size": "4" },
                { "name": "SX", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "DQ", "size": "12" },
                { "name": "opcode", "size": "4", "value": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if “stxvp” then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if “pstxvp” then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "",
                "if “stxvp”        then EA ~ EAbase + EAdisp",
                "if “pstxvp” & R=0 then EA ~ EAbase + EAdisp",
                "if “pstxvp” & R=1 then EA ~ CIA    + EAdisp",
                "",
                "store_data.bit[  0:127] ~ VSR[32×SX+2×Sp]",
                "store_data.bit[128:255] ~ VSR[32×SX+2×Sp+1]",
                "",
                "MEM(EA,32) ~ store_data",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XSp be the value 32×SX+2×Sp (i.e., only even ",
                "values of XSp can be encoded in the instruction).",
                "For stxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0 and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For pstxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For pstxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XSp] ",
                "concatenated with VSR[XSp+1].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "For pstxvp, if R is equal to 1 and ",
                "RA is not equal to 0, the instruction form is invalid.",
                "",
                "",
                "Extended mnemonics for Store VSX Vector Paired Pre",
                "fixed:",
                "  "
            ]
        },
        {
            "description": "Prefixed Store VSX Vector Paired",
            "form": "8LS:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "pstxvp",
                    "regs": [ "XSp,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "62" },
                { "name": "Sp", "size": "4" },
                { "name": "SX", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase ~ (RA=0) ? 0 : GPR[RA]",
                "if “stxvp” then",
                "   EAdisp ~ EXTS64(DQ || 0b0000)",
                "if “pstxvp” then",
                "   EAdisp ~ EXTS64(d0 || d1)",
                "",
                "if “stxvp”        then EA ~ EAbase + EAdisp",
                "if “pstxvp” & R=0 then EA ~ EAbase + EAdisp",
                "if “pstxvp” & R=1 then EA ~ CIA    + EAdisp",
                "",
                "store_data.bit[  0:127] ~ VSR[32×SX+2×Sp]",
                "store_data.bit[128:255] ~ VSR[32×SX+2×Sp+1]",
                "",
                "MEM(EA,32) ~ store_data",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XSp be the value 32×SX+2×Sp (i.e., only even ",
                "values of XSp can be encoded in the instruction).",
                "For stxvp, let the effective address (EA) be the sum of ",
                "the integer value in GPR[RA], or 0 if RA=0 and the value ",
                "DQ||0b0000, sign-extended to 64 bits.",
                "For pstxvp, if R=0, let the effective address (EA) be the ",
                "sum of the integer value in GPR[RA], or 0 if RA=0, and ",
                "the value d0||d1, sign-extended to 64 bits.",
                "For pstxvp, if R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "Let store_data be the contents of VSR[XSp] ",
                "concatenated with VSR[XSp+1].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "For pstxvp, if R is equal to 1 and ",
                "RA is not equal to 0, the instruction form is invalid.",
                "",
                "",
                "Extended mnemonics for Store VSX Vector Paired Pre",
                "fixed:",
                "  "
            ]
        },
        {
            "description": "Store VSX Vector Paired Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvpx",
                    "regs": [ "XSp,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "Sp", "size": "4" },
                { "name": "SX", "size": "1" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "461" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "store_data.bit[  0:127] ~ VSR[32×SX+2×Sp]",
                "store_data.bit[128:255] ~ VSR[32×SX+2×Sp+1]",
                "",
                "MEM(EA,32) ~ store_data",
                ""
            ],
            "body": [
                "Let XSp be the value 32×SX + 2×Sp (i.e., only even ",
                "values of XSp can be encoded in the instruction).",
                "Let the effective address (EA) be the sum of the integer ",
                "value in GPR[RA], or 0 if RA=0, and the integer value in ",
                "GPR[RB].",
                "Let store_data be the contents of VSR[XSp] ",
                "concatenated with VSR[XSp+1].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the octword in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Byte Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvrbx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "141" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB];",
                "MEM(EA,1) = VSR[32×SX+S].byte[15];"
            ],
            "body": [
                "Let XS be the value of 32×SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "The contents of byte element 15 of VSR[XS] are placed ",
                "into storage at address EA."
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Doubleword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvrdx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "237" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,8) = VSR[32×SX+S].dword[1]"
            ],
            "body": [
                "Let XS be the value of 32×SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Let store_data be the contents of doubleword element ",
                "1 of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the doubleword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the doubleword in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Halfword Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvrhx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "173" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,2) = VSR[32×SX+S].hword[7]"
            ],
            "body": [
                "Let XS be the value of 32×SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Let store_data be the contents of halfword element 7 ",
                "of VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the halfword in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the halfword in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Rightmost Word Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvrwx",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "205" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,4) = VSR[32×SX+S].word[3]"
            ],
            "body": [
                "Let XS be the value of 32×SX + S.",
                "Let EA be the sum of GPR[RA], or 0 if RA=0, and GPR[RB].",
                "Let store_data be the contents of word element 3 of ",
                "VSR[XS].",
                "When Big-Endian byte ordering is employed, ",
                "store_data is placed into the word in storage at ",
                "address EA in such an order that;",
                "When Little-Endian byte ordering is employed, ",
                "store_data is placed into the word in storage at ",
                "address EA in such an order that;"
            ]
        },
        {
            "description": "Store VSX Vector Word*4 Indexed",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvw4x",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "908" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA ~ ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "",
                "MEM(EA,4)     := VSR[32×SX+S].word[0]",
                "MEM(EA+4,4)   := VSR[32×SX+S].word[1]",
                "MEM(EA+8,4)   := VSR[32×SX+S].word[2]",
                "MEM(EA+12,4)  := VSR[32×SX+S].word[3]",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let EA be the sum of the contents of GPR[RA], or 0 if RA ",
                "is equal to 0, and the contents of GPR[RB].",
                "For each integer value i from 0 to 3, do the following.",
                "  "
            ]
        },
        {
            "description": "Store VSX Vector with Length",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvl",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "397" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ (RA=0) ? 0 : GPR[RA]",
                "",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb ~ 16",
                "",
                "if MSR.LE = 0 then       // Big-Endian byte-ordering",
                "   store_data ~ VSR[32×SX+S].byte[0:nb-1]",
                "else                     // Little-Endian byte ordering",
                "   store_data ~ VSR[32×SX+S].byte[16-nb:15]",
                "",
                "MEM(EA,nb) ~ store_data",
                ""
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed.",
                "Otherwise, when Big-Endian byte-ordering is ",
                "employed, do the following.",
                "Otherwise, when Little-Endian byte ordering is ",
                "employed, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Storing less than 16-byte data in VSR[XS] into ",
                "BigEndian storage using stxvl.",
                "Storing less than 16-byte data in VSR[XS] into ",
                "LittleEndian storage using stxvl."
            ]
        },
        {
            "description": "Store VSX Vector with Length Left-justified",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "stxvll",
                    "regs": [ "XS,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "S", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "429" },
                { "name": "SX", "size": "1" }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA ~ (RA=0) ? 0 : GPR[RA]",
                "",
                "nb ~ EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb ~ 16",
                "",
                "if nb>0 then do i = 0 to nb-1",
                "   MEM(EA+i,1) ~ VSR[32×SX+S].byte[i]",
                "",
                "end"
            ],
            "body": [
                "Let XS be the value 32×SX + S.",
                "Let the effective address (EA) be the contents of ",
                "GPR[RA], or 0 if RA is equal to 0.",
                "Let nb be the unsigned integer value in bits 0:7 of ",
                "GPR[RB].",
                "If nb is equal to 0, the storage access is not performed.",
                "Otherwise, do the following.",
                "If the contents of bits 8:63 of GPR[RB] are not equal to ",
                "0, the results are boundedly undefined.",
                "Storing less than 16-byte data, left-justified in VSR[XS], ",
                "into storage using stxvll."
            ]
        },
        {
            "description": "Store Vector Element Byte Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "stvebx",
                    "regs": [ "VRS,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "135" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then ",
                "   MEM(EA,1) := VSR[VRS+32].byte[eb]",
                "else",
                "   MEM(EA,1) := VSR[VRS+32].byte[15-eb]"
            ],
            "body": [
                "Let EA be the sum of the contents of GPR[RA], or 0 if ",
                "RA=0, and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, the contents of byte eb of VSR[VRS+32] are ",
                "placed in the byte in storage at address EA.",
                "If Little-Endian byte ordering is used for the storage ",
                "access, the contents of byte 15-eb of VSR[VRS+32] are ",
                "placed in the byte in storage at address EA.",
                " "
            ]
        },
        {
            "description": "Store Vector Element Halfword Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "stvehx",
                    "regs": [ "VRS,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "167" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFE",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then ",
                "   MEM(EA,2) := VSR[VRS+32].byte[eb:eb+1]",
                "else",
                "   MEM(EA,2) := VSR[VRS+32][14-eb:15-eb]"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If Little-Endian byte ordering is used for the storage ",
                "access, ",
                "  "
            ]
        },
        {
            "description": "Store Vector Element Word Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "stvewx",
                    "regs": [ "VRS,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "199" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFC",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then ",
                "   MEM(EA,4) := VSR[VRS+32].byte[eb:eb+3]",
                "else",
                "   MEM(EA,4) := VSR[VRS+32].byte[12-eb:15-eb]"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "Let eb be bits 60:63 of EA.",
                "If Big-Endian byte ordering is used for the storage ",
                "access, ",
                "If Little-Endian byte ordering is used for the storage ",
                "access,",
                " "
            ]
        },
        {
            "description": "Store Vector Indexed",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "stvx",
                    "regs": [ "VRS,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "231" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "MEM(EA, 16) := VSR[VRS+32]"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of VSR[VRS+32] are placed into the ",
                "quadword in storage at address EA. "
            ]
        },
        {
            "description": "Store Vector Indexed Last",
            "form": "X-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "stvxl",
                    "regs": [ "VRS,RA,RB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "VRS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "487" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) +<sub> GPR[RB]</sub>",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "MEM(EA, 16) := VSR[VRS+32]",
                "",
                "mark_as_not_likely_to_be_needed_again_anytime_soon(EA)"
            ],
            "body": [
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 ",
                "with the sum of the contents of GPR[RA], or 0 if RA=0, ",
                "and the contents of GPR[RB].",
                "The contents of VSR[VRS+32] are placed into the ",
                "quadword in storage at address EA. ",
                "stvxl provides a hint that the quadword in storage ",
                "addressed by EA will probably not be needed again by ",
                "the program in the near future.",
                ""
            ]
        },
        {
            "description": "Store Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stw",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "36" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "if “stw”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstw” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstw” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stw, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstw with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstw with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>32:63</sub> are stored into the word in storage addressed ",
                "by EA.",
                "",
                "For pstw, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Word:"
            ]
        },
        {
            "description": "Prefixed Store Word",
            "form": "MLS:D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "pstw",
                    "regs": [ "RS,D(RA),R" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "R", "size": "1" },
                { "name": "reserved", "size": "2" },
                { "name": "d0", "size": "18" },
                { "name": "opcode", "size": "6", "value": "36" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "d1", "size": "16" }
            ],
            "code": [
                "if “stw”  then",
                "   EA := (RA|0) + EXTS64(D)",
                "if “pstw” & R=0 then",
                "   EA := (RA|0) + EXTS64(d0||d1)",
                "if “pstw” & R=1 then",
                "   EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Prefix:",
                "Suffix::",
                "For stw, let the effective address (EA) be the sum of the ",
                "contents of register RA, or the value 0 if RA=0, and the ",
                "value D, sign-extended to 64 bits.",
                "For pstw with R=0, let the effective address (EA) be the ",
                "sum of the contents of register RA, or the value 0 if RA=0, ",
                "and the value d0||d1, sign-extended to 64 bits.",
                "For pstw with R=1, let the effective address (EA) be the ",
                "sum of the address of the instruction and the value ",
                "d0||d1, sign-extended to 64 bits.",
                "(RS)<sub>32:63</sub> are stored into the word in storage addressed ",
                "by EA.",
                "",
                "For pstw, if R is equal to 1 and RA is not equal to 0, the ",
                "instruction form is invalid.",
                "Extended mnemonics for Prefixed Store Word:"
            ]
        },
        {
            "description": "Store Word Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwbrx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "662" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> || (RS)<sub>40:47</sub>",
                "               ||(RS)<sub>32:39</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>.",
                "(RS)<sub>56:63</sub> are stored into bits 0:7 of the word in storage ",
                "addressed by EA. ",
                "(RS)<sub>48:55</sub> are stored into bits 8:15 of the word in storage ",
                "addressed by EA. ",
                "(RS)<sub>40:47</sub> are stored into bits 16:23 of the word in stor",
                "age addressed by EA. ",
                "(RS)<sub>32:39</sub> are stored into bits 24:31 of the word in stor",
                "age addressed by EA."
            ]
        },
        {
            "description": "Store Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "151" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+<sub>(RB)</sub>. (RS)<sub>32:63</sub> are stored into the word in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Word with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwu",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "37" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "D", "size": "16" }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+<sub>D</sub>. ",
                "(RS)<sub>32:63</sub> are stored into the word in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Word with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "opcode", "size": "10", "value": "183" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+<sub>(RB)</sub>. (RS)<sub>32:63</sub> are stored into the word in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Subtract From",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subf",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subf.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subfo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subfo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "40" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := ~(RA) + (RB) + 1"
            ],
            "body": [
                "The sum ¬(RA) + (RB) + 1 is placed into register RT.",
                "Example of extended mnemonics for Subtract From:"
            ]
        },
        {
            "description": "Subtract From Carrying",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfc",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfc.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfco",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfco.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "8" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := ~(RA) + (RB) + 1"
            ],
            "body": [
                "The sum ¬(RA) + (RB) + 1 is placed into register RT.",
                "Example of extended mnemonics for Subtract From ",
                "Carrying:"
            ]
        },
        {
            "description": "Subtract From Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfe",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfe.",
                    "regs": [ "RT,RA,RB", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfeo",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfeo.",
                    "regs": [ "RT,RA,RB", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "136" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := ~(RA) + (RB) + CA"
            ],
            "body": [
                "The sum ¬(RA) + (RB) + CA is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Immediate Carrying",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfic",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "8" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "RT := ~(RA) + EXTS(SI) + 1"
            ],
            "body": [
                "The sum ¬(RA) + SI + 1 is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Minus One Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfme",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfme.",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfmeo",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfmeo.",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "232" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := ~(RA) + CA - 1"
            ],
            "body": [
                "The sum ¬(RA) + CA + 641 is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Zero Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfze",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfze.",
                    "regs": [ "RT,RA", "(", "OE=0 Rc=1", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfzeo",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfzeo.",
                    "regs": [ "RT,RA", "(", "OE=1 Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "OE", "size": "1" },
                { "name": "opcode", "size": "9", "value": "200" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RT := ~(RA) + CA"
            ],
            "body": [
                "The sum ¬(RA) + CA is placed into register RT."
            ]
        },
        {
            "description": "System Call",
            "form": "SC-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "sc",
                    "regs": [ "LEV" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "17" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "LEV", "size": "7" },
                { "name": "reserved", "size": "3" },
                { "name": "opcode", "size": "1", "value": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "System Call Vectored",
            "form": "SC-form",
            "category": "Branch Facility",
            "mnemonics": [
                {
                    "mnemonic": "scv",
                    "regs": [ "LEV" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "17" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "LEV", "size": "7" },
                { "name": "reserved", "size": "3" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "opcode", "size": "1", "value": "1" }
            ],
            "code": [

            ],
            "body": [
                "These instructions call the system to perform a service. ",
                "A complete description of these instructions can be ",
                "found in Section4.3.1 of Book III.",
                "The first form of the instruction (sc) provides a single ",
                "system call. The second form of the instruction (scv) ",
                "provides the capability for 128 unique system calls.",
                "The use of the LEV field is described in Book III. In the ",
                "first form of the instruction the LEV values greater than ",
                "1 are reserved, and bits 0:5 of the LEV field (instruction ",
                "bits 20:25) are treated as a reserved field.",
                "When control is returned to the program that executed ",
                "the System Call or System Call Vectored instruction, ",
                "the contents of the registers will depend on the register ",
                "conventions used by the program providing the system ",
                "service.",
                "These instructions are context synchronizing (see Book ",
                "III).",
                "  ",
                "",
                ""
            ]
        },
        {
            "description": "Trap Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "td",
                    "regs": [ "TO,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "TO", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "68" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "a := (RA)",
                "b := (RB)",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "if (a < b) & TO<sub>0</sub>",
                "",
                " then TRAP",
                "if (a > b) & TO<sub>1</sub>",
                "",
                "",
                " then TRAP",
                "if (a = b) & TO<sub>2</sub>",
                "",
                "",
                " then TRAP",
                "if (a <<sup>u</sup> b) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> b) & TO<sub>4</sub> ",
                " then TRAP"
            ],
            "body": [
                "The contents of register RA are compared with the con",
                "tents of register RB. ",
                "",
                " any bit in the TO field is set to 1 and its corre",
                "sponding condition is met by the result of the compari",
                "son, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "Examples of extended mnemonics for Trap Double",
                "word:"
            ]
        },
        {
            "description": "Trap Doubleword Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "tdi",
                    "regs": [ "TO,RA,SI" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "2" },
                { "name": "TO", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "a := (RA)",
                "b := EXTS(SI)",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "if (a < b) & TO<sub>0</sub>",
                "",
                " then TRAP",
                "if (a > b) & TO<sub>1</sub>",
                "",
                "",
                " then TRAP",
                "if (a = b) & TO<sub>2</sub>",
                "",
                "",
                " then TRAP",
                "if (a <<sup>u</sup> b) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> b) & TO<sub>4</sub> ",
                " then TRAP"
            ],
            "body": [
                "The contents of register RA are compared with the ",
                "sign-extended value of the SI field. ",
                "",
                "any bit in the TO field is set to 1 ",
                "and its corresponding condition is met by the result of ",
                "the comparison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "Examples of extended mnemonics for Trap Double",
                "word Immediate:"
            ]
        },
        {
            "description": "Trap Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "tw",
                    "regs": [ "TO,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "TO", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "4" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "a := EXTS((RA)<sub>32:63</sub>)",
                "b := EXTS((RB)<sub>32:63</sub>)",
                "if (a < b) & TO<sub>0</sub> then TRAP",
                "if (a > b) & TO<sub>1</sub> then TRAP",
                "if (a = b) & TO<sub>2</sub> then TRAP",
                "if (a <<sup>u</sup> b) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> b) & TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "The contents of RA<sub>32:63</sub> are compared with the contents ",
                "of RB<sub>32:63</sub>. If any bit in the TO field is set to 1 and its cor",
                "responding condition is met by the result of the compar",
                "ison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "Examples of extended mnemonics for Trap Word:"
            ]
        },
        {
            "description": "Trap Word Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "twi",
                    "regs": [ "TO,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "3" },
                { "name": "TO", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "SI", "size": "16" }
            ],
            "code": [
                "a := EXTS((RA)<sub>32:63</sub>)",
                "if (a < EXTS(SI)) & TO<sub>0</sub>  then TRAP",
                "if (a > EXTS(SI)) & TO<sub>1</sub>  then TRAP",
                "if (a = EXTS(SI)) & TO<sub>2</sub>  then TRAP",
                "if (a <<sup>u</sup> EXTS(SI)) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> EXTS(SI)) & TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "The contents of RA<sub>32:63</sub> are compared with the ",
                "sign-extended value of the SI field. If any bit in the TO ",
                "field is set to 1 and its corresponding condition is met ",
                "by the result of the comparison, the system trap han",
                "dler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "Examples of extended mnemonics for Trap Word ",
                "Immediate:"
            ]
        },
        {
            "description": "VSX Move From Accumulator",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxmfacc",
                    "regs": [ "AS" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "AS", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "177" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[4×AS]   := ACC[AS][0]",
                "VSR[4×AS+1] := ACC[AS][1]",
                "VSR[4×AS+2] := ACC[AS][2]",
                "VSR[4×AS+3] := ACC[AS][3]"
            ],
            "body": [
                "For each integer value i from 0 to 3, the contents of ",
                "row i of ACC[AS] are placed into VSR[4×AS+i]."
            ]
        },
        {
            "description": "VSX Move To Accumulator",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxmtacc",
                    "regs": [ "AT" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "177" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ACC[AT][0] := VSR[4×AT]",
                "ACC[AT][1] := VSR[4×AT+1]",
                "ACC[AT][2] := VSR[4×AT+2]",
                "ACC[AT][3] := VSR[4×AT+3]"
            ],
            "body": [
                "For each integer value i from 0 to 3, the contents of ",
                "VSR[4×AT+i] are placed into row i of ACC[AT]."
            ]
        },
        {
            "description": "VSX Scalar Absolute Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsabsdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "345" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32×BX+B].dword[0]",
                "VSR[32×TX+T].dword[0] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The absolute value of the double-precision ",
                "floating-point operand in doubleword element 0 of ",
                "VSR[XB] is placed into doubleword element 0 of VSR[XT] ",
                "in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                " "
            ]
        },
        {
            "description": "VSX Scalar Absolute Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsabsqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "804" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATIVE_ABSOLUTE(VSR[VRB+32])"
            ],
            "body": [
                "Let XT be the value VRT + 32.",
                "The absolute value of the quadprecision floating-point ",
                "value in VSR[XB] is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Scalar Add Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsadddp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "32" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[VRA+32].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v      := bfp_ADD(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is added to src1, producing a sum having ",
                "unbounded range and precision.",
                "The sum is normalized.",
                "See Table61, “Actions for xsadddp,” on page674.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Add Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsaddqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "4" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_ADD(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "if ox_flag=1     then SetFX(FPSCR.OX)",
                "if ux_flag=1     then SetFX(FPSCR.UX)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1.",
                "If src1 and src2 are Infinity values having opposite ",
                "signs, an Invalid Operation exception occurs and VXISI ",
                "is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 and src2 are Infinity values having ",
                "opposite signs, the result is the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Add Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsaddsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "0" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[VRA+32].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v        := bfp_ADD(src1, src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is added to src1, producing a sum having ",
                "unbounded range and precision.",
                "The sum is normalized.",
                "See Table64, “Actions for xsaddsp,” on page679.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Compare Equal Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpeqdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "3" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "",
                "if vex_flag=0 then do",
                "   if src1=src2 then",
                "      VSR[32×TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "      VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "   else do",
                "      VSR[32×TX+T].dword[0] := 0x0000_0000_0000_0000",
                "      VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, equal.",
                "The contents of doubleword 0 of VSR[XT] are set to ",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is equal to src2, and are ",
                "set to 0x0000_0000_0000_0000 otherwise.",
                "The contents of doubleword 1 of VSR[XT] are set to ",
                "0x0000_0000_0000_0000.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Compare Equal Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpeqqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "68" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, equal.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "equal to src2, and are set to all 0s otherwise.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Compare Exponents Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpexpdp",
                    "regs": [ "BF,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "59" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 ~ VSR[32×AX+A].dword[0]",
                "src2 ~ VSR[32×BX+B].dword[0]",
                "",
                "src1.exponent ~ EXTZ(src1.bit[1:11])",
                "src2.exponent ~ EXTZ(src2.bit[1:11])",
                "src1.fraction ~ EXTZ(src1.bit[12:63])",
                "src2.fraction ~ EXTZ(src2.bit[12:63])",
                "",
                "src1.class.NaN ~ (src1.exponent = 2047) & (src1.fraction != 0)",
                "src2.class.NaN ~ (src2.exponent = 2047) & (src2.fraction != 0)",
                "",
                "lt_flag ~ (src1.exponent < src2.exponent)",
                "gt_flag ~ (src1.exponent > src2.exponent)",
                "eq_flag ~ (src1.exponent = src2.exponent)",
                "uo_flag ~ src1.class.NaN | src2.class.NaN",
                "",
                "CR.bit[4×BF+32] ~ FPSCR.FL ~ !uo_flag & lt_flag",
                "CR.bit[4×BF+33] ~ FPSCR.FG ~ !uo_flag & gt_flag",
                "CR.bit[4×BF+34] ~ FPSCR.FE ~ !uo_flag & eq_flag",
                "CR.bit[4×BF+35] ~ FPSCR.FU ~  uo_flag"
            ],
            "body": [
                "Let XA be the sum 32×AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The exponent of src1 is compared with the exponent of ",
                "src2. The result of the compare is placed into FPCC and ",
                "CR field BF."
            ]
        },
        {
            "description": "VSX Scalar Compare Exponents Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpexpqp",
                    "regs": [ "BF,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "164" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src1           := VSR[VRA+32]",
                "src2           := VSR[VRB+32]",
                "",
                "src1.exponent  := EXTZ(src1.bit[1:15])",
                "src2.exponent  := EXTZ(src2.bit[1:15])",
                "src1.fraction  := EXTZ(src1.bit[16:127])",
                "src2.fraction  := EXTZ(src2.bit[16:127])",
                "",
                "src1.class.NaN := (src1.exponent = 32767) &",
                "                   (src1.fraction != 0)",
                "src2.class.NaN := (src2.exponent = 32767) &",
                "                   (src2.fraction != 0)",
                "",
                "lt_flag := (src1.exponent < src2.exponent)",
                "gt_flag := (src1.exponent > src2.exponent)",
                "eq_flag := (src1.exponent = src2.exponent)",
                "uo_flag := src1.class.NaN | src2.class.NaN",
                "",
                "CR.bit[4×BF+32] := FPSCR.FL := !uo_flag & lt_flag",
                "CR.bit[4×BF+33] := FPSCR.FG := !uo_flag & gt_flag",
                "CR.bit[4×BF+34] := FPSCR.FE := !uo_flag & eq_flag",
                "CR.bit[4×BF+35] := FPSCR.FU :=  uo_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "The exponent of src1 is compared with the exponent of ",
                "src2 as unsigned integer values. The result of the ",
                "compare is placed into FPCC and CR field BF."
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgtdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "11" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "vex_flag := FPSCR.VE & (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "   if src1 > src2 then",
                "      VSR[32×TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "      VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "   else do",
                "      VSR[32×TX+T].dword[0] := 0x0000_0000_0000_0000",
                "      VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than.",
                "The contents of doubleword 0 of VSR[VRT] are set to ",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is greater than src2, and ",
                "are set to 0x0000_0000_0000_0000 otherwise.",
                "The contents of doubleword 1 of VSR[VRT] are set to ",
                "0x0000_0000_0000_0000.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgtqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "228" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than src2, and are set to all 0s otherwise.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than or Equal Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgedp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "19" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN)",
                "",
                "vex_flag := FPSCR.VE & (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1 SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "   if src1 >= src2 then",
                "      VSR[32×TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "      VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "   else do",
                "      VSR[32×TX+T].dword[0] := 0x0000_0000_0000_0000",
                "      VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than or ",
                "equal.",
                "The contents of doubleword 0 of VSR[XT] are set to ",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is greater than or equal ",
                "to src2, and are set to 0x0000_0000_0000_0000 ",
                "otherwise.",
                "The contents of doubleword 1 of VSR[XT] are set to ",
                "0x0000_0000_0000_0000.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Compare Greater Than or Equal Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpgeqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "196" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "src1 is compared to src2.",
                "A NaN compared to any value, including itself, ",
                "compares false for the predicate, greater than or ",
                "equal.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than or equal to src2, and are set to all 0s ",
                "otherwise.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Compare Ordered Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpodp",
                    "regs": [ "BF,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "43" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "CR.bit[4×BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4×BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4×BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4×BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                               src1.class.QNaN |",
                "                               src2.class.SNaN |",
                "                               src2.class.QNaN"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal.",
                "Infinities of same signs compare equal.",
                "See Table66, “Actions for xscmpodp - Part 1: ",
                "Compare Ordered,” on page691.",
                "The result of the compare is placed into CR field BF ",
                "and the FPCC.",
                "If either of the operands is a NaN, either quiet or ",
                "signaling, CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling ",
                "NaN, VXSNAN is set, and Invalid Operation is disabled ",
                "(VE=0), VXVC is set. If neither operand is a Signaling ",
                "NaN but at least one operand is a Quiet NaN, VXVC is ",
                "set.",
                "See Table67, “Actions for xscmpodp - Part 2: Result,” ",
                "on page691."
            ]
        },
        {
            "description": "VSX Scalar Compare Ordered Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpoqp",
                    "regs": [ "BF,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "132" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "   vxsnan_flag := 0b1",
                "   if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "   vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "CR.bit[4×BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4×BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4×BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4×BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                               src1.class.QNaN |",
                "                               src2.class.SNaN |",
                "                               src2.class.QNaN"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal. ",
                "Infinities of same signs compare equal.",
                "Bit 0 of CR field BF and FL are set to indicate if src1 is ",
                "less than src2.",
                "Bit 1 of CR field BF and FG are set to indicate if src1 is ",
                "greater than src2.",
                "Bit 2 of CR field BF and FE are set to indicate if src1 is ",
                "equal to src2.",
                "Bit 3 of CR field BF and FU are set to indicate unordered ",
                "(i.e., src1 or src2 is a NaN).",
                "If either of the operands is a NaN, either quiet or ",
                "signaling, CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling ",
                "NaN, an Invalid Operation exception occurs and ",
                "VXSNAN is set, and if Invalid Operation exceptions are ",
                "disabled (VE=0), VXVC is set. If neither operand is a ",
                "Signaling NaN but at least one operand is a Quiet ",
                "NaN, an Invalid Operation exception occurs and VXVC ",
                "is set."
            ]
        },
        {
            "description": "VSX Scalar Compare Unordered Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpudp",
                    "regs": [ "BF,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "35" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "CR.bit[4×BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4×BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4×BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4×BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                               src1.class.QNaN |",
                "                               src2.class.SNaN |",
                "                               src2.class.QNaN"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal equal.",
                "Infinities of same signs compare equal.",
                "See Table68, “Actions for xscmpudp - Part 1: ",
                "Compare Unordered,” on page694.",
                "The result of the compare is placed into CR field BF ",
                "and the FPCC.",
                "If either of the operands is a NaN, either quiet or ",
                "signaling, CR field BF and the FPCC are set to reflect ",
                "unordered. If either of the operands is a Signaling ",
                "NaN, VXSNAN is set.",
                "See Table69, “Actions for xscmpudp - Part 2: Result,” ",
                "on page694."
            ]
        },
        {
            "description": "VSX Scalar Compare Unordered Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscmpuqp",
                    "regs": [ "BF,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "644" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "src1 is compared to src2.",
                "Zeros of same or opposite signs compare equal. ",
                "Infinities of same signs compare equal.",
                "Bit 0 of CR field BF and FL are set to indicate if src1 is ",
                "less than src2.",
                "Bit 1 of CR field BF and FG are set to indicate if src1 is ",
                "greater than src2.",
                "Bit 2 of CR field BF and FE are set to indicate if src1 is ",
                "equal to src2.",
                "Bit 3 of CR field BF and FU are set to indicate unordered ",
                "(i.e., src1 or src2 is a NaN).",
                "If either of the operands is a Signaling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1."
            ]
        },
        {
            "description": "VSX Scalar Convert Double-Precision to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "22" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "",
                "if src.class.SNaN then",
                "   result := bfp128_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "else",
                "   result := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "vxsnan_flag := src.class.SNaN",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := 0"
            ],
            "body": [
                "Let src be the floating-point value in doubleword ",
                "element 0 of VSR[VRB+32] represented in ",
                "doubleprecision format.",
                "src is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN is set to 1.",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[XT] and FPRF are not modified."
            ]
        },
        {
            "description": "VSX Scalar Convert Half-Precision to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvhpdp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "16" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "347" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src ~ bfp_CONVERT_FROM_BFP16(VSR[BX×32+B].hword[3])",
                "",
                "if src.class.SNaN=1 then",
                "   result ~ bfp64_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "else",
                "   result ~ bfp64_CONVERT_FROM_BFP(src)",
                "",
                "vxsnan_flag ~ src.class.SNaN",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag ~ FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[TX×32+T].dword[0] ~ result",
                "   VSR[TX×32+T].dword[1] ~ 0x0000_0000_0000_0000",
                "   FPSCR.FPRF ~ fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR ~ 0",
                "FPSCR.FI ~ 0"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the half-precision floating-point value in the ",
                "rightmost halfword of doubleword element 0 of VSR[XB].",
                "If src is an SNaN, the result is the double-precision ",
                "representation of that SNaN converted to a QNaN.",
                "Otherwise, if src is a QNaN, the result is the ",
                "double-precision representation of that QNaN.",
                "Otherwise, if src is an Infinity, the result is the ",
                "double-precision representation of Infinity with the ",
                "same sign as src.",
                "Otherwise, if src is a Zero, the result is the ",
                "double-precision representation of Zero with the same ",
                "sign as src.",
                "Otherwise, if src is a denormal value, the result is the ",
                "normalized double-precision representation of src.",
                "Otherwise, the result is the double-precision ",
                "representation of src.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in double-precision format.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified.",
                "FR is set to 0. FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Scalar Single-Precision to Vector Single - Precision format Non-signalling",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpspn",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "267" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "result := bfp32_CONVERT_FROM_BFP(src)",
                "",
                "VSR[32×TX+T].word[0] := result",
                "VSR[32×TX+T].word[1] := result",
                "VSR[32×TX+T].word[2] := 0x0000_0000",
                "VSR[32×TX+T].word[3] := 0x0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the single-precision floating-point value in ",
                "doubleword element 0 of VSR[XB] represented in ",
                "double-precision format.",
                "src is placed into word elements 0 and 1 of VSR[XT] in ",
                "single-precision format.",
                "The contents of word elements 2 and 3 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Signed Doubleword to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvsdqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "10" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src         := bfp_CONVERT_FROM_SI64(VSR[VRB+32].dword[0])",
                "result      := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := 0",
                "FPSCR.FI    := 0"
            ],
            "body": [
                "Let src be the signed integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "src is placed into VSR[VRT+32] in quadprecision ",
                "floating-point format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Single-Precision to Double - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvspdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "329" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[0])",
                "vxsnan_flag := src.class.SNaN",
                "result := bfp64_CONVERT_FROM_BFP(src)",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the single-precision floating-point value in ",
                "word element 0 of VSR[XB].",
                "If src is a SNaN, the result is src, converted to a ",
                "QNaN (i.e., bit 9 of src set to 1). VXSNAN is set to 1.",
                "Otherwise, the result is src.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] is not modified, FPRF is not modified, FR is set ",
                "to 0, and FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Single-Precision to Double - Precision format Non-signalling",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvspdpn",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "331" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[0])",
                "result := bfp64_CONVERT_FROM_BFP(src)",
                "VSR[32×TX+T].dword[0] := result",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the single-precision floating-point value in ",
                "word element 0 of VSR[XB].",
                "src is placed into doubleword element 0 of VSR[XT] in ",
                "double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert Unsigned Doubleword to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvudqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src         := bfp_CONVERT_FROM_UI64(VSR[VRB+32].dword[0])",
                "result      := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := 0",
                "FPSCR.FI    := 0"
            ],
            "body": [
                "Let src be the unsigned integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "src is placed into VSR[VRT+32] in quadprecision ",
                "floating-point format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Double-Precision t o Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "265" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "result := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].word[0] := result",
                "   VSR[32×TX+T].word[1] := result",
                "   VSR[32×TX+T].word[2] := 0x0000_0000",
                "   VSR[32×TX+T].word[3] := 0x0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a SNaN, the result is src converted to a QNaN ",
                "(i.e., bit 12 of src is set to 1). VXSNAN is set to 1.",
                "Otherwise, if src is a QNaN, an Infinity, or a Zero, the ",
                "result is src.",
                "Otherwise, the result is src rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into word elements 0 and 1 of ",
                "VSR[XT] in single-precision format.",
                "The contents of word elements 2 and 3 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Double-Precision to Half-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdphp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "17" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "347" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src    ~ bfp_CONVERT_FROM_BFP64(VSR[BX×32+B].dword[0])",
                "rnd    ~ bfp_ROUND_TO_BFP16(FPSCR.RN,src)",
                "result ~ bfp16_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag ~ FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[TX×32+T].hword[0:2] ~ 0x0000_0000_0000",
                "   VSR[TX×32+T].hword[3]   ~ result",
                "   VSR[TX×32+T].dword[1]   ~ 0x0000_0000_0000_0000",
                "   FPSCR.FPRF              ~ fprf_CLASS_BFP16(result)",
                "end",
                "FPSCR.FR ~ (vex_flag=0) & inc_flag",
                "FPSCR.FI ~ (vex_flag=0) & xx_flag"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is an SNaN, the result is the half-precision ",
                "representation of that SNaN converted to a QNaN.",
                "Otherwise, if src is a QNaN, the result is the ",
                "half-precision representation of that QNaN.",
                "Otherwise, if src is an Infinity, the result is the ",
                "half-precision representation of Infinity with the same ",
                "sign as src.",
                "Otherwise, if src is a Zero, the result is the ",
                "half-precision representation of Zero with the same ",
                "sign as src.",
                "Otherwise, the result is the half-precision ",
                "representation of src rounded to half-precision using ",
                "the rounding mode specified by RN.",
                "The result is zero-extended and placed into ",
                "doubleword element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in half-precision. FR is set to indicate if the ",
                "result was incremented when rounded. FI is set to ",
                "indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Convert with round Quad-Precision to Double-Precision format [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpdp",
                    "regs": [ "VRT,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "20" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP64(RO,FPSCR.RN,src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := (vxsnan_flag=0) & inc_flag",
                "FPSCR.FI := (vxsnan_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN is set to 1.",
                "If src is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to the Signalling NaN, with the ",
                "significand truncated to the rounding precision.",
                "Otherwise, if src is a Quiet NaN, then the result is src ",
                "with the significand truncated to double-precision.",
                "Otherwise, if src is an Infinity or a Zero, the result is ",
                "src.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in doubleprecision format. The contents ",
                "of doubleword element 1 of VSR[VRT+32] are set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in double-precision format. FR is set to ",
                "indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Signed D oubleword to D ouble - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvsxddp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "376" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_SI64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32×TX+T].dword[0] := result",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the signed integer value in doubleword ",
                "element 0 of VSR[XB].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to double-precision ",
                "using the rounding mode specified by RN. ",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Convert with round Signed Doubleword to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvsxdsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "312" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_SI64(VSR[32×BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32×TX+T].dword[0] := result64",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the two’s-complement integer value in ",
                "doubleword element 0 of VSR[XB].",
                "src is converted to floating-point format, and rounded ",
                "to single-precision using the rounding mode specified ",
                "by RN. ",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Signed Quadword to Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvsqqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "11" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_SI128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP128(0,FPSCR.RN,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(XX)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := inc_flag",
                "FPSCR.FI    := xx_flag"
            ],
            "body": [
                "Let src be the 128-bit signed integer value in ",
                "VSR[VRB+32].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to quad-precision ",
                "using the rounding mode specified by RN.",
                "The result is placed into VSR[VRT+32] in quad-precision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Unsigned D oubleword to D ouble - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvuxddp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "360" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_UI64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32×TX+T].dword[0] := result",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the unsigned integer value in doubleword ",
                "element 0 of VSR[XB].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round Unsigned Doubleword to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvuxdsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "296" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_UI64(VSR[32×BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32×TX+T].dword[0] := result64",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the unsigned-integer value in doubleword ",
                "element 0 of VSR[XB].",
                "src is converted to floating-point format, and rounded ",
                "to single-precision using the rounding mode specified ",
                "by RN. ",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Convert with round Unsigned Quadword to Quad-Precision format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvuqqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "3" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_UI128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP128(0b0,FPSCR.RN,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(XX)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := inc_flag",
                "FPSCR.FI    := xx_flag"
            ],
            "body": [
                "Let src be the 128-bit unsigned integer value in ",
                "VSR[VRB+32].",
                "src is converted to an unbounded-precision ",
                "floating-point value and rounded to quad-precision ",
                "using the rounding mode specified by RN.",
                "The result is placed into VSR[VRT+32] in quad-precision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero D ouble-Precision t o Unsigned D oubleword format X",
            "form": "X2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpuxds",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "328" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[1] := result",
                "   VSR[32×TX+T].dword[2] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value ",
                "0x0000_0000_0000_0000 and VXCVI is set to 1. If src is ",
                "an SNaN, VXSNAN is also set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 264-1, the result is ",
                "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 0, the ",
                "result is 0x0000_0000_0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit unsigned-integer format, and if the result is ",
                "inexact (i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 72."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero D ouble-Precision t o Unsigned W ord format X",
            "form": "X2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpuxws",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "72" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].word[0] := result",
                "   VSR[32×TX+T].word[1] := result",
                "   VSR[32×TX+T].word[2] := 0x0000_0000",
                "   VSR[32×TX+T].word[3] := 0x0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value 0x0000_0000 and ",
                "VXCVI is set to 1. If src is an SNaN, VXSNAN is also set ",
                "to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 232-1, the result is ",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 0, the ",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit unsigned-integer format, and if the result is ",
                "inexact (i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 73."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Double-Precision t o Signed D oubleword format X",
            "form": "X2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpsxds",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "344" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[1] := result",
                "   VSR[32×TX+T].dword[2] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value ",
                "0x8000_0000_0000_0000 and VXCVI is set to 1. If src is ",
                "an SNaN, VXSNAN is also set to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 263-1, the result is ",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 263, the ",
                "result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "64-bit signed-integer format, and if the result is inexact ",
                "(i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 70.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Double-Precision to Signed Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvdpsxws",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "88" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].word[0] := result",
                "   VSR[32×TX+T].word[1] := result",
                "   VSR[32×TX+T].word[2] := 0x0000_0000",
                "   VSR[32×TX+T].word[3] := 0x0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src is a NaN, the result is the value 0x8000_0000 and ",
                "VXCVI is set to 1. If src is an SNaN, VXSNAN is also set ",
                "to 1.",
                "Otherwise, src is rounded to a floating-point integer ",
                "using the rounding mode Round Toward Zero.",
                "If the rounded value is greater than 231-1, the result is ",
                "0x7FFF_FFFF and VXCVI is set to 1.",
                "Otherwise, if the rounded value is less than 231, the ",
                "result is 0x8000_0000 and VXCVI is set to 1.",
                "Otherwise, the result is the rounded value converted to ",
                "32-bit signed-integer format, and if the result is inexact ",
                "(i.e., not equal to src), XX is set to 1.",
                "If a trap-enabled invalid operation exception occurs,",
                "Otherwise,",
                "See Table 71."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Signed Doubleword format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpsdz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "25" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN | src.class.SNaN then do",
                "   result := 0x8000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity then do",
                "   vxcvi_flag := 1",
                "   if src.sign = 0 then",
                "      result := 0x7FFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x8000_0000_0000_0000",
                "end",
                "else if src.class.Zero then",
                "   result := 0x0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +263-1) then do",
                "      result := 0x7FFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, -263) then do",
                "      result := 0x8000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0x8000_0000_0000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is +Infinity, the result is ",
                "0x7FFF_FFFF_FFFF_FFFF.",
                "Otherwise, if src is -Infinity, the result is ",
                "0x8000_0000_0000_0000.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in signed integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table70, “Actions for xscvdpsxds,” on page702."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Signed Quadword",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpsqz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "8" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign = 0 then",
                "      result := 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000_0000_0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +2127-1) then do",
                "      result := 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, -2127) then do",
                "      result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si128_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is -2127.",
                "Otherwise, if src is a Zero, the result is 0.",
                "Otherwise, if src is +Infinity, the result is 2127-1.",
                "Otherwise, if src is -Infinity, the result is -2127.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in signed integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table75, “Actions for xscvqpsqz,” on page714."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Signed Word format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpswz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "9" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0xFFFF_FFFF_8000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0x0000_0000_7FFF_FFFF",
                "   else",
                "      result := 0xFFFF_FFFF_8000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +231-1) then do",
                "      result := 0x0000_0000_7FFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, -231) then do",
                "      result := 0xFFFF_FFFF_8000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0xFFFF_FFFF_8000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is a +Infinity, the result is ",
                "0x0000_0000_7FFF_FFFF.",
                "Otherwise, if src is a -Infinity, the result is ",
                "0xFFFF_FFFF_8000_0000.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in signed integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table76, “Actions for xscvqpswz,” on page716."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Doubleword format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpudz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "17" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x0000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0xFFFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x0000_0000_0000_0000",
                "end",
                "else if src.class.Zero then result := 0x0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +264-1) then do",
                "      result := 0xFFFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, 0) then do",
                "      result := 0x0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := ui64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0x0000_0000_0000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is a positive Infinity, the result is ",
                "0xFFFF_FFFF_FFFF_FFFF.",
                "Otherwise, if src is a negative Infinity, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in unsigned integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table77, “Actions for xscvqpudz,” on page718."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpuqz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSypX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   else",
                "      result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +2128-1) then do",
                "      result := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, 0) then do",
                "      result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := si128_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0.",
                "Otherwise, if src is a Zero, the result is 0.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in unsigned ",
                "integer format.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table77, “Actions for xscvqpudz,” on page718."
            ]
        },
        {
            "description": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Word format",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscvqpuwz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "836" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "   result := 0x0000_0000",
                "   vxsnan_flag := src.class.SNaN",
                "   vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "   vxcvi_flag := 1",
                "   if src.sign=0 then",
                "      result := 0x0000_0000_FFFF_FFFF",
                "   else",
                "      result := 0x0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "   result := 0x0000_0000",
                "else do",
                "   rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "   if bfp_COMPARE_GT(rnd, +232-1) then do",
                "      result := 0x0000_0000_FFFF_FFFF",
                "      vxcvi_flag := 1",
                "   end",
                "   else if bfp_COMPARE_LT(rnd, bfp_ZERO) then do",
                "      result := 0x0000_0000_0000_0000",
                "      vxcvi_flag := 1",
                "   end",
                "   else do",
                "      result := ui64_CONVERT_FROM_BFP(rnd)",
                "      if xx_flag=1 then SetFX(FPSCR.XX)",
                "   end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32].dword[0] := result",
                "   VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN and VXCVI are set to 1.",
                "If src is a Quiet NaN or an Infinity, an Invalid Operation ",
                "exception occurs and VXCVI is set to 1.",
                "If src is a NaN, the result is 0x0000_0000_0000_0000.",
                "Otherwise, if src is a Zero, the result is ",
                "0x0000_0000_0000_0000.",
                "Otherwise, if src is a positive Infinity, the result is ",
                "0x0000_0000_FFFF_FFFF.",
                "Otherwise, do the following.",
                "The result is placed into doubleword element 0 of ",
                "VSR[VRT+32] in unsigned integer format.",
                "The contents of doubleword element 1 of VSR[VRT+32] ",
                "are set to 0.",
                "FPRF is set to undefined. FR is set to 0. FI is set to ",
                "indicate if the rounded result is inexact.",
                "If an Invalid Operation exception occurs, FR and FI are ",
                "set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified.",
                "See Table79, “Actions for xscvqpuwz,” on page722."
            ]
        },
        {
            "description": "VSX Scalar Copy Sign Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscpsgndp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "176" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32×AX+A].dword[0] & 0x8000_0000_0000_0000",
                "src2 := VSR[32×BX+B].dword[0] & 0x7FFF_FFFF_FFFF_FFFF",
                "VSR[32×TX+T].dword[0] := src1 | src2",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Bit 0 of VSR[XT] is set to the contents of bit 0 of ",
                "VSR[XA].",
                "Bits 1:63 of VSR[XT] are set to the contents of bits 1:63 ",
                "of VSR[XB].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Copy Sign Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xscpsgnqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "100" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[VRA+32] & 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "src2 := VSR[VRB+32] & 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "",
                "VSR[VRT+32] := src1 | src2"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quad-precision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quad-precision format.",
                "src2 is placed into VSR[VRT+32] with the sign of src1."
            ]
        },
        {
            "description": "VSX Scalar Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsdivdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "56" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v      := bfp_DIVIDE(src1,src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is divided by src2, producing a quotient having ",
                "unbounded range and precision.",
                "The quotient is normalized.",
                "See Actions for xsdivdp (p. 732).",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified, and FR and FI are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Divide Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsdivqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "548" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_DIVIDE(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & (zx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & (zx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1",
                "If src1 and src2 are Infinity values, an Invalid ",
                "Operation exception occurs and VXIDI is set to 1.",
                "If src1 and src2 are Zero values, an Invalid Operation ",
                "exception occurs and VXZDZ is set to 1.",
                "If src1 is a finite value and src2 is a Zero value, an ",
                "Zero Divide exception occurs and ZX is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 and src2 are Infinity values, or if ",
                "src1 and src2 are Zero values, the result is the default ",
                "Quiet NaN.",
                "Otherwise, if src1 is a non-zero value and src2 is a ",
                "Zero value, the result is an Infinity.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-disabled Zero Divide exception occurs, FR and ",
                "FI are set to 0.",
                "If a trap-enabled Invalid Operation exception or a ",
                "trap-enabled Zero Divide exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Divide Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsdivsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "24" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v        := bfp_DIVIDE(src1,src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is divided by src2, producing a quotient having ",
                "unbounded range and precision.",
                "The quotient is normalized.",
                "See Table82, “Actions for xsdivsp,” on page736.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified, and FR and FI are set to 0.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Extract Exponent Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsxexpdp",
                    "regs": [ "RT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "347" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src ~ VSR[32×BX+B].dword[0]",
                "",
                "GPR[RT] ~ (src >> 52) & 0x0000_0000_0000_07FF"
            ],
            "body": [
                "Let XB be the sum 32×BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The value of the exponent field in src is placed into ",
                "GPR[RT] in unsigned integer format."
            ]
        },
        {
            "description": "VSX Scalar Extract Exponent Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsxexpqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "804" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[VRB+32]",
                "VSR[VRT+32].dword[0] := EXTZ64(src.bit[1:15]), 64)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "The contents of the exponent field of src (bits 1:15) are ",
                "zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "VSX Scalar Extract Significand Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsxsigdp",
                    "regs": [ "RT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "347" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "exponent ~ VSR[32×BX+B].bit[1:11]",
                "fraction ~ EXTZ64(VSR[32×BX+B].bit[12:63])",
                "",
                "if (exponent != 0) & (exponent != 2047) then",
                "   significand ~ fraction | 0x0010_0000_0000_0000",
                "else",
                "   significand ~ fraction",
                "",
                "GPR[RT] ~ significand"
            ],
            "body": [
                "Let XB be the sum 32×BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The significand of src is placed into GPR[RT] in ",
                "unsigned integer format. If src is a normal value, the ",
                "implicit leading bit is set to 1."
            ]
        },
        {
            "description": "VSX Scalar Extract Significand Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsxsigqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "18" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "804" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src      := VSR[VRB+32]",
                "exponent := EXTZ(src.bit[1:15])",
                "fraction := EXTZ128(src.bit[16:127])",
                "",
                "if (exponent != 0) &  (exponent != 32767) then",
                "   VSR[VRT+32] := fraction |",
                "                    0x0001_0000_0000_0000_0000_0000_0000_0000",
                "else",
                "   VSR[VRT+32] := fraction"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "The significand of src is placed into VSR[VRT+32].",
                "If the value of the exponent field of src is equal to ",
                "0b000_0000_0000_0000 (i.e., Zero or Denormal value) or ",
                "0b111_1111_1111_1111 (i.e., Infinity or NaN), 0b0 is ",
                "placed into bit 15 of VSR[VRT+32]. Otherwise (i.e., ",
                "Normal value), 0b1 is placed into bit 15 of VSR[VRT+32]. ",
                "The contents of bits 0:14 of VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "VSX Scalar Insert Exponent Double - Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsiexpdp",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "918" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 ~ GPR[RA]",
                "src2 ~ GPR[RB]",
                "",
                "VSR[32×TX+T].dword[0].bit[0]     ~ src1.bit[0]",
                "VSR[32×TX+T].dword[0].bit[1:11]  ~ src2.bit[53:63]",
                "VSR[32×TX+T].dword[0].bit[12:63] ~ src1.bit[12:63]",
                "VSR[32×TX+T].dword[1]            ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "Let src1 be the unsigned integer value in GPR[RA].",
                "The contents of bit 0 of src1 are placed into bit 0 of ",
                "VSR[XT].",
                "The contents of bits 53:63 of src2 are placed into bits ",
                "1:11 of VSR[XT].",
                "The contents of bits 12:63 of src1 are placed into bits ",
                "12:63 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Insert Exponent Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsiexpqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "868" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32].bit[0]      := VSR[VRA+32].bit[0]",
                "VSR[VRT+32].bit[1:15]   := VSR[VRB+32].dword[0].bit[49:63]",
                "VSR[VRT+32].bit[16:127] := VSR[VRA+32].bit[16:127]"
            ],
            "body": [
                "The contents of bit 0 of VSR[VRA+32] are placed into bit ",
                "0 of VSR[VRT+32].",
                "The contents of bit 49:63 of doubleword element 0 of ",
                "VSR[VRB+32] are placed into bits 1:15 of VSR[VRT+32].",
                "The contents of bit 16:127 of VSR[VRA+32] are placed ",
                "into bits 16:127 of VSR[VRT+32]."
            ]
        },
        {
            "description": "VSX Scalar Maximum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "160" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32×AX+A].dword[0]",
                "src2   := VSR[32×BX+B].dword[0]",
                "result := bfp64_MAXIMUM(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src1 is greater than src2, src1 is placed into ",
                "doubleword element 0 of VSR[XT]. Otherwise, src2 is ",
                "placed into doubleword element 0 of VSR[XT] in ",
                "double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "The maximum of +0 and -0 is +0. The maximum of a ",
                "QNaN and any value is that value. The maximum of ",
                "any value and an SNaN is that SNaN converted to a ",
                "QNaN.",
                "FPRF, FR and FI are not modified.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] is not modified.",
                "See Table 86."
            ]
        },
        {
            "description": "VSX Scalar Maximum Type-C Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxcdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "128" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32×AX+A].dword[0]",
                "src2   := VSR[32×BX+B].dword[0]",
                "result := bfp64_MAXIMUM_TYPE_C(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is greater than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Maximum Type-C Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxcqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "676" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is greater than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of VSR[VRT+32] are set to the value ",
                "result.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Maximum Type-J Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaxjdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "144" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32×AX+A].dword[0]",
                "src2   := VSR[32×BX+B].dword[0]",
                "result := bfp64_MAXIMUM_TYPE_J(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If src1 is a NaN, result is src1.",
                "Otherwise, if src2 is a NaN, result is src2.",
                "Otherwise, if src1 is a Zero and src2 is a Zero and ",
                "either src1 or src2 is a +Zero, the result is +Zero.",
                "Otherwise, if src1 is a -Zero and src2 is a -Zero, the ",
                "result is -Zero.",
                "Otherwise, if src1 is greater than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Minimum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmindp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "168" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32×AX+A].dword[0]",
                "src2   := VSR[32×BX+B].dword[0]",
                "result := bfp64_MINIMUM(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "If src1 is less than src2, src1 is placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "Otherwise, src2 is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "The minimum of +0 and –0 is –0. The minimum of a ",
                "QNaN and any value is that value. The minimum of ",
                "any value and an SNaN is that SNaN converted to a ",
                "QNaN.",
                "FPRF, FR and FI are not modified.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] is not modified.",
                "See Table 90.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Minimum Type-C Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmincdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "136" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32×AX+A].dword[0]",
                "src2   := VSR[32×BX+B].dword[0]",
                "result := bfp64_MINIMUM_TYPE_C(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is less than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Minimum Type-C Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmincqp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "740" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [
                "Let src1 be the quad-precision floating-point value in ",
                "VSR[VRA+32].",
                "Let src2 be the quad-precision floating-point value in ",
                "VSR[VRB+32].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If either src1 or src2 is a NaN, result is src2.",
                "Otherwise, if src1 is less than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of VSR[VRT+32] are set to the value ",
                "result.",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32] ",
                "is not modified."
            ]
        },
        {
            "description": "VSX Scalar Minimum Type-J Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsminjdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "152" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32×AX+A].dword[0]",
                "src2   := VSR[32×BX+B].dword[0]",
                "result := bfp64_MINIMUM_TYPE_J(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword 0 of VSR[XB].",
                "If src1 or src2 is a SNaN, an Invalid Operation ",
                "exception occurs.",
                "If src1 is a NaN, result is src1.",
                "Otherwise, if src2 is a NaN, result is src2.",
                "Otherwise, if src1 is a Zero and src2 is a Zero and ",
                "either src1 or src2 is a -Zero, the result is -Zero.",
                "Otherwise, if src1 is a +Zero and src2 is a +Zero, the ",
                "result is +Zero.",
                "Otherwise, if src1 is less than src2, result is src1.",
                "Otherwise, result is src2.",
                "The contents of doubleword 0 of VSR[XT] are set to the ",
                "value result.",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is ",
                "not modified.",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Scalar Multiply - Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Multiply - Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "9" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsmaddasp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsmaddmsp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For xsmaddasp, do the following.",
                "For xsmaddmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table84, “Actions for xsmadd(a|m)sp,” ",
                "on page744.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table84, “Actions for xsmadd(a|m)sp,” ",
                "on page744.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Multiply - Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "17" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Multiply - Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "25" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsmsubasp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsmsubmsp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For xsmsubasp, do the following.",
                "For xsmsubmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table95, “Actions for xsmsub(a|m)sp”.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision. ",
                "The result, having unbounded range and precision, is ",
                "normalized. ",
                "See part 2 of Table95, “Actions for xsmsub(a|m)sp”.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmuldp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "48" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v      := bfp_MULTIPLY(src1,src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is multiplied by src2, producing a product ",
                "having unbounded range and precision.",
                "The product is normalized.",
                "See Table 97.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Multiply Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmulqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "36" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1.",
                "If src1 is an Infinity value and src2 is a Zero value, or if ",
                "src1 is a Zero value and src2 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 is an Infinity value and src2 is a Zero ",
                "value, or if src1 is a Zero value and src2 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmulsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "16" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v        := bfp_MULTIPLY(src1,src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src1 is multiplied by src2, producing a product ",
                "having unbounded range and precision.",
                "The product is normalized.",
                "See Table99, “Actions for xsmulsp,” on page776.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Multiply-Add Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "388" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1  then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "if ox_flag=1     then SetFX(FPSCR.OX)",
                "if ux_flag=1     then SetFX(FPSCR.UX)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "ex_flag  := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having opposite signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having opposite signs, the result is ",
                "the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "33" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmaddmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "41" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsmaddadp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsmaddmdp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "For xsmaddadp, do the following.",
                "For xsmaddmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 83.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table 83.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply-Subtract Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "420" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having same signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having same signs, the result is the ",
                "default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "49" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsmsubmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "57" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsmsubadp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsmsubmdp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For xsmsubadp, do the following.",
                "For xsmsubmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 94.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision.",
                "The result, having unbounded range and precision, is ",
                "normalized.",
                "See part 2 of Table 94.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is ",
                "set to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                ""
            ]
        },
        {
            "description": "VSX Scalar Negate Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnegdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "377" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32×BX+B].dword[0]",
                "VSR[32×TX+T].dword[0] := bfp64_NEGATE(src)",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of doubleword element 0 of VSR[XB], with ",
                "bit 0 complemented, is placed into doubleword ",
                "element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Negate Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnegqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "16" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "804" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATE(VSR[VRB+32])"
            ],
            "body": [
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "src is negated and placed into VSR[VRT+32] in ",
                "quadprecision format."
            ]
        },
        {
            "description": "VSX Scalar Negative Absolute Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnabsdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "361" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32×BX+B].dword[0]",
                "VSR[32×TX+T].dword[0] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of doubleword element 0 of VSR[XB], with ",
                "bit 0 set to 1, is placed into doubleword element 0 of ",
                "VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. "
            ]
        },
        {
            "description": "VSX Scalar Negative Absolute Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnabsqp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "8" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "804" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATIVE_ABSOLUTE(VSR[VRB+32])"
            ],
            "body": [
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "The negative absolute value of src is placed into ",
                "VSR[VRT+32] in quadprecision format."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply - Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "129" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Negative Multiply - Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "137" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsnmaddasp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsnmaddmsp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd      := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN, v))",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For xsnmaddasp, do the following.",
                "For xsnmaddmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table102, “Actions for xsnmadd(a|m)sp,” ",
                "on page786.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table102, “Actions for xsnmadd(a|m)sp,” ",
                "on page786.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, “Scalar Floating-Point Final Result with ",
                "Negation,” on page782."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply - Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "145" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Negative Multiply - Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "153" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsnmsubasp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsnmsubmsp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd      := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN, v))",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For xsnmsubasp, do the following.",
                "For xsnmsubmsp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table105, “Actions for xsnmsub(a|m)sp,” ",
                "on page795.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table105, “Actions for xsnmsub(a|m)sp,” ",
                "on page795.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, “Scalar Floating-Point Final Result with ",
                "Negation,” on page782."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Add Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "452" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v))",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having opposite signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having opposite signs, the result is ",
                "the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is negated and placed into VSR[VRT+32] in ",
                "quadprecision format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "161" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmaddmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "169" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsnmaddadp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsnmaddmdp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v))",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "For xsnmaddadp, do the following.",
                "For xsnmaddmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 100.",
                "src2 is added to the product, producing a sum ",
                "having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table 100.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, “Scalar Floating-Point Final Result with ",
                "Negation,” on page782."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Subtract Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "484" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v))",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "ex_flag  := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRT+32] ",
                "represented in quadprecision format.",
                "Let src3 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1, src2, or src3 is a Signalling NaN, an ",
                "Invalid Operation exception occurs and VXSNAN is set to ",
                "1.",
                "If src1 is an Infinity value and src3 is a Zero value, or if ",
                "src1 is a Zero value and src3 is an Infinity value, an ",
                "Invalid Operation exception occurs and VXIMZ is set to ",
                "1.",
                "If src2 and the product of src1 and src3 are Infinity ",
                "values having same signs, an Invalid Operation ",
                "exception occurs and VXISI is set to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src3 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src3.",
                "Otherwise, if src3 is a Quiet NaN, the result is src3.",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero ",
                "value, or if src1 is a Zero value and src3 is an Infinity ",
                "value, the result is the default Quiet NaN.",
                "Otherwise, if the product of src1 and src3, and src2 ",
                "are Infinity values having same signs, the result is the ",
                "default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is negated and placed into VSR[VRT+32] in ",
                "quadprecision format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FR and FI are set to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "177" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Scalar Negative Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsnmsubmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "185" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if “xsnmsubadp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "end",
                "if “xsnmsubmdp” then do",
                "   src1 := bfp_CONVERT_FROM_BFP128(VSR[32×AX+A].dword[0])",
                "   src2 := bfp_CONVERT_FROM_BFP128(VSR[32×BX+B].dword[0])",
                "   src3 := bfp_CONVERT_FROM_BFP128(VSR[32×TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v))",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "For xsnmsubadp, do the following.",
                "For xsnmsubmdp, do the following.",
                "src1 is multiplied by src3, producing a product ",
                "having unbounded range and precision.",
                "See part 1 of Table 104.",
                "src2 is negated and added to the product, producing ",
                "a sum having unbounded range and precision.",
                "The sum is normalized.",
                "See part 2 of Table 104.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is negated and placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table101, “Scalar Floating-Point Final Result with ",
                "Negation,” on page782."
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsredp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "90" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v      := bfp_RECIPROCAL_ESTIMATE(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A double-precision floating-point estimate of the ",
                "reciprocal of src is placed into doubleword element 0 ",
                "of VSR[XT] in double-precision format.",
                "Unless the reciprocal of src would be a zero, an ",
                "infinity, or a QNaN, the estimate has a relative error in ",
                "precision no greater than one part in 16384 of the ",
                "reciprocal of src. That is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to an undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsresp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "26" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v        := bfp_RECIPROCAL_ESTIMATE(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if 0bU then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A single-precision floating-point estimate of the ",
                "reciprocal of src is placed into doubleword element 0 ",
                "of VSR[XT] in double-precision format.",
                "Unless the reciprocal of src would be a zero, an ",
                "infinity, the result of a trap-disabled Overflow ",
                "exception, or a QNaN, the estimate has a relative error ",
                "in precision no greater than one part in 16384 of the ",
                "reciprocal of src. That is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to an ",
                "undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Square Root Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrsqrtedp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "74" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v      := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A double-precision floating-point  estimate of the ",
                "reciprocal square root of src is placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format.",
                "Unless the reciprocal of the square root of src would ",
                "be a zero, an infinity, or a QNaN, the estimate has a ",
                "relative error in precision no greater than one part in ",
                "16384 of the reciprocal of the square root of src. That ",
                "is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to an undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Reciprocal Square Root Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrsqrtesp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "10" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v        := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if 0bU then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := 0bU",
                "   FPSCR.FI   := 0bU",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "A single-precision floating-point  estimate of the ",
                "reciprocal square root of src is placed into doubleword ",
                "element 0 of VSR[XT] in double-precision format.",
                "Unless the reciprocal of the square root of src would ",
                "be a zero, an infinity, or a QNaN, the estimate has a ",
                "relative error in precision no greater than one part in ",
                "16384 of the reciprocal of the square root of src. That ",
                "is,",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to an ",
                "undefined value. FI is set to an undefined value.",
                "If a trap-enabled invalid operation exception or a ",
                "trap-enabled zero divide exception occurs, VSR[XT] and ",
                "FPRF are not modified.",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Scalar Round Quad-Precision to Double-Extended - Precision",
            "form": "Z23-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrqpxp",
                    "regs": [ "R,VRT,VRB,RMC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "R", "size": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "37" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if R=0 then do",
                "   if RMC=0b00 then           // Round to Nearest Away",
                "      rmode := 0b100",
                "   if RMC=0b11 then do",
                "      if FPSCR.RN=0b00 then   // Round to Nearest Even",
                "         rmode := 0b000",
                "      if FPSCR.RN=0b01 then   // Round towards Zero",
                "         rmode := 0b001",
                "      if FPSCR.RN=0b10 then   // Round towards +Infinity",
                "         rmode := 0b010",
                "      if FPSCR.RN=0b11 then   // Round towards -Infinity",
                "         rmode := 0b011",
                "   end",
                "end",
                "else do // R=1",
                "   if RMC=0b00 then           // Round to Nearest Even",
                "      rmode := 0b000",
                "   if RMC=0b01 then           // Round towards Zero",
                "      rmode := 0b001",
                "   if RMC=0b10 then           // Round towards +Infinity",
                "      rmode := 0b010",
                "   if RMC=0b11 then           // Round towards -Infinity",
                "      rmode := 0b011",
                "end",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP80(rmode,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vxsnan_flag=0) & inc_flag",
                "FPSCR.FI := (vxsnan_flag=0) & xx_flag"
            ],
            "body": [
                "Let R and RMC specify the rounding mode as follows.",
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs, VXSNAN is set to 1, and the result is ",
                "the Quiet NaN corresponding to the Signalling NaN, ",
                "with the significand truncated to ",
                "double-extended-precision.",
                "Otherwise, if src is a Quiet NaN, then the result is src ",
                "with the significand truncated to ",
                "double-extended-precision.",
                "Otherwise, if src is an Infinity or a Zero, the result is ",
                "src.",
                "Otherwise, src is rounded to double-extended ",
                "precision (i.e., 15-bit exponent range and 64-bit ",
                "significand precision) using the specified rounding ",
                "mode.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value, and FR and FI are set ",
                "to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer exact using Current rounding mode",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpic",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "107" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "",
                "if FPSCR.RN=0b00 then",
                "   rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "if FPSCR.RN=0b01 then",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "if FPSCR.RN=0b10 then",
                "   rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "if FPSCR.RN=0b11 then",
                "   rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "specified by RN.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round to Nearest Away",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpi",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "73" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round to Nearest Away.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round toward +Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpip",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "105" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round toward +Infinity.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round toward -Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpim",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "121" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round toward Infinity.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Double-Precision Integer using round toward Zero",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrdpiz",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "89" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to an integer using the rounding mode ",
                "Round toward Zero.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to 0. FI is set to 0.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0."
            ]
        },
        {
            "description": "VSX Scalar Round to Quad-Precision Integer [ with Inexact ]",
            "form": "Z23-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrqpi",
                    "regs": [ "R,VRT,VRB,RMC", "(", "EX=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "4" },
                { "name": "R", "size": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "RMC", "size": "2" },
                { "name": "opcode", "size": "8", "value": "5" },
                { "name": "EX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if R=0 then do",
                "   if RMC=0b00 then           // Round to Nearest Away",
                "      rmode := 0b100",
                "   if RMC=0b11 then do",
                "      if FPSCR.RN=0b00 then   // Round to Nearest Even",
                "         rmode := 0b000",
                "      if FPSCR.RN=0b01 then   // Round towards Zero",
                "         rmode := 0b001",
                "      if FPSCR.RN=0b10 then   // Round towards +Infinity",
                "         rmode := 0b010",
                "      if FPSCR.RN=0b11 then   // Round towards -Infinity",
                "         rmode := 0b011",
                "   end",
                "end",
                "else do // R=1",
                "   if RMC=0b00 then           // Round to Nearest Even",
                "      rmode := 0b000",
                "   if RMC=0b01 then           // Round towards Zero",
                "      rmode := 0b001",
                "   if RMC=0b10 then           // Round towards +Infinity",
                "      rmode := 0b010",
                "   if RMC=0b11 then           // Round towards -Infinity",
                "      rmode := 0b011",
                "end",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.SNaN then do",
                "   result := bfp128_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "   vxsnan_flag := 1",
                "end",
                "else if src.class.QNaN     |",
                "        src.class.Infinity |",
                "        src.class.Zero  then",
                "   result := bfp128_CONVERT_FROM_BFP(src)",
                "else do",
                "   rnd    := bfp_ROUND_TO_INTEGER(rmode, src)",
                "   result := bfp128_CONVERT_FROM_BFP(rnd)",
                "end",
                "",
                "if vxsnan_flag=1  then SetFX(FPSCR.VXSNAN)",
                "if xx_flag & EX then SetFX(FPSCR.XX)",
                "",
                "vex_flag  := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := EX & (vxsnan_flag=0) & inc_flag",
                "FPSCR.FI := EX & (vxsnan_flag=0) & xx_flag"
            ],
            "body": [
                "Let R and RMC specify the rounding mode as follows.",
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs, VXSNAN is set to 1, and the result is ",
                "the Quiet NaN corresponding to the Signalling NaN.",
                "Otherwise, if src is a Quiet NaN, an Infinity, or a Zero, ",
                "then the result is src.",
                "Otherwise, src is rounded to an integer using the ",
                "rounding mode rmode.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result.",
                "For xsrqpi, FR is set to 0, FI is set to 0, and XX is not ",
                "set by an Inexact exception.",
                "For xsrqpix, FR is set to indicate if the result was ",
                "incremented when rounded, FI is set to indicate the ",
                "result is inexact, and XX is set by an Inexact exception.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified."
            ]
        },
        {
            "description": "VSX Scalar Round to Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xsrsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "281" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src is rounded to single-precision using the rounding ",
                "mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified."
            ]
        },
        {
            "description": "VSX Scalar Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xssqrtdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "75" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v      := bfp_SQUARE_ROOT(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The unbounded-precision square root of src is ",
                "produced.",
                "See Table 107.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN. ",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Square Root Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xssqrtqp",
                    "regs": [ "VRT,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "27" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "804" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_SQUARE_ROOT(src)",
                "rnd    := bfp_ROUND_TO_BFP128(RO,FPSCR.RN,v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If src is a Signalling NaN, an Invalid Operation ",
                "exception occurs and VXSNAN is set to 1.",
                "If src is a negative, non-zero value, an Invalid ",
                "Operation exception occurs and VXSQRT is set to 1.",
                "If src is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src.",
                "Otherwise, if src is a Quiet NaN, the result is src.",
                "Otherwise, if src is a negative value, the result is the ",
                "default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value, and FR and FI are set ",
                "to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Square Root Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xssqrtsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "11" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v        := bfp_SQUARE_ROOT(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "The unbounded-precision square root of src is ",
                "produced.",
                "See Table 107.",
                "The intermediate result is rounded to single-precision ",
                "using the rounding mode specified by RN. ",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT] in double-precision format.",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Subtract Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xssubdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "40" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v      := bfp_ADD(src1,bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is negated and added to src1, producing a sum ",
                "having unbounded range and precision.",
                "See Table 110.",
                "The sum is normalized.",
                "The intermediate result is rounded to double-precision ",
                "using the rounding mode specified by RN.",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT]. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the result was incremented when ",
                "rounded. FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Subtract Quad-Precision [ using round to Odd ]",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xssubqp",
                    "regs": [ "VRT,VRA,VRB", "(", "RO=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "516" },
                { "name": "RO", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_ADD(src1, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP128(RO,FPSCR.RN,v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[VRT+32] := result",
                "   FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "Let src1 be the floating-point value in VSR[VRA+32] ",
                "represented in quadprecision format.",
                "Let src2 be the floating-point value in VSR[VRB+32] ",
                "represented in quadprecision format.",
                "If either src1 or src2 is a Signalling NaN, an Invalid ",
                "Operation exception occurs and VXSNAN is set to 1.",
                "If src1 and src2 are Infinity values having same signs, ",
                "an Invalid Operation exception occurs and VXISI is set ",
                "to 1.",
                "If src1 is a Signalling NaN, the result is the Quiet NaN ",
                "corresponding to src1.",
                "Otherwise, if src1 is a Quiet NaN, the result is src1.",
                "Otherwise, if src2 is a Signalling NaN, the result is the ",
                "Quiet NaN corresponding to src2.",
                "Otherwise, if src2 is a Quiet NaN, the result is src2.",
                "Otherwise, if src1 and src2 are Infinity values having ",
                "same signs, the result is the default Quiet NaN.",
                "Otherwise, do the following.",
                "The result is placed into VSR[VRT+32] in quadprecision ",
                "format.",
                "FPRF is set to the class and sign of the result. FR is set ",
                "to indicate if the rounded result was incremented. FI is ",
                "set to indicate the result is inexact.",
                "If a trap-disabled Invalid Operation exception occurs, ",
                "FPRF is set to an undefined value, and FR and FI are set ",
                "to 0.",
                "If a trap-enabled Invalid Operation exception occurs, ",
                "VSR[VRT+32] and FPRF are not modified, and FR and FI ",
                "are set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676."
            ]
        },
        {
            "description": "VSX Scalar Subtract Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xssubsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "8" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[0])",
                "v        := bfp_ADD(src1,bfp_NEGATE(src2))",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "   VSR[32×TX+T].dword[0] := result64",
                "   VSR[32×TX+T].dword[1] := 0x0000_0000_0000_0000",
                "   FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "   FPSCR.FR   := inc_flag",
                "   FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "   FPSCR.FR   := 0b0",
                "   FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "src2 is negated and added to src1, producing the ",
                "sum, v, having unbounded range and precision. ",
                "See Table112, “Actions for xssubsp,” on page826.",
                "v is normalized and rounded to single-precision ",
                "using the rounding mode specified by RN. ",
                "See Table62, “Scalar Floating-Point Intermediate ",
                "Result Handling,” on page675.",
                "The result is placed into doubleword element 0 of ",
                "VSR[XT]. ",
                "The contents of doubleword element 1 of VSR[XT] are ",
                "set to 0. ",
                "FPRF is set to the class and sign of the result as ",
                "represented in single-precision format. FR is set to ",
                "indicate if the result was incremented when rounded. ",
                "FI is set to indicate the result is inexact.",
                "If a trap-enabled invalid operation exception occurs, ",
                "VSR[XT] and FPRF are not modified, and FR and FI are ",
                "set to 0.",
                "See Table63, “VSX Scalar Floating-Point Final ",
                "Result,” on page676.",
                " "
            ]
        },
        {
            "description": "VSX Scalar Test Data Class Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xststdcdp",
                    "regs": [ "BF,XB,DCMX" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "DCMX", "size": "7" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "362" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            ~ VSR[32×BX+B].dword[0]",
                "exponent       ~ src.bit[1:11]",
                "fraction       ~ src.bit[12:63]",
                "",
                "class.Infinity ~ (exponent = 0x7FF) & (fraction  = 0)",
                "class.NaN      ~ (exponent = 0x7FF) & (fraction != 0)",
                "class.Zero     ~ (exponent = 0x000) & (fraction  = 0)",
                "class.Denormal ~ (exponent = 0x000) & (fraction != 0)",
                "",
                "match          ~ (DCMX.bit[0] & class.NaN)              |",
                "                (DCMX.bit[1] & class.Infinity & !sign) |",
                "                (DCMX.bit[2] & class.Infinity &  sign) |",
                "                (DCMX.bit[3] & class.Zero     & !sign) |",
                "                (DCMX.bit[4] & class.Zero     &  sign) |",
                "                (DCMX.bit[5] & class.Denormal & !sign) |",
                "                (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "CR.bit[4×BF+32] ~ FPSCR.FL ~ src.sign",
                "CR.bit[4×BF+33] ~ FPSCR.FG ~ 0b0",
                "CR.bit[4×BF+34] ~ FPSCR.FE ~ match",
                "CR.bit[4×BF+35] ~ FPSCR.FU ~ 0b0"
            ],
            "body": [
                "Let XB be the sum 32×BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign ",
                "bit of src.",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate ",
                "whether the data class of src, as represented in ",
                "double-precision format, matches any of the data ",
                "classes specified by DCMX (Data Class Mask). ",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0."
            ]
        },
        {
            "description": "VSX Scalar Test Data Class Quad-Precision",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xststdcqp",
                    "regs": [ "BF,VRB,DCMX" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "63" },
                { "name": "BF", "size": "3" },
                { "name": "DCMX", "size": "7" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "708" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            := VSR[VRB+32]",
                "exponent       := src.bit[1:15]",
                "fraction       := src.bit[16:127]",
                "",
                "class.Infinity := (exponent = 0x7FFF) & (fraction  = 0)",
                "class.NaN      := (exponent = 0x7FFF) & (fraction != 0)",
                "class.Zero     := (exponent = 0x0000) & (fraction  = 0)",
                "class.Denormal := (exponent = 0x0000) & (fraction != 0)",
                "",
                "match          := (DCMX.bit[0] & class.NaN)              |",
                "                (DCMX.bit[1] & class.Infinity & !sign) |",
                "                (DCMX.bit[2] & class.Infinity &  sign) |",
                "                (DCMX.bit[3] & class.Zero     & !sign) |",
                "                (DCMX.bit[4] & class.Zero     &  sign) |",
                "                (DCMX.bit[5] & class.Denormal & !sign) |",
                "                (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "CR.bit[4×BF+32] ~ FPSCR.FL ~ src.sign",
                "CR.bit[4×BF+33] ~ FPSCR.FG ~ 0b0",
                "CR.bit[4×BF+34] ~ FPSCR.FE ~ match",
                "CR.bit[4×BF+35] ~ FPSCR.FU ~ 0b0"
            ],
            "body": [
                "Let src be the quadprecision floating-point value in ",
                "VSR[VRB+32].",
                "Let the DCMX (Data Class Mask) field specify one or ",
                "more of the 7 possible data classes, where each bit ",
                "corresponds to a specific data class.",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign ",
                "of src.",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate ",
                "whether the data class of src, as represented in ",
                "quadprecision format, matches any of the data ",
                "classes specified by DCM.",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0."
            ]
        },
        {
            "description": "VSX Scalar Test Data Class Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xststdcsp",
                    "regs": [ "BF,XB,DCMX" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "DCMX", "size": "7" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "298" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            ~ VSR[32×BX+B].dword[0]",
                "exponent       ~ src.bit[1:11]",
                "fraction       ~ src.bit[12:63]",
                "",
                "class.Infinity ~ (exponent = 0x7FF) & (fraction  = 0)",
                "class.NaN      ~ (exponent = 0x7FF) & (fraction != 0)",
                "class.Zero     ~ (exponent = 0x000) & (fraction  = 0)",
                "class.Denormal ~ (exponent = 0x000) & (fraction != 0) |",
                "                (exponent > 0x000) & (exponent < 0x381)",
                "",
                "match          ~ (DCMX.bit[0] & class.NaN)              |",
                "                (DCMX.bit[1] & class.Infinity & !sign) |",
                "                (DCMX.bit[2] & class.Infinity &  sign) |",
                "                (DCMX.bit[3] & class.Zero     & !sign) |",
                "                (DCMX.bit[4] & class.Zero     &  sign) |",
                "                (DCMX.bit[5] & class.Denormal & !sign) |",
                "                (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "not_SP_value   ~ (src != Convert_SPtoDP(Convert_DPtoSP(src)))",
                "",
                "CR.bit[4×BF]   ~ FPSCR.FL ~ src.sign",
                "CR.bit[4×BF+1] ~ FPSCR.FG ~ 0b0",
                "CR.bit[4×BF+2] ~ FPSCR.FE ~ match",
                "CR.bit[4×BF+3] ~ FPSCR.FU ~ not_SP_value"
            ],
            "body": [
                "Let XB be the sum 32×BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign ",
                "bit of src.",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate ",
                "whether the data class of src, as represented in ",
                "single-precision format, matches any of the data ",
                "classes specified by DCMX (Data Class Mask).",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to indicate if ",
                "src is not representable in single-precision format."
            ]
        },
        {
            "description": "VSX Scalar Test for software Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xstdivdp",
                    "regs": [ "BF,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "61" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1    ~ VSR[32×AX+A].dword[0]",
                "src2    ~ VSR[32×BX+B].dword[0]",
                "e_a     := src1.bit[1:11] - 1023",
                "e_b     := src2.bit[1:11] - 1023",
                "fe_flag := IsNaN(src1) | IsInf(src1) |",
                "           IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "           ( e_b <= -1022 ) |",
                "           ( e_b >=  1021 ) |",
                "           ( !IsZero(src1) & ( (e_a - e_b) >=  1023 ) ) |",
                "           ( !IsZero(src1) & ( (e_a - e_b) <= -1021 ) ) |",
                "           ( !IsZero(src1) & ( e_a <= -970 ) )",
                "fg_flag := IsInf(src1) | IsInf(src2) |",
                "           IsZero(src2) | IsDen(src2)",
                "fl_flag := xsredp_error() <= 2-14",
                "CR[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "Let src1 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XA].",
                "Let src2 be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Let e_a be the unbiased exponent of src1.",
                "fe_flag is set to 1 for any of the following conditions.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 for any of the following conditions.",
                "Otherwise fg_flag is set to 0.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Scalar Test for software Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xstsqrtdp",
                    "regs": [ "BF,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "106" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src     ~ VSR[32×BX+B].dword[0]",
                "e_b     := src.bit[1:11] - 1023",
                "fe_flag := IsNaN(src) | IsInf(src) | IsZero(src) |",
                "           IsNeg(src) | ( e_b <= -970 )",
                "fg_flag := IsInf(src) | IsZero(src) | IsDen(src)",
                "fl_flag := xsrsqrtedp_error() <= 2-14",
                "",
                "CR.field[BF] := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XB be the value 32×BX + B.",
                "Let src be the double-precision floating-point value in ",
                "doubleword element 0 of VSR[XB].",
                "Let e_b be the unbiased exponent of src.",
                "fe_flag is set to 1 for any of the following conditions.",
                "Otherwise fe_flag is set to 0.",
                "fg_flag is set to 1 for any of the following conditions.",
                "Otherwise fg_flag is set to 0.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Set Accumulator to Zero",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxsetaccz",
                    "regs": [ "AT" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "opcode", "size": "5", "value": "3" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "10", "value": "177" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ACC[AT][0] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][1] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][2] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][3] := 0x0000_0000_0000_0000_0000_0000_0000_0000"
            ],
            "body": [
                "For each integer value i from 0 to 3, the contents of ",
                "row i of ACC[AT] are set to 0."
            ]
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "19" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2nn",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "210" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2np",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "82" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2pn",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "146" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf16ger2pp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "18" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "75" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2pp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "107" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2s",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "43" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi16ger2spp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "42" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf32ger",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "27" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gernn",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "218" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gernp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "90" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gerpn",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "154" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf32gerpp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "26" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 4-bit Signed Integer GER ( rank-8 update )",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi4ger8",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "35" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 4-bit Signed Integer GER ( rank-8 update ) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi4ger8pp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "34" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update )",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf64ger",
                    "regs": [ "AT,XAp,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "59" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gernn",
                    "regs": [ "AT,XAp,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "250" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gernp",
                    "regs": [ "AT,XAp,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "122" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gerpn",
                    "regs": [ "AT,XAp,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "186" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 64-bit Floating-Point GER ( rank-1 update ) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvf64gerpp",
                    "regs": [ "AT,XAp,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "Ap", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "58" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi8ger4",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "3" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi8ger4pp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "2" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturate Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvi8ger4spp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "99" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Absolute Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvabsdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "473" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[32×BX+B].dword[i]",
                "   VSR[32×TX+T].dword[i] := bfp64_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Absolute Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvabssp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "409" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[32×BX+B].word[i]",
                "   VSR[32×TX+T].word[i] := bfp32_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Add Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvadddp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "96" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v    := bfp_ADD(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Add Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvaddsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "64" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   v    := bfp_ADD(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Byte",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvb",
                    "regs": [ "XT,XA,XB,XC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "18" },
                { "name": "opcode", "size": "6", "value": "33" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 15",
                "   if VSR[32×CX+C].byte[i].bit[0]=0 then",
                "      VSR[32×TX+T].byte[i] := VSR[32*AX+A].byte[i]",
                "   else",
                "      VSR[32×TX+T].byte[i] := VSR[32*BX+B].byte[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Doubleword",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvd",
                    "regs": [ "XT,XA,XB,XC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "18" },
                { "name": "opcode", "size": "6", "value": "33" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 1",
                "   if VSR[32×CX+C].dword[i].bit[0]=0 then",
                "      VSR[32×TX+T].dword[i] := VSR[32×AX+A].dword[i]",
                "   else",
                "      VSR[32×TX+T].dword[i] := VSR[32×BX+B].dword[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Halfword",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvh",
                    "regs": [ "XT,XA,XB,XC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "18" },
                { "name": "opcode", "size": "6", "value": "33" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 7",
                "   if VSR[32×CX+C].hword[i].bit[0]=0 then",
                "      VSR[32×TX+T].hword[i] := VSR[32×AX+A].hword[i]",
                "   else",
                "      VSR[32×TX+T].hword[i] := VSR[32×BX+B].hword[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "VSX Vector Blend Variable Word",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxblendvw",
                    "regs": [ "XT,XA,XB,XC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "18" },
                { "name": "opcode", "size": "6", "value": "33" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "2" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 3",
                "   if VSR[32×CX+C].word[i].bit[0]=0 then",
                "      VSR[32×TX+T].word[i] := VSR[32×AX+A].word[i]",
                "   else",
                "      VSR[32×TX+T].word[i] := VSR[32×BX+B].word[i]",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Doubleword",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxbrd",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "23" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   vsrc ~ VSR[32×BX+B].dword[i]",
                "   do j = 0 to 7",
                "      VSR[32×TX+T].dword[i].byte[j] ~ vsrc.byte[7-j]",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Halfword",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxbrh",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "7" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 7",
                "   vsrc ~ VSR[32×BX+B].hword[i]",
                "   do j = 0 to 1",
                "      VSR[32×TX+T].hword[i].byte[j] ~ vsrc.byte[1-j]",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Quadword",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxbrq",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "31" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 15",
                "   VSR[32×TX+T].byte[i] ~ VSR[32×BX+B].byte[15-i]",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Byte-Reverse Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxbrw",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "15" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   vsrc ~ VSR[32×BX+B].word[i]",
                "   do j = 0 to 3",
                "      VSR[32×TX+T].word[i].byte[j] ~ vsrc.byte[3-j]",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Compare Equal To Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpeqdp",
                    "regs": [ "XT,XA,XB", "(Rc=0)" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "7", "value": "99" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "",
                "   vxsnan_flag := IsSNaN(src1) | IsSNaN(src2)",
                "",
                "   if src1 = src2 then do",
                "      vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false        := 0b0",
                "   end",
                "   else do",
                "      vresult.dword[i] := 0x0000_0000_0000_0000",
                "      all_true         := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Equal To Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpeqsp",
                    "regs": [ "XT,XA,XB", "(Rc=0)" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "7", "value": "67" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "",
                "   vxsnan_flag := IsSNaN(src1) | IsSNaN(src2)",
                "",
                "   if src1 = src2 then do",
                "      vresult.word[i] := 0xFFFF_FFFF",
                "      all_false       := 0b0",
                "   end",
                "   else do",
                "      vresult.word[i] := 0x0000_0000",
                "      all_true        := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgtdp",
                    "regs": [ "XT,XA,XB", "(Rc=0)" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "7", "value": "107" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "",
                "   if src1.class.SNaN | src2.class.SNaN then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "   if src1 > src2 then do",
                "      vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false        := 0b0",
                "   end",
                "   else do",
                "      vresult.dword[i] := 0x0000_0000_0000_0000",
                "      all_true         := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgtsp",
                    "regs": [ "XT,XA,XB", "(Rc=0)" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "7", "value": "75" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "",
                "   if IsSNaN(src1)=1 | IsSNaN(src2)=1 then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else",
                "      vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "   if src1 > src2 then do",
                "      vresult.word[i] := 0xFFFF_FFFF",
                "      all_false       := 0b0",
                "   end",
                "   else do",
                "      vresult.word[i] := 0x0000_0000",
                "      all_true        := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than or Equal To Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgedp",
                    "regs": [ "XT,XA,XB", "(Rc=0)" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "7", "value": "115" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "",
                "   if src1.class.SNaN | src2.class.SNaN then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "   if src1 >= src2 then do",
                "      vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false        := 0b0",
                "   end",
                "   else do",
                "      vresult.dword[i] := 0x0000_0000_0000_0000",
                "      all_true         := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Compare Greater Than or Equal To Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcmpgesp",
                    "regs": [ "XT,XA,XB", "(Rc=0)" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "7", "value": "83" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i=0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "",
                "   if src1.class.SNaN | src2.class.SNaN then do",
                "      vxsnan_flag := 0b1",
                "      if FPSCR.VE=0 then vxvc_flag := 0b1",
                "   end",
                "   else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "   if src1 >= src2 then do",
                "      vresult.word[i] := 0xFFFF_FFFF",
                "      all_false       := 0b0",
                "   end",
                "   else do",
                "      vresult.word[i] := 0x0000_0000",
                "      all_true        := 0b0",
                "   end",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "   if vex_flag=0 then",
                "      CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "   else",
                "      CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR Field 6 is set as follows.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT] and the ",
                "contents of CR field 6 are undefined if Rc is equal to 1."
            ]
        },
        {
            "description": "VSX Vector Convert Signed Word to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxwdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "248" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := bfp_CONVERT_FROM_SI32(VSR[32×BX+B].dword[i].word[0])",
                "   VSR[32×TX+T].dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Convert Single-Precision to Double - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "457" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src ~ bfp_CONVERT_FROM_BFP32(VSR[BX×32+B].dword[i].word[0])",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert Unsigned Word to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxwdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "232" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := bfp_CONVERT_FROM_UI32(VSR[32×BX+B].dword[i].word[0])",
                "   VSR[32×TX+T].dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Convert bfloat16 to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvbf16sp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "16" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "   VSR[32×TX+T].word[i].hword[0] := VSR[32×BX+B].word[i].hword[1]",
                "   VSR[32×TX+T].word[i].hword[1] := 0x0000",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Convert bfloat16 to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvhpsp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "24" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "   src ~ bfp_CONVERT_FROM_BFP16(VSR[BX×32+B].word[i].hword[1])",
                "",
                "   if src.class.SNaN=1 then",
                "      vresult.word[i] ~ bfp32_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "   else",
                "      vresult.word[i] ~ bfp32_CONVERT_FROM_BFP(src)",
                "",
                "   vxsnan_flag ~ src.class.SNaN",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   ex_flag ~ ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs, VSR[XT] is not ",
                "modified."
            ]
        },
        {
            "description": "VSX Vector Convert with r ound Unsigned W ord to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxwsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "168" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_UI32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Double-Precision to Single - Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "393" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "   vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[XT] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                ""
            ]
        },
        {
            "description": "VSX Vector Convert with round Signed Doubleword to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxddp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "504" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_SI64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Signed Doubleword to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxdsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "440" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_SI64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Signed Word to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsxwsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "184" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_SI32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Single - Precision to bfloat16 format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspbf16",
                    "regs": [ "XT,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "17" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   reset_flags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_BFLOAT16_NO_TRAP(src)",
                "   result.word[i].hword[0] := 0x0000",
                "   result.word[i].hword[1] := bfloat16_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "           :=         | (FPSCR.OE & ox_flag)",
                "           :=         | (FPSCR.UE & ux_flag)",
                "           :=         | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs, VSR[XT] is not ",
                "modified."
            ]
        },
        {
            "description": "VSX Vector Convert with round Single-Precision to bfloat16 format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvsphp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "25" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "   src ~ bfp_CONVERT_FROM_BFP32(VSR[BX×32+B].word[i])",
                "   rnd ~ bfp_ROUND_TO_BFP16(FPSCR.RN,rnd)",
                "",
                "   vresult.word[i].hword[0] ~ 0x0000",
                "   vresult.word[i].hword[1] ~ bfp16_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag ~ ex_flag | (FPSCR.VE & vxsnan_flag)",
                "           ~         | (FPSCR.OE & ox_flag)",
                "           ~         | (FPSCR.UE & ux_flag)",
                "           ~         | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs, VSR[XT] is not ",
                "modified."
            ]
        },
        {
            "description": "VSX Vector Convert with round Unsigned Doubleword to Double-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxddp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "488" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_UI64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round Unsigned Doubleword to Single-Precision format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvuxdsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "424" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_UI64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "   vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero D ouble-Precision t o Signed D oubleword format X",
            "form": "X2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpsxds",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "472" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[XT] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Signed Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpsxws",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "216" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i].word[0] := si32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " ",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Unsigned Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpuxds",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "456" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Double-Precision to Unsigned Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvdpuxws",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "200" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i].word[0] := ui32_CONVERT_FROM_BFP(rnd)",
                "   vresult.dword[i].word[1] := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] ~ vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " ",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Signed Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspsxds",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "408" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].dword[i].word[0])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Signed Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspsxws",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "152" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.word[i] := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Unsigned Doubleword format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspuxds",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "392" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].dword[i].word[0])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                " "
            ]
        },
        {
            "description": "VSX Vector Convert with round to zero Single-Precision to Unsigned Word format",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcvspuxws",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "136" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.word[i] := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Copy Sign Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcpsgndp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "240" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[32×AX+A].dword[i] & 0x8000_0000_0000_0000",
                "   src2 := VSR[32×BX+B].dword[i] & 0x7FFF_FFFF_FFFF_FFFF",
                "   VSR[32×TX+T].dword[i] := src1 | src2",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "Extended mnemonic for VSX Vector Copy Sign Dou",
                "ble-Precision:"
            ]
        },
        {
            "description": "VSX Vector Copy Sign Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvcpsgnsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "208" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[32×AX+A].word[i] & 0x8000_0000",
                "   src2 := VSR[32×BX+B].word[i] & 0x7FFF_FFFF",
                "   VSR[32×TX+T].word[i] := src1 | src2",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "Extended mnemonic for VSX Vector Copy Sign Sin",
                "gle-Precision:"
            ]
        },
        {
            "description": "VSX Vector Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvdivdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "120" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v    := bfp_DIVIDE(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXZDZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxidi_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxzdz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Divide Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvdivsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "88" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   v    := bfp_DIVIDE(src1,src2)",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXZDZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxidi_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxzdz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Evaluate",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxeval",
                    "regs": [ "XT,XA,XB,XC,IMM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "10" },
                { "name": "IMM", "size": "8" },
                { "name": "opcode", "size": "6", "value": "34" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "src1 := VSR[32xAX+A]",
                "src2 := VSR[32xBX+B]",
                "src3 := VSR[32xCX+C]",
                "result := (~src1&~src2&~src3 & qword_bit_splat(IMM.bit[0]) |",
                "         (~src1&~src2& src3 & qword_bit_splat(IMM.bit[1]) |",
                "         (~src1& src2&~src3 & qword_bit_splat(IMM.bit[2]) |",
                "         (~src1& src2& src3 & qword_bit_splat(IMM.bit[3]) |",
                "         ( src1&~src2&~src3 & qword_bit_splat(IMM.bit[4]) |",
                "         ( src1&~src2& src3 & qword_bit_splat(IMM.bit[5]) |",
                "         ( src1& src2&~src3 & qword_bit_splat(IMM.bit[6]) |",
                "         ( src1& src2& src3 & qword_bit_splat(IMM.bit[7])",
                "VSR[32xTX+T] := result"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "For each integer value i, 0 to 127, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Exponent Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvxexpdp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src ~ VSR[32×BX+B].dword[i]",
                "   VSR[32×TX+T].dword[i] ~ EXTZ64(src.bit[1:11])",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Exponent Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvxexpsp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "8" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src ~ VSR[32×BX+B].word[i]",
                "   VSR[32×TX+T].word[i] ~ EXTZ32(src.bit[1:8])",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Significand Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvxsigdp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src ~ VSR[32×BX+B].dword[i]",
                "   exponent ~ EXTZ(src.bit[1:11])",
                "   fraction ~ EXTZ64(src.bit[12:63])",
                "",
                "   if (exponent != 0) &  (exponent != 2047) then",
                "      fraction ~ fraction | 0x0010_0000_0000_0000",
                "",
                "   VSR[32×TX+T].dword[i] ~ fraction",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Significand Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvxsigsp",
                    "regs": [ "XT,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "5", "value": "9" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src ~ VSR[32×BX+B].word[i]",
                "   exponent ~ EXTZ(src.bit[1:8])",
                "   fraction ~ EXTZ32(src.bit[9:31])",
                "",
                "   if (exponent != 0) &  (exponent != 255) then",
                "      fraction ~ fraction | 0x0080_0000",
                "",
                "   VSR[32×TX+T].word[i] ~ fraction",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Extract Unsigned Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxextractuw",
                    "regs": [ "XT,XB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "165" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src ~ VSR[32×BX+B].byte[UIM:UIM+3]",
                "",
                "VSR[32×TX+T].dword[0] ~ EXTZ64(src)",
                "VSR[32×TX+T].dword[1] ~ 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of byte elements UIM:UIM+3 of VSR[XB]  ",
                "are placed into word element 1 of VSR[XT]. The ",
                "contents of the remaining word elements of VSR[XT] ",
                "are set to 0.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Byte Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvbm",
                    "regs": [ "XT,VRB,IMM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "IMM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "916" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[i].bit[0]=1 then do",
                "         VSR[XT].byte[i] := j",
                "         j := j + 1",
                "      end",
                "      else",
                "         VSR[XT].byte[i] := i + 0x10",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[i].bit[0]=1 then do",
                "         VSR[XT].byte[j] = i",
                "         j = j + 1",
                "      end",
                "   end",
                "   do i = j to 15",
                "      VSR[XT].byte[i] = 0xUU",
                "   end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0;",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[15-i].bit[0]=1 then do",
                "         VSR[XT].byte[15-i] := j",
                "         j := j + 1",
                "      end",
                "      else",
                "         VSR[XT].byte[15-i] := i + 0x10",
                "   end",
                "end",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 15",
                "      if VSR[VRB+32].byte[15-i].bit[0]=1 then do",
                "         VSR[XT].byte[15-j] := i",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 15",
                "         VSR[XT].byte[15-i] := 0xUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "byte elements of a source vector into the byte ",
                "elements of a result vector specified by the ",
                "byte-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement a compression of the sparse ",
                "byte elements in a source vector specified by the ",
                "byte-element mask in VSR[VRB+32] into the leftmost ",
                "byte elements of a result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "byte elements of a source vector into the byte ",
                "elements of a result vector specified by the ",
                "byte-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "byte elements in a source vector specified by the ",
                "byte-element mask in VSR[VRB+32] into the rightmost ",
                "byte elements of a result vector.",
                "pcv is placed into VSR[XT].",
                "Unused values of IMM are reserved."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Doubleword Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvdm",
                    "regs": [ "XT,VRB,IMM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "IMM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "949" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[i].bit[0]=1 then do",
                "         VSR[XT].dword[i].byte[0] := 8×j + 0x00",
                "         VSR[XT].dword[i].byte[1] := 8×j + 0x01",
                "         VSR[XT].dword[i].byte[2] := 8×j + 0x02",
                "         VSR[XT].dword[i].byte[3] := 8×j + 0x03",
                "         VSR[XT].dword[i].byte[4] := 8×j + 0x04",
                "         VSR[XT].dword[i].byte[5] := 8×j + 0x05",
                "         VSR[XT].dword[i].byte[6] := 8×j + 0x06",
                "         VSR[XT].dword[i].byte[7] := 8×j + 0x07",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].dword[i].byte[0] := 8×i + 0x10",
                "         VSR[XT].dword[i].byte[1] := 8×i + 0x11",
                "         VSR[XT].dword[i].byte[2] := 8×i + 0x12",
                "         VSR[XT].dword[i].byte[3] := 8×i + 0x13",
                "         VSR[XT].dword[i].byte[4] := 8×i + 0x14",
                "         VSR[XT].dword[i].byte[5] := 8×i + 0x15",
                "         VSR[XT].dword[i].byte[6] := 8×i + 0x16",
                "         VSR[XT].dword[i].byte[7] := 8×i + 0x17",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[i].bit[0]=1 then do",
                "         VSR[XT].dword[j].byte[0] := 8×i + 0x00",
                "         VSR[XT].dword[j].byte[1] := 8×i + 0x01",
                "         VSR[XT].dword[j].byte[2] := 8×i + 0x02",
                "         VSR[XT].dword[j].byte[3] := 8×i + 0x03",
                "         VSR[XT].dword[j].byte[4] := 8×i + 0x04",
                "         VSR[XT].dword[j].byte[5] := 8×i + 0x05",
                "         VSR[XT].dword[j].byte[6] := 8×i + 0x06",
                "         VSR[XT].dword[j].byte[7] := 8×i + 0x07",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 1",
                "      VSR[XT].dword[i] := 0xUUUU_UUUU_UUUU_UUUU",
                "   end",
                "end",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[1-i].bit[0]=1 then do",
                "         VSR[XT].dword[1-i].byte[7] := 8×j + 0x00",
                "         VSR[XT].dword[1-i].byte[6] := 8×j + 0x01",
                "         VSR[XT].dword[1-i].byte[5] := 8×j + 0x02",
                "         VSR[XT].dword[1-i].byte[4] := 8×j + 0x03",
                "         VSR[XT].dword[1-i].byte[3] := 8×j + 0x04",
                "         VSR[XT].dword[1-i].byte[2] := 8×j + 0x05",
                "         VSR[XT].dword[1-i].byte[1] := 8×j + 0x06",
                "         VSR[XT].dword[1-i].byte[0] := 8×j + 0x07",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].dword[1-i].byte[7] := 8×i + 0x10",
                "         VSR[XT].dword[1-i].byte[6] := 8×i + 0x11",
                "         VSR[XT].dword[1-i].byte[5] := 8×i + 0x12",
                "         VSR[XT].dword[1-i].byte[4] := 8×i + 0x13",
                "         VSR[XT].dword[1-i].byte[3] := 8×i + 0x14",
                "         VSR[XT].dword[1-i].byte[2] := 8×i + 0x15",
                "         VSR[XT].dword[1-i].byte[1] := 8×i + 0x16",
                "         VSR[XT].dword[1-i].byte[0] := 8×i + 0x17",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 1",
                "      if VSR[VRB+32].dword[1-i].bit[0]=1 then do",
                "         VSR[XT].dword[1-j].byte[7] := 8×i + 0x00",
                "         VSR[XT].dword[1-j].byte[6] := 8×i + 0x01",
                "         VSR[XT].dword[1-j].byte[5] := 8×i + 0x02",
                "         VSR[XT].dword[1-j].byte[4] := 8×i + 0x03",
                "         VSR[XT].dword[1-j].byte[3] := 8×i + 0x04",
                "         VSR[XT].dword[1-j].byte[2] := 8×i + 0x05",
                "         VSR[XT].dword[1-j].byte[1] := 8×i + 0x06",
                "         VSR[XT].dword[1-j].byte[0] := 8×i + 0x07",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 1",
                "         VSR[XT].dword[1-i] := 0xUUUU_UUUU_UUUU_UUUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "doubleword elements of a source vector into the ",
                "doubleword elements of a result vector specified by ",
                "the doubleword-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the the permute control ",
                "vector required to enable a left-indexed permute ",
                "(vperm or xxperm) to implement a compression of the ",
                "sparse doubleword elements in a source vector ",
                "specified by the doubleword-element mask in ",
                "VSR[VRB+32] into the leftmost doubleword elements of a ",
                "result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "doubleword elements of a source vector into the ",
                "doubleword elements of a result vector specified by ",
                "the doubleword-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "doubleword elements in a source vector specified by ",
                "the doubleword-element mask in VSR[VRB+32] into the ",
                "rightmost doubleword elements of a result vector.",
                "pcv is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Halfword Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvhm",
                    "regs": [ "XT,VRB,IMM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "IMM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "917" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[i].bit[0]=1 then do",
                "         VSR[XT].hword[i].byte[0] := 2×j + 0x00",
                "         VSR[XT].hword[i].byte[1] := 2×j + 0x01",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].hword[i].byte[0] := 2×i + 0x10",
                "         VSR[XT].hword[i].byte[1] := 2×i + 0x11",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[i].bit[0]=1 then do",
                "         VSR[XT].hword[j].byte[0] := 2×i + 0x00",
                "         VSR[XT].hword[j].byte[1] := 2×i + 0x01",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 7",
                "      VSR[XT].hword[i] := 0xUUUU",
                "   end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[7-i].bit[0]=1 then do",
                "         VSR[XT].hword[7-i].byte[1] := 2×j + 0x00",
                "         VSR[XT].hword[7-i].byte[0] := 2×j + 0x01",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].hword[7-i].byte[1] := 2×i + 0x10",
                "         VSR[XT].hword[7-i].byte[0] := 2×i + 0x11",
                "      end",
                "   end",
                "end",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 7",
                "      if VSR[VRB+32].hword[7-i].bit[0]=1 then do",
                "         VSR[XT].hword[7-j].byte[1] := 2×i + 0x00",
                "         VSR[XT].hword[7-j].byte[0] := 2×i + 0x01",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 7",
                "         VSR[XT].hword[7-i] := 0xUUUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "halfword elements of a source vector into the halfword ",
                "elements of a result vector specified by the ",
                "halfword-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement a compression of the sparse ",
                "halfword elements in a source vector specified by the ",
                "halfword-element mask in VSR[VRB+32] into the leftmost ",
                "halfword elements of a result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "halfword elements of a source vector into the halfword ",
                "elements of a result vector specified by the ",
                "halfword-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "halfword elements in a source vector specified by the ",
                "halfword-element mask in VSR[VRB+32] into the ",
                "rightmost halfword elements of a result vector.",
                "pcv is placed into VSR[XT].",
                "Unused values of IMM are reserved."
            ]
        },
        {
            "description": "VSX Vector Generate PCV from Word Mask",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxgenpcvwm",
                    "regs": [ "XT,VRB,IMM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "IMM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "948" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[i].bit[0]=1 then do",
                "         VSR[XT].word[i].byte[0] := 4×j + 0x00",
                "         VSR[XT].word[i].byte[1] := 4×j + 0x01",
                "         VSR[XT].word[i].byte[2] := 4×j + 0x02",
                "         VSR[XT].word[i].byte[3] := 4×j + 0x03",
                "         j = j + 1",
                "      end",
                "      else do",
                "         VSR[XT].word[i].byte[0] := 4×i + 0x10",
                "         VSR[XT].word[i].byte[1] := 4×i + 0x11",
                "         VSR[XT].word[i].byte[2] := 4×i + 0x12",
                "         VSR[XT].word[i].byte[3] := 4×i + 0x13",
                "      end",
                "   end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[i].bit[0]=1 then do",
                "         VSR[XT].word[j].byte[0] := 4×i + 0x00",
                "         VSR[XT].word[j].byte[1] := 4×i + 0x01",
                "         VSR[XT].word[j].byte[2] := 4×i + 0x02",
                "         VSR[XT].word[j].byte[3] := 4×i + 0x03",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 3",
                "      VSR[XT].word[i] := 0xUUUU_UUUU",
                "   end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[3-i].bit[0]=1 then do",
                "         VSR[XT].word[3-i].byte[3] := 4×j + 0x00",
                "         VSR[XT].word[3-i].byte[2] := 4×j + 0x01",
                "         VSR[XT].word[3-i].byte[1] := 4×j + 0x02",
                "         VSR[XT].word[3-i].byte[0] := 4×j + 0x03",
                "         j := j + 1",
                "      end",
                "      else do",
                "         VSR[XT].word[3-i].byte[3] := 4×i + 0x10",
                "         VSR[XT].word[3-i].byte[2] := 4×i + 0x11",
                "         VSR[XT].word[3-i].byte[1] := 4×i + 0x12",
                "         VSR[XT].word[3-i].byte[0] := 4×i + 0x13",
                "      end",
                "   end",
                "end",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "   j := 0",
                "   do i = 0 to 3",
                "      if VSR[VRB+32].word[3-i].bit[0]=1 then do",
                "         VSR[XT].word[3-j].byte[3] := 4×i + 0x00",
                "         VSR[XT].word[3-j].byte[2] := 4×i + 0x01",
                "         VSR[XT].word[3-j].byte[1] := 4×i + 0x02",
                "         VSR[XT].word[3-j].byte[0] := 4×i + 0x03",
                "         j := j + 1",
                "      end",
                "   end",
                "   do i = j to 3",
                "         VSR[XT].word[3-i] := 0xUUUU_UUUU",
                "   end",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "If IMM=0b00000, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement an expansion of the leftmost ",
                "word elements of a source vector into the word ",
                "elements of a result vector specified by the ",
                "word-element mask in VSR[VRB+32].",
                "If IMM=0b00001, let pcv be the permute control vector ",
                "required to enable a left-indexed permute (vperm or ",
                "xxperm) to implement a compression of the sparse ",
                "word elements in a source vector specified by the ",
                "word-element mask in VSR[VRB+32] into the leftmost ",
                "word elements of a result vector.",
                "If IMM=0b00010, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement an expansion of the rightmost ",
                "word elements of a source vector into the word ",
                "elements of a result vector specified by the ",
                "word-element mask in VSR[VRB+32].",
                "If IMM=0b00011, let pcv be the permute control vector ",
                "required to enable a right-indexed permute (vpermr or ",
                "xxpermr) to implement a compression of the sparse ",
                "word elements in a source vector specified by the ",
                "word-element mask in VSR[VRB+32] into the rightmost ",
                "word elements of a result vector.",
                "pcv is placed into VSR[XT].",
                "Unused values of IMM are reserved."
            ]
        },
        {
            "description": "VSX Vector Insert Exponent Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xviexpdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "248" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 ~ VSR[32×AX+A].dword[i]",
                "   src2 ~ VSR[32×BX+B].dword[i]",
                "",
                "   VSR[32×TX+T].dword[i].bit[0]     ~ src1.bit[0]",
                "   VSR[32×TX+T].dword[i].bit[1:11]  ~ src2.bit[53:63]",
                "   VSR[32×TX+T].dword[i].bit[12:63] ~ src1.bit[12:63]",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Insert Exponent Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xviexpsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "216" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 ~ VSR[32×AX+A].word[i]",
                "   src2 ~ VSR[32×BX+B].word[i]",
                "",
                "   VSR[32×TX+T].word[i].bit[0]    ~ src1.bit[0]",
                "   VSR[32×TX+T].word[i].bit[1:8]  ~ src2.bit[24:31]",
                "   VSR[32×TX+T].word[i].bit[9:31] ~ src1.bit[9:31]",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Insert Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxinsertw",
                    "regs": [ "XT,XB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "181" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T].byte[UIM:UIM+3] ~ VSR[32×BX+B].bit[32:63]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of word element 1 of VSR[XB] are placed ",
                "into byte elements UIM:UIM+3 of VSR[XT]. The contents ",
                "of the remaining byte elements of VSR[XT] are not ",
                "modified.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "VSX Vector Logical AND",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxland",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "130" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := VSR[32×AX+A] & VSR[32×BX+B]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are ANDed with the contents ",
                "of VSR[XB] and the result is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical AND with Complement",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxlandc",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "138" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := VSR[32×AX+A] & ~VSR[32×BX+B]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are ANDed with the ",
                "complement of the contents of VSR[XB] and the result is ",
                "placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical Equivalence",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxleqv",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "186" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := VSR[32×AX+A] == VSR[32×BX+B]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are exclusive-ORed with the ",
                "contents of VSR[XB] and the complemented result is ",
                "placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical NAND",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxlnand",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "178" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := ~( VSR[32×AX+A] & VSR[32×BX+B] )"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are ANDed with the contents ",
                "of VSR[XB] and the complemented result is placed into ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical NOR",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxlnor",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "162" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := ~( VSR[32×AX+A] | VSR[32×BX+B] )"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are ORed with the contents of ",
                "VSR[XB] and the complemented result is placed into ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical OR",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxlor",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "146" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := VSR[32×AX+A] | VSR[32×BX+B]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are ORed with the contents of ",
                "VSR[XB] and the result is placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical OR with Complement",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxlorc",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "170" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := VSR[32×AX+A] | ~VSR[32×BX+B]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are ORed with the ",
                "complement of the contents of VSR[XB] and the result is ",
                "placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Logical XOR",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxlxor",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "154" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T] := VSR[32×AX+A] ^ VSR[32×BX+B]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of VSR[XA] are exclusive-ORed with the ",
                "contents of VSR[XB] and the result is placed into ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Maximum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmaxdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "224" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32×AX+A].dword[i]",
                "   src2 := VSR[32×BX+B].dword[i]",
                "   vresult.dword[i] := bfp64_MAXIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Maximum Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmaxsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "192" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32×AX+A].word[i]",
                "   src2 := VSR[32×BX+B].word[i]",
                "   vresult.word[i] := bfp32_MAXIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Merge High Word",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxmrghw",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "18" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T].word[0] := VSR[32×AX+A].word[0]",
                "VSR[32×TX+T].word[1] := VSR[32×BX+B].word[0]",
                "VSR[32×TX+T].word[2] := VSR[32×AX+A].word[1]",
                "VSR[32×TX+T].word[3] := VSR[32×BX+B].word[1]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of word element 0 of VSR[XA] are placed ",
                "into word element 0 of VSR[XT].",
                "The contents of word element 0 of VSR[XB] are placed ",
                "into word element 1 of VSR[XT].",
                "The contents of word element 1 of VSR[XA] are placed ",
                "into word element 2 of VSR[XT].",
                "The contents of word element 1 of VSR[XB] are placed ",
                "into word element 3 of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Merge Low Word",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxmrglw",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "50" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T].word[0] := VSR[32×AX+A].word[2]",
                "VSR[32×TX+T].word[1] := VSR[32×BX+B].word[2]",
                "VSR[32×TX+T].word[2] := VSR[32×AX+A].word[3]",
                "VSR[32×TX+T].word[3] := VSR[32×BX+B].word[3]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of word element 2 of VSR[XA] are placed ",
                "into word element 0 of VSR[XT].",
                "The contents of word element 2 of VSR[XB] are placed ",
                "into word element 1 of VSR[XT].",
                "The contents of word element 3 of VSR[XA] are placed ",
                "into word element 2 of VSR[XT].",
                "The contents of word element 3 of VSR[XB] are placed ",
                "into word element 3 of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Minimum Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmindp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "232" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32×AX+A].dword[i]",
                "   src2 := VSR[32×BX+B].dword[i]",
                "   vresult.dword[i] := bfp64_MINIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Minimum Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvminsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "200" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := VSR[32×AX+A].word[i]",
                "   src2 := VSR[32×BX+B].word[i]",
                "   vresult.word[i] := bfp32_MINIMUM(src1,src2)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmuldp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "112" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src3 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v    := bfp_MULTIPLY(src1,src3)",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmulsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "80" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src3 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   v    := bfp_MULTIPLY(src1,src3)",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "97" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Multiply-Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "65" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "105" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if “xvmaddadp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmaddmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "73" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if “xvmaddasp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "",
                    "regs": [  ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "113" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmsubasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "81" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "",
                    "regs": [  ],
                    "release": ""
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "121" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if “xvmsubadp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Multiply-Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvmsubmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "89" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if “xvmsubasp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := result"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negate Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnegdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "505" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[32×BX+B].dword[i]",
                "   VSR[32×TX+T].dword[i] := bfp64_NEGATE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Negate Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnegsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "441" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[32×BX+B].word[i]",
                "   VSR[32×TX+T].word[i] := bfp32_NEGATE(src)",
                "end"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Negative Absolute Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnabsdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "489" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[32×BX+B].dword[i]",
                "   VSR[32×TX+T].dword[i] := bfp64_NEGATIVE_ABSOLUTE(src)"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Negative Absolute Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnabssp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "425" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[32×BX+B].word[i]",
                "   VSR[32×TX+T].word[i] := bfp32_NEGATIVE_ABSOLUTE(src)"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "225" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "193" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "233" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if “xvnmaddadp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP64(FPSCR.RN,v))",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Add Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmaddmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "201" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if “xvnmaddasp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN,v))",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP32(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-A Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubadp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "241" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-A Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubasp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "209" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-M Double - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubmdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "249" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   if “xvnmsubadp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "      src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "      src3 := bfp_CONVERT_FROM_BFP64(VSR[32×TX+T].dword[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP64(FPSCR.RN,v))",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Negative Multiply-Subtract Type-M Single - Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvnmsubmsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "217" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   if “xvnmsubasp” then do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   end",
                "   else do",
                "      src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "      src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "      src3 := bfp_CONVERT_FROM_BFP32(VSR[32×TX+T].word[i])",
                "   end",
                "",
                "   v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "   rnd := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN,v))",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP32(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Permute",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxperm",
                    "regs": [ "XT,XA.XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "26" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.byte[0:15]  ~ VSR[32×AX+A]",
                "src.byte[16:31] ~ VSR[32×TX+T]",
                "pcv.byte[0:15]  ~ VSR[32×BX+B]",
                "",
                "do i = 0 to 15",
                "   idx ~ pcv.byte[i].bit[3:7]",
                "   VSR[32×TX+T].byte[i] ~ src.byte[idx]",
                "end"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "Let bytes 0:15 of src be the contents of VSR[XA].",
                "Let the permute control vector pcv be the contents of ",
                "VSR[XB].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Permute Doubleword Immediate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxpermdi",
                    "regs": [ "XT,XA,XB,DM" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "DM", "size": "2" },
                { "name": "opcode", "size": "5", "value": "10" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T].dword[0] := VSR[32×AX+A].dword[DM.bit[0]]",
                "VSR[32×TX+T].dword[1] := VSR[32×BX+B].dword[DM.bit[1]]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "If DM.bit[0]=0, the contents of doubleword element 0 ",
                "of VSR[XA] are placed into doubleword element 0 of ",
                "VSR[XT]. Otherwise the contents of doubleword ",
                "element 1 of VSR[XA] are placed into doubleword ",
                "element 0 of VSR[XT].",
                "If DM.bit[1]=0, the contents of doubleword element 0 ",
                "of VSR[XB] are placed into doubleword element 1 of ",
                "VSR[XT]. Otherwise the contents of doubleword ",
                "element 1 of VSR[XB] are placed into doubleword ",
                "element 1 of VSR[XT].",
                "Extended mnemonics for VSX Vector Permute Double",
                "word Immediate:"
            ]
        },
        {
            "description": "VSX Vector Permute Extended",
            "form": "8RR:XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxpermx",
                    "regs": [ "XT,XA,XB,XC,UIM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "15" },
                { "name": "UIM", "size": "3" },
                { "name": "opcode", "size": "6", "value": "34" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.qword[0] := VSR[32×AX+A]",
                "src.qword[1] := VSR[32×BX+B]",
                "do i = 0 to 15",
                "   section := VSR[32×CX+C].byte[i].bit[0:2]",
                "   eidx    := VSR[32×CX+C].byte[i].bit[3:7]",
                "   if section=UIM then",
                "      VSR[32×TX+T].byte[i] := src.byte[eidx]",
                "   else ",
                "      VSR[32×TX+T].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "Let UIM specify which 32-byte section of the long vector ",
                "that src contains.",
                "Let src be the concatenation VSR[XA] and VSR[XB], ",
                "comprising a 32-byte section of up to a 128-byte ",
                "vector.",
                "For each integer value i from 0 to 15, do the following.",
                " ",
                " ",
                ""
            ]
        },
        {
            "description": "VSX Vector Permute Right-indexed",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxpermr",
                    "regs": [ "XT,XA.XB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "58" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.byte[0:15]  ~ VSR[32×AX+A]",
                "src.byte[16:31] ~ VSR[32×TX+T]",
                "pcv.byte[0:15]  ~ VSR[32×BX+B]",
                "",
                "do i = 0 to 15",
                "   idx ~ pcv.byte[i].bit[3:7]",
                "   VSR[32×TX+T].byte[i] ~ src.byte[31-idx]",
                "end"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "Let bytes 0:15 of src be the contents of VSR[XA].",
                "Let the permute control vector pcv be the contents of ",
                "VSR[XB].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvredp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "218" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v   := bfp_RECIPROCAL_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvresp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "154" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   v   := bfp_RECIPROCAL_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Square Root Estimate Double - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrsqrtedp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "202" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v   := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Reciprocal Square Root Estimate Single - Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrsqrtesp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "138" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   v   := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                " ",
                "Operation with various special values of the operand is ",
                "summarized below.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT].",
                "The results of executing this instruction is permitted to ",
                "vary between implementations, and between different ",
                "executions on the same implementation."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer Exact using Current rounding mode",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpic",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "235" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "",
                "   if FPSCR.RN=0b00 then",
                "      rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "   if FPSCR.RN=0b01 then",
                "      rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "   if FPSCR.RN=0b10 then",
                "      rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "   if FPSCR.RN=0b11 then",
                "      rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round to Nearest Away",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpi",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "201" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round toward +Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpip",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "233" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round toward -Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpim",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "249" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Double-Precision Integer using round toward Zero",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrdpiz",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "217" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer Exact using Current rounding mode",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrspic",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "171" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   if FPSCR.RN=0b00 then",
                "      rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "   if FPSCR.RN=0b01 then",
                "      rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "   if FPSCR.RN=0b10 then",
                "      rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "   if FPSCR.RN=0b11 then",
                "      rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round to Nearest Away",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrspi",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "137" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round toward +Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrspip",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "169" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round toward -Infinity",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrspim",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "185" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Round to Single-Precision Integer using round toward Zero",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvrspiz",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "153" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Select",
            "form": "XX4-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxsel",
                    "regs": [ "XT,XA,XB,XC" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "C", "size": "5" },
                { "name": "opcode", "size": "2", "value": "3" },
                { "name": "CX", "size": "1" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32×AX+A]",
                "src2 := VSR[32×BX+B]",
                "mask := VSR[32×CX+C]",
                "",
                "VSR[32×TX+T] := (src1 & ~mask) | (src2 & mask)"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let src1 be the contents of VSR[XA].",
                "The value, (src1&~mask)|(src2&mask), is placed ",
                "into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Shift Left Double by Word Immediate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxsldwi",
                    "regs": [ "XT,XA,XB,SHW" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "1", "value": "0" },
                { "name": "SHW", "size": "2" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "source.qword[0] := VSR[32×AX+A]",
                "source.qword[1] := VSR[32×BX+B]",
                "VSR[32×TX+T] := source.word[SHW:SHW+3]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[XA] followed by the contents of VSR[XB].",
                "Words SHW:SHW+3 of vsrc are placed into VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate Byte",
            "form": "X-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxspltib",
                    "regs": [ "XT,IMM8" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "IMM8", "size": "8" },
                { "name": "opcode", "size": "10", "value": "360" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   VSR[32×TX+T].byte[i] ~ UIM8",
                "end"
            ],
            "body": [
                "Let XT be the sum 32×TX + T.",
                "The value IMM8 is copied into each byte element of ",
                "VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate Double - Precision",
            "form": "8RR:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxspltidp",
                    "regs": [ "XT,IMM32" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "2" },
                { "name": "imm0", "size": "16" },
                { "name": "opcode", "size": "6", "value": "32" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "4", "value": "2" },
                { "name": "TX", "size": "1" },
                { "name": "imm1", "size": "16" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "IMM32 ~ imm0<<16 | imm1;",
                "",
                "temp ~ bfp_CONVERT_FROM_BFP32(IMM32);",
                "",
                "VSR[32×TX+T].dword[0] ~ bfp64_CONVERT_FROM_BFP(IMM32);",
                "VSR[32×TX+T].dword[1] ~ bfp64_CONVERT_FROM_BFP(IMM32);"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let IMM32 be the concatenation of imm0 and imm1, ",
                "representing a single-precision value.",
                "IMM32 is converted to double-precision format and ",
                "placed into each doubleword element of VSR[XT].",
                "If IMM32 specifies a single-precision denormal value ",
                "(i.e., bits 1:8 equal to 0 and bits 9:31 not equal to 0), ",
                "the result is undefined."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate Word",
            "form": "8RR:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxspltiw",
                    "regs": [ "XT,IMM32" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "2" },
                { "name": "imm0", "size": "16" },
                { "name": "opcode", "size": "6", "value": "32" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "4", "value": "3" },
                { "name": "TX", "size": "1" },
                { "name": "imm1", "size": "16" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "IMM32 := imm0<<16 | imm1",
                "",
                "do i = 0 to 3",
                "   VSR[32×TX+T].word[i] := IMM32",
                "end"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "IMM32 is placed into each word element of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Splat Immediate32 Doubleword Indexed",
            "form": "8RR:D-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxsplti32dx",
                    "regs": [ "XT,IX,IMM32" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "1" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "opcode", "size": "4", "value": "0" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "2" },
                { "name": "imm0", "size": "16" },
                { "name": "opcode", "size": "6", "value": "32" },
                { "name": "T", "size": "5" },
                { "name": "opcode", "size": "3", "value": "0" },
                { "name": "IX", "size": "1" },
                { "name": "TX", "size": "1" },
                { "name": "imm1", "size": "16" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "IMM32 := imm0<<16 | imm1",
                "",
                "VSR[32×TX+T].dword[0].word[IX] := IMM32",
                "VSR[32×TX+T].dword[1].word[IX] := IMM32"
            ],
            "body": [
                "Prefix:",
                "Suffix:",
                "Let XT be the value 32×TX + T.",
                "IMM32 is placed into word element IX of each ",
                "doubleword element of VSR[XT]. The contents of the ",
                "remaining word elements are not modified."
            ]
        },
        {
            "description": "VSX Vector Splat Word",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xxspltw",
                    "regs": [ "XT,XB,UIM" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "3" },
                { "name": "UIM", "size": "2" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "164" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32×TX+T].word[0] := VSR[32×BX+B].word[UIM]",
                "VSR[32×TX+T].word[1] := VSR[32×BX+B].word[UIM]",
                "VSR[32×TX+T].word[2] := VSR[32×BX+B].word[UIM]",
                "VSR[32×TX+T].word[3] := VSR[32×BX+B].word[UIM]"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "The contents of word element UIM of VSR[XB] are ",
                "replicated in each word element of VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvsqrtdp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "203" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v   := bfp_SQUARE_ROOT(src)",
                "   rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Square Root Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvsqrtsp",
                    "regs": [ "XT,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "139" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].word[i])",
                "   v   := bfp_SQUARE_ROOT(src)",
                "   rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "   if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Subtract Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvsubdp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "104" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP64(VSR[32×AX+A].dword[i])",
                "   src2 := bfp_CONVERT_FROM_BFP64(VSR[32×BX+B].dword[i])",
                "   v    := bfp_ADD(src1,bfp_NEGATE(src2))",
                "   rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "   vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1 then SetFX(FPSCR.OX)",
                "   if ux_flag=1 then SetFX(FPSCR.UX)",
                "   if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 1, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Subtract Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvsubsp",
                    "regs": [ "XT,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "72" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   reset_xflags()",
                "",
                "   src1 := bfp_CONVERT_FROM_BFP32(VSR[32×AX+A].word[i])",
                "   src2 := bfp_CONVERT_FROM_BFP32(VSR[32×BX+B].word[i])",
                "   v    := bfp_ADD(src1,bfp_NEGATE(src2))",
                "   rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "   vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "   if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "   if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "   if ox_flag=1     then SetFX(FPSCR.OX)",
                "   if ux_flag=1     then SetFX(FPSCR.UX)",
                "   if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "   ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "   ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "   ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "   ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "   ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32×TX+T] := vresult"
            ],
            "body": [
                "Let XT be the value 32×TX + T.",
                "For each integer value i from 0 to 3, do the following.",
                "If a trap-enabled exception occurs in any element of ",
                "the vector, no results are written to VSR[XT]."
            ]
        },
        {
            "description": "VSX Vector Test Data Class Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtstdcdp",
                    "regs": [ "XT,XB,DCMX" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "dx", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "4", "value": "15" },
                { "name": "dx", "size": "1" },
                { "name": "opcode", "size": "3", "value": "5" },
                { "name": "dm", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "DCMX ~ dc || dm || dx",
                "",
                "do i = 0 to 1",
                "   src            ~ VSR[32×BX+B].dword[i]",
                "   sign           ~ src.bit[0]",
                "   exponent       ~ src.bit[1:11]",
                "   fraction       ~ src.bit[12:63]",
                "",
                "   class.Infinity ~ (exponent = 0x7FF) & (fraction  = 0)",
                "   class.NaN      ~ (exponent = 0x7FF) & (fraction != 0)",
                "   class.Zero     ~ (exponent = 0x000) & (fraction  = 0)",
                "   class.Denormal ~ (exponent = 0x000) & (fraction != 0)",
                "",
                "   match          ~ (DCMX.bit[0] & class.NaN)              |",
                "                   (DCMX.bit[1] & class.Infinity & !sign) |",
                "                   (DCMX.bit[2] & class.Infinity &  sign) |",
                "                   (DCMX.bit[3] & class.Zero     & !sign) |",
                "                   (DCMX.bit[4] & class.Zero     &  sign) |",
                "                   (DCMX.bit[5] & class.Denormal & !sign) |",
                "                   (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "   if match = 1 then",
                "      VSR[32×TX+T].dword[i] ~ 0xFFFF_FFFF_FFFF_FFFF",
                "   else",
                "      VSR[32×TX+T].dword[i] ~ 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "Let XB be the sum 32×BX + B.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "VSX Vector Test Data Class Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtstdcsp",
                    "regs": [ "XT,XB,DCMX" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "T", "size": "5" },
                { "name": "dx", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "4", "value": "13" },
                { "name": "dx", "size": "1" },
                { "name": "opcode", "size": "3", "value": "5" },
                { "name": "dm", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "TX", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "DCMX ~ dc || dm || dx",
                "",
                "do i = 0 to 3",
                "   src            ~ VSR[32×BX+B].word[i]",
                "   sign           ~ src.bit[0]",
                "   exponent       ~ src.bit[1:8]",
                "   fraction       ~ src.bit[9:31]",
                "",
                "   class.Infinity ~ (exponent = 0xFF) & (fraction  = 0)",
                "   class.NaN      ~ (exponent = 0xFF) & (fraction != 0)",
                "   class.Zero     ~ (exponent = 0x00) & (fraction  = 0)",
                "   class.Denormal ~ (exponent = 0x00) & (fraction != 0)",
                "",
                "   match          ~ (DCMX.bit[0] & class.NaN)              |",
                "                   (DCMX.bit[1] & class.Infinity & !sign) |",
                "                   (DCMX.bit[2] & class.Infinity &  sign) |",
                "                   (DCMX.bit[3] & class.Zero     & !sign) |",
                "                   (DCMX.bit[4] & class.Zero     &  sign) |",
                "                   (DCMX.bit[5] & class.Denormal & !sign) |",
                "                   (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "   if match = 1 then",
                "      VSR[32×TX+T].dword[i] ~ 0xFFFF_FFFF",
                "   else",
                "      VSR[32×TX+T].dword[i] ~ 0x0000_0000",
                "end"
            ],
            "body": [
                "Let XB be the sum 32×BX + B.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "VSX Vector Test Least-Significant Bit by Byte",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtlsbb",
                    "regs": [ "BF,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "475" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ALL_TRUE  := 1 ",
                "ALL_FALSE := 1",
                "",
                "do i = 0 to 15",
                "   ALL_TRUE  := ALL_TRUE  & (VSR[XB].byte[i].bit[7]=1)",
                "   ALL_FALSE := ALL_FALSE & (VSR[XB].byte[i].bit[7]=0)",
                "end",
                "",
                "CR.field_WRITE(BF, ALL_TRUE, 0, ALL_FALSE, 0);"
            ],
            "body": [
                "Set CR field BF to indicate if bit 7 of every byte element in VSR[XB] is equal to 1 (ALL_TRUE) or equal to 0 (ALL_FALSE)."
            ]
        },
        {
            "description": "VSX Vector Test for software Divide Double-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtdivdp",
                    "regs": [ "BF,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "125" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "eq_flag := 0b0",
                "gt_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   src1    := VSR[32×AX+A].dword[i]",
                "   src2    := VSR[32×BX+B].dword[i]",
                "   e_a     := src1.bit[1:11] - 1023",
                "   e_b     := src2.bit[1:11] - 1023",
                "   fe_flag := fe_flag | IsNaN(src1) | IsInf(src1) |",
                "              IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "              ( e_b <= -1022 ) |",
                "              ( e_b >=  1021 ) |",
                "              ( !IsZero(src1) & ( (e_a - e_b) >=  1023 ) ) |",
                "              ( !IsZero(src1) & ( (e_a - e_b) <= -1021 ) ) |",
                "              ( !IsZero(src1) & ( e_a <= -970 ) )",
                "   fg_flag := fg_flag | IsInf(src1) | IsInf(src2) |",
                "              IsZero(src2) | IsDen(src2)",
                "end"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 1, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector Test for software Divide Single-Precision",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtdivsp",
                    "regs": [ "BF,XA,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "93" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "eq_flag := 0b0",
                "gt_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   src1    := VSR[32×AX+A].word[i]",
                "   src2    := VSR[32×BX+B].word[i]",
                "   e_a     := src1.bit[1:8] - 127",
                "   e_b     := src2.bit[1:8] - 127",
                "   fe_flag := fe_flag | IsNaN(src1) | IsInf(src1) |",
                "              IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "              ( e_b <= -126 ) |",
                "              ( e_b >=  125 ) |",
                "              ( !IsZero(src1) & ( (e_a - e_b) >=  127 ) ) |",
                "              ( !IsZero(src1) & ( (e_a - e_b) <= -125 ) ) |",
                "              ( !IsZero(src1) & ( e_a <= -103 ) )",
                "   fg_flag := fg_flag | IsInf(src1) | IsInf(src2) |",
                "              IsZero(src2) | IsDen(src2)",
                "end",
                "",
                "fl_flag := xvredp_error() <= 2-14",
                "CR.field[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XA be the value 32×AX + A.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 3, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector Test for software Square Root Double-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtsqrtdp",
                    "regs": [ "BF,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "234" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "fe_flag := 0b0",
                "fg_flag := 0b0",
                "",
                "do i = 0 to 1",
                "   src     := VSR[32×BX+B].dword[i]",
                "   e_b     := src2.bit[1:11] - 1023",
                "   fe_flag := fe_flag | IsNaN(src) | IsInf(src)  |",
                "              IsZero(src) | IsNeg(src) | ( e_a <= -970 )",
                "   fg_flag := fg_flag | IsInf(src) | IsZero(src) |",
                "              IsDen(src)",
                "end",
                "",
                "fl_flag := xvrsqrtedp_error() <= 2-14",
                "CR.field[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XB be the value 32×BX + B.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 1, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector Test for software Square Root Single-Precision",
            "form": "XX2-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvtsqrtsp",
                    "regs": [ "BF,XB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "60" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "reserved", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "9", "value": "170" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "fe_flag := 0b0",
                "fg_flag := 0b0",
                "",
                "do i = 0 to 3",
                "   src     := VSR[32×BX+B].word[i]",
                "   e_b     := src2.bit[1:8] - 127",
                "   fe_flag := fe_flag | IsNaN(src) | IsInf(src) |",
                "              IsZero(src) | IsNeg(src) | ( e_a <= -103 )",
                "   fg_flag := fg_flag | IsInf(src) | IsZero(src) |",
                "              IsDen(src)",
                "end",
                "",
                "fl_flag = xvrsqrtesp_error() <= 2-14",
                "CR.field[BF]  = 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "Let XB be the value 32×BX + B.",
                "fe_flag is initialized to 0.",
                "For each integer value i from 0 to 3, do the following.",
                "CR field BF is set to the value ",
                "0b1||fg_flag||fe_flag||0b0."
            ]
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update)",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "51" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2nn",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "242" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2np",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "114" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2pn",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "178" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
            "form": "XX3-form",
            "category": "Vector-Scalar Extension Facility",
            "mnemonics": [
                {
                    "mnemonic": "xvbf16ger2pp",
                    "regs": [ "AT,XA,XB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "59" },
                { "name": "AT", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "A", "size": "5" },
                { "name": "B", "size": "5" },
                { "name": "opcode", "size": "8", "value": "50" },
                { "name": "AX", "size": "1" },
                { "name": "BX", "size": "1" },
                { "name": "reserved", "size": "1" }
            ],
            "code": [

            ],
            "body": [

            ]
        },
        {
            "description": "Vector 2 Raised to the Exponent Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vexptefp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "394" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_POWER2_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Let x be any single-precision floating-point input value. ",
                "Unless x < -146 or the single-precision floating-point ",
                "result of computing 2 raised to the power x would be a ",
                "zero, an infinity, or a QNaN, the estimate has a relative ",
                "error in precision no greater than one part in 16. The ",
                "most significant 12 bits of the estimate’s significand ",
                "are monotonic. An integral input value returns an ",
                "integral value when the result is representable.",
                "The result for various special cases of the source ",
                "value is given below. "
            ]
        },
        {
            "description": "Vector AES Cipher",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcipher",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1288" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := SubBytes(State)",
                "vtemp2   := ShiftRows(vtemp1)",
                "vtemp3   := MixColumns(vtemp2)",
                "VSR[VRT+32]  := vtemp3 ^ RoundKey"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "One round of an AES cipher operation is performed on ",
                "the intermediate State array, sequentially applying the ",
                "transforms, SubBytes(), ShiftRows(), MixColumns(), ",
                "and AddRoundKey(), as defined in FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "new intermediate state of the cipher operation."
            ]
        },
        {
            "description": "Vector AES Cipher Last",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcipherlast",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1289" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := SubBytes(State)",
                "vtemp2   := ShiftRows(vtemp1)",
                "VSR[VRT+32]  := vtemp2 ^ RoundKey"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "The final round in an AES cipher operation is ",
                "performed on the intermediate State array, ",
                "sequentially applying the transforms, SubBytes(), ",
                "ShiftRows(), AddRoundKey(), as defined in FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "final state of the cipher operation."
            ]
        },
        {
            "description": "Vector AES Inverse Cipher",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vncipher",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1352" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := InvShiftRows(State)",
                "vtemp2   := InvSubBytes(vtemp1)",
                "vtemp3   := vtemp2 ^ RoundKey",
                "VSR[VRT+32]  := InvMixColumns(vtemp3)"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES inverse cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "One round of an AES inverse cipher operation is ",
                "performed on the intermediate State array, ",
                "sequentially applying the transforms, InvShiftRows(), ",
                "InvSubBytes(), AddRoundKey(), and InvMixColumns(), ",
                "as defined in FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "new intermediate state of the inverse cipher operation."
            ]
        },
        {
            "description": "Vector AES Inverse Cipher Last",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vncipherlast",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1353" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := InvShiftRows(State)",
                "vtemp2   := InvSubBytes(vtemp1)",
                "VSR[VRT+32]  := vtemp2 ^ RoundKey"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES inverse cipher ",
                "operation.",
                "Let RoundKey be the contents of VSR[VRB+32], ",
                "representing the round key.",
                "The final round in an AES inverse cipher operation is ",
                "performed on the intermediate State array, ",
                "sequentially applying the transforms, InvShiftRows(), ",
                "InvSubBytes(), and AddRoundKey(), as defined in ",
                "FIPS-197.",
                "The result is placed into VSR[VRT+32], representing the ",
                "final state of the inverse cipher operation."
            ]
        },
        {
            "description": "Vector AES SubBytes",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsbox",
                    "regs": [ "VRT,VRA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1480" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State   := VSR[VRA+32]",
                "VSR[VRT+32] := SubBytes(State)"
            ],
            "body": [
                "Let State be the contents of VSR[VRA+32], representing ",
                "the intermediate state array during AES cipher ",
                "operation.",
                "The result of applying the transform, SubBytes() on ",
                "State, as defined in FIPS-197, is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Absolute Difference Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vabsdub",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1027" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "   if src1 > src2 then ",
                "      VSR[VRT+32].byte[i] := CHOP8(src1 + ~src2 + 1)",
                "   else",
                "      VSR[VRT+32].byte[i] := CHOP8(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Absolute Difference Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vabsduh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1091" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "   if src1 > src2 then ",
                "      VSR[VRT+32].hword[i] := CHOP16(src1 + ~src2 + 1)",
                "   else",
                "      VSR[VRT+32].hword[i] := CHOP16(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Absolute Difference Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vabsduw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1155" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   if src1 > src2 then",
                "      VSR[VRT+32].word[i] := CHOP32(src1 + ~src2 + 1)",
                "   else",
                "      VSR[VRT+32].word[i] := CHOP32(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add & Write Carry-out Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddcuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "384" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "src1 := EXTZ(VSR[VRA+32].word[i])",
                "src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := CHOP32((src1 + src2) >> 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddcuq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "320" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "sum  := EXTZ(src1) + EXTZ(src2)",
                "",
                "VSR[VRT+32] := EXTZ128((src1 + src2) >> 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1 and src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Extended & write Carry-out Unsigned Quadword",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddecuq",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "61" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := EXTZ128((src1 + src2 + cin) >> 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1, src2, and cin  are ",
                "placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Extended Unsigned Quadword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddeuqm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "60" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + cin)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1, src2, and cin  ",
                "are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddfp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "10" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ADD(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add Signed Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddsbs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "768" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "src1 := EXTS(VSR[VRA+32].byte[i])",
                "src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := si8_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Add Signed Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddshs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "832" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "src1 := EXTS(VSR[VRA+32].hword[i])",
                "src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := si16_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Add Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddsws",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "896" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA].word[i])",
                "   src2 := EXTS(VSR[VRB].word[i])",
                "",
                "   VSR[VRT+32].word[i] := si32_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Add Unsigned Byte Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddubm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "0" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "src1 := EXTZ(VSR[VRA+32].byte[i])",
                "src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := CHOP8(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddubs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "512" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := ui8_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Add Unsigned Doubleword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vaddudm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "192" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "VSR[VRT+32].dword[i] := CHOP64(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Halfword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vadduhm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "64" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := CHOP16(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vadduhs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "576" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := ui16_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Add Unsigned Quadword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vadduqm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "256" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1 and src2 are ",
                "placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Add Unsigned Word Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vadduwm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "128" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := CHOP32(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Add Unsigned Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vadduws",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "640" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := ui32_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Average Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vavgsb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1282" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTS(VSR[VRA+32].byte[i])",
                "   src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "   VSR[VRT+32].byte[i] := CHOP8((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Average Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vavgsh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1346" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Average Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vavgsw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1410" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := Chop32((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Average Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vavgub",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1026" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "   VSR[VRT+32].byte[i] := CHOP8((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Average Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vavguh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1090" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Average Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vavguw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1154" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := Chop32((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Bit Permute Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vbpermd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1484" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   do j = 0 to 7 ",
                "      index := VSR[VRB+32].dword[i].byte[j]",
                "      if index < 64 then",
                "         perm.bit[j] := VSR[VRA+32].dword[i].bit[index]",
                "      else",
                "         perm.bit[j] := 0",
                "   end",
                "   VSR[VRT+32].dword[i] := EXTZ64(perm)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, and for each ",
                "integer value j from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Bit Permute Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vbpermq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1356" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   index := VSR[VRB+32].byte[i]",
                "   if index < 128 then",
                "      perm.bit[i] := VSR[VRA+32].bit[index]",
                "   else",
                "      perm.bit[i] := 0",
                "end",
                "VSR[VRT+32].dword[0] := CHOP64(EXTZ(perm))",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "The contents of bits 0:47 of VSR[VRT+32] are set to 0. ",
                "The contents of bits 64:127 of VSR[VRT+32] are set to 0. ",
                "  "
            ]
        },
        {
            "description": "Vector Centrifuge Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcfuged",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1357" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   ptr0 := 0",
                "   ptr1 := 0",
                "   do j = 0 to 63",
                "      if VSR[VRB+32].dword[i].bit[j]=0b0 then do",
                "         result.bit[ptr0] := VSR[VRA+32].dword[i].bit[j]",
                "         ptr0 := ptr0 + 1",
                "      end",
                "      if VSR[VRB+32].dword[i].bit[63-j]=1 then do",
                "         result.bit[63-ptr1] := VSR[VRA+32].dword[i].bit[63-j]",
                "         ptr1 := ptr1 + 1",
                "      end",
                "   end",
                "   VSR[VRT+32].dword[i] := result",
                "end"
            ],
            "body": [
                "For each doubleword element i of VSR[VRA+32], the ",
                "bits whose corresponding bits in the mask in ",
                "doubleword element i of VSR[VRB+32] equal 1 are ",
                "placed in the rightmost bits in doubleword element i of ",
                "VSR[VRT+32], maintaining their original relative order.  ",
                "The other bits in doubleword element i of VSR[VRA+32] ",
                "are placed in the leftmost bits in doubleword element i ",
                "of VSR[VRT+32], maintaining their original relative order."
            ]
        },
        {
            "description": "Vector Clear Leftmost Bytes",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclrlb",
                    "regs": [ "VRT,VRA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "397" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "N := (GPR[RB] > 15) ? 16: GPR[RB]",
                "",
                "do i = 0 to N-1",
                "   VSR[VRT+32].byte[15-i] := VSR[VRA+32].byte[15-i]",
                "end",
                "",
                "do i = N to 15",
                "   VSR[VRT+32].byte[15-i] := 0x00",
                "end"
            ],
            "body": [
                "Let N be the integer value in GPR[RB], or the integer ",
                "value 16 if the integer value in GPR[RB] is greater than ",
                "15.",
                "The contents of VSR[VRA+32] are placed into ",
                "VSR[VRT+32] with the leftmost 16-N bytes of VSR[VRT+32] ",
                "set to 0."
            ]
        },
        {
            "description": "Vector Clear Rightmost Bytes",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclrrb",
                    "regs": [ "VRT,VRA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "461" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "N := (GPR[RB] > 15) ? 16: GPR[RB]",
                "do i = 0 to N-1",
                "   VSR[VRT+32].byte[i] := VSR[VRA+32].byte[i]",
                "end",
                "",
                "do i = N to 15",
                "   VSR[VRT+32].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "Let N be the integer value in GPR[RB], or the integer ",
                "value 16 if the integer value in GPR[RB] is greater than ",
                "15.",
                "The contents of VSR[VRA+32] are placed into ",
                "VSR[VRT+32] with the rightmost 16-N bytes of ",
                "VSR[VRT+32] set to 0.",
                "A valid encoding of a packed decimal integer value ",
                "requires the following properties.",
                "Source operands with sign codes of 0b1010, 0b1100, ",
                "0b1110, and 0b1111 are interpreted as positive values.",
                "Source operands with sign codes of 0b1011 and 0b1101 ",
                "are interpreted as negative values.",
                "Positive and zero results are encoded with a either ",
                "sign code of 0b1100 or 0b1111, depending on the ",
                "preferred sign (indicated as an immediate operand).",
                "Negative results are encoded with a sign code of ",
                "0b1101."
            ]
        },
        {
            "description": "Vector Compare Bounds Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpbfp",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpbfp.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "966" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   le := bool_COMPARE_LE_BFP32(src1,src2)",
                "   ge := bool_COMPARE_GE_BFP32(src1,src2)",
                "   VSR[VRT+32].word[i] := ~le || ~ge || 300",
                "end",
                "if Rc=1 then do",
                "   ib := (VSR[VRT+32]=0)",
                "   CR6 := 0b00 || ib || 0b0",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set as follows.",
                " "
            ]
        },
        {
            "description": "Vector Compare Equal Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpeqfp",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpeqfp.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "198" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if bool_COMPARE_EQ_BFP32(src1,src2)=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   else",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Quadword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequq",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "455" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32]",
                "",
                "if src1 = src2 then do",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   all_false := 0",
                "end",
                "else do",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "If src1 is equal to src2, set VSR[VRT+32] to all 1s. ",
                "Otherwise, set VSR[VRT+32] to all 0s."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequb",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpequb.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "6" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Doubleword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequd",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "vcmpequd.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "199" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequh",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpequh.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "70" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Equal Unsigned Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpequw",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpequw.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "134" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if src1 = src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtfp",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtfp.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "710" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if bool_COMPARE_GT_BFP32(src1,src2)=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   else",
                "      all_true := 0",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsb",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtsb.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "774" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := EXTS(VSR[VRA+32].byte[i])",
                "   src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Doubleword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsd",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "vcmpgtsd.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "967" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].dword[i])",
                "   src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsh",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtsh.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "838" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Quadword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsq",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "903" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := EXTS(VSR[VRA+32])",
                "src2 := EXTS(VSR[VRB+32])",
                "",
                "if src1 > src2 then do",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   all_false := 0",
                "end",
                "else do",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "src1 is compared to src2.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than src2, and are set to all 0s otherwise.",
                "If Rc=1, CR field 6 is set to indicate if src1 is greater ",
                "than src2 or if src1 is not greater than src2."
            ]
        },
        {
            "description": "Vector Compare Greater Than Signed Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtsw",
                    "regs": [ "VRT,VRA,VRB", "(Rc=0)" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtsw.",
                    "regs": [ "VRT,VRA,VRB", "(Rc=1)" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "902" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtub",
                    "regs": [ "VRT,VRA,VRB", "(Rc=0)" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtub.",
                    "regs": [ "VRT,VRA,VRB", "(Rc=1)" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "518" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Doubleword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtud",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.07"
                },
                {
                    "mnemonic": "vcmpgtud.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "711" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtuh",
                    "regs": [ "VRT,VRA,VRB", "(Rc=0)" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtuh.",
                    "regs": [ "VRT,VRA,VRB", "(Rc=1)" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "582" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Quadword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtuq",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "647" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "if src1 > src2 then do",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "   all_false := 0",
                "end",
                "else do",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "   all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "src1 is compared to src2.",
                "The contents of VSR[VRT+32] are set to all 1s if src1 is ",
                "greater than src2, and are set to all 0s otherwise.",
                "If Rc=1, CR field 6 is set to indicate if src1 is greater ",
                "than src2 or if src1 is not greater than src2."
            ]
        },
        {
            "description": "Vector Compare Greater Than Unsigned Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgtuw",
                    "regs": [ "VRT,VRA,VRB", "(Rc=0)" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgtuw.",
                    "regs": [ "VRT,VRA,VRB", "(Rc=1)" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "646" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   if src1 > src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Greater Than or Equal Floating-Point",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpgefp",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v2.03"
                },
                {
                    "mnemonic": "vcmpgefp.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "454" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   if bool_COMPARE_GE_BFP32(src1,src2)=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   else",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpneb",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpneb.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "7" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   if src1 != src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpneh",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpneh.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "71" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   if src1 != src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnew",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnew.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "135" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   if src1 != src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal or Zero Byte",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnezb",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnezb.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "263" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].byte[i] := 0x00",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal or Zero Halfword",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnezh",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnezh.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "327" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Not Equal or Zero Word",
            "form": "VC-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpnezw",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "vcmpnezw.",
                    "regs": [ "VRT,VRA,VRB", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "391" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "      all_false := 0",
                "   end",
                "   else do",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "      all_true := 0",
                "   end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "If Rc=1, CR field 6 is set to indicate whether all vector ",
                "elements compared true and whether all vector ",
                "elements compared false."
            ]
        },
        {
            "description": "Vector Compare Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpsq",
                    "regs": [ "BF,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "321" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTS(VSR[VRA+32])",
                "src2 := EXTS(VSR[VRB+32])",
                "",
                "lt_flag := src1 < src2",
                "gt_flag := src1 > src2",
                "eq_flag := src1 = src2",
                "",
                "CR.field[BF] := lt_flag<<3 | gt_flag<<2 | eq_flag<<1"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "Compare src1 with src2, place the comparison flags ",
                "into CR field BF."
            ]
        },
        {
            "description": "Vector Compare Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcmpuq",
                    "regs": [ "BF,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "BF", "size": "3" },
                { "name": "reserved", "size": "2" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "257" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "lt_flag := src1 < src2",
                "gt_flag := src1 > src2",
                "eq_flag := src1 = src2",
                "",
                "CR.field[BF] := lt_flag<<3 | gt_flag<<2 | eq_flag<<1"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "Compare src1 with src2, place the comparison flags ",
                "into CR field BF."
            ]
        },
        {
            "description": "Vector Convert with round to nearest From Signed Word to floating-point format",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcfsx",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "UIM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "842" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_CONVERT_FROM_SI32(src,UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Convert with round to nearest From Unsigned Word to floating-point format",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcfux",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "UIM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "778" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_CONVERT_FROM_UI32(src,UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                ""
            ]
        },
        {
            "description": "Vector Convert with round to zero from floating-point  To Unsigned Word format Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctuxs",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "UIM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "906" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := ui32_CONVERT_FROM_BFP32(src, UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Convert with round to zero from floating-point To Signed Word format Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctsxs",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "UIM", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "970" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := si32_CONVERT_FROM_BFP32(src, UIM)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zero Least-Significant Bits Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclzlsbb",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count := 0",
                "do while count < 16",
                "   if VSR[VRB+32].byte[count].bit[7]=1 break",
                "   count := count + 1",
                "end",
                "GPR[RT] := EXTZ64(count)"
            ],
            "body": [
                "Let count be the number of contiguous leading byte ",
                "elements in VSR[VRB+32] having a zero least-significant ",
                "bit.",
                "count is placed into GPR[RT]."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclzb",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1794" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   n := 0",
                "   do while n < 8",
                "      if VSR[VRB+32].byte[i].bit[n] = 0b1 then leave ",
                "      n := n + 1",
                "   end",
                "   VSR[VRT+32].byte[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclzd",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1986" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   n := 0",
                "   do while (n<64) & (VSR[VRB+32].dword[i].bit[n]=0b0)",
                "      n := n + 1",
                "   end",
                "   VSR[VRT+32].dword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Doubleword under bit Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclzdm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1924" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   count := 0",
                "   do j = 0 to 63",
                "      if VSR[VRB+32].dword[i].bit[j]=1 then do",
                "         if VSR[VRA+32].dword[i].bit[i]=1 then break",
                "         count := count + 1",
                "      end",
                "   end",
                "   VSR[VRT+32].dword[i] := EXTZ64(count)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, starting on the ",
                "left, count the number of consecutive 0 bits in ",
                "doubleword element i of VSR[VRA+32] corresponding to ",
                "1 bits in doubleword element i of VSR[VRB+32]. Place ",
                "count in doubleword element i of VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclzh",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1858" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   n  := 0",
                "   do while n < 16",
                "      if VSR[VRB+32].hword[i].bit[n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].hword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Count Leading Zeros Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vclzw",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1922" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   n  := 0",
                "   do while n < 32",
                "      if VSR[VRB+32].word[i].bit[n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].word[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Count Mask Bits Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbb",
                    "regs": [ "RT,VRB,MP" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "4", "value": "12" },
                { "name": "MP", "size": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 15",
                "   count := count + EXTZ8(VSR[VRB+32].byte[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count << 56"
            ],
            "body": [
                "The number of byte elements having bit 0 set to the ",
                "value MP in VSR[VRB+32] is placed into bits 0:7 of ",
                "GPR[RT]. Bits 8:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Mask Bits Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbd",
                    "regs": [ "RT,VRB,MP" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "4", "value": "15" },
                { "name": "MP", "size": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 1",
                "   count := count + EXTZ64(VSR[VRB+32].dword[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count << 59"
            ],
            "body": [
                "The number of doubleword elements having bit 0 set ",
                "to the value MP in VSR[VRB+32] is placed into bits 0:4 of ",
                "GPR[RT]. Bits 5:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Mask Bits Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbh",
                    "regs": [ "RT,VRB,MP" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "4", "value": "13" },
                { "name": "MP", "size": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 7",
                "   count := count + EXTZ64(VSR[VRB+32].hword[i].bit[0]=MP)",
                "",
                "GPR[RT] := count << 57"
            ],
            "body": [
                "The number of halfword elements having bit 0 set to ",
                "the value MP in VSR[VRB+32] is placed into bits 0:6 of ",
                "GPR[RT]. Bits 7:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Mask Bits Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vcntmbw",
                    "regs": [ "RT,VRB,MP" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "4", "value": "14" },
                { "name": "MP", "size": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 3",
                "   count := count + EXTZ64(VSR[VRB+32].word[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count << 58"
            ],
            "body": [
                "The number of word elements having bit 0 set to the ",
                "value MP in VSR[VRB+32] is placed into bits 0:5 of ",
                "GPR[RT]. Bits 6:63 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Count Trailing Zero Least-Significant Bits Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctzlsbb",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count := 0",
                "do while count < 16",
                "   if VSR[VRB+32].byte[15-count].bit[7]=1 break",
                "   count := count + 1",
                "end",
                "GPR[RT] := EXTZ64(count)"
            ],
            "body": [
                "Let count be the number of contiguous trailing byte ",
                "elements of VSR[VRB+32] having a zero least-significant ",
                "bit.",
                "count is placed into GPR[RT]."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctzb",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "28" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   n := 0",
                "   do while n < 8",
                "      if VSR[VRB+32].byte[i].bit[7-n] = 0b1 then leave ",
                "      n := n + 1",
                "   end",
                "   VSR[VRT+32].byte[i] := CHOP8(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctzd",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "31" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   n  := 0",
                "   do while n < 64",
                "      if VSR[VRB+32].dword[i].bit[63-n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Doubleword under bit Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctzdm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1988" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   count := 0",
                "   do j = 0 to 63",
                "      if VSR[VRB+32].dword[i].bit[63-j]=1 then do",
                "         if VSR[VRA+32].dword[i].bit[63-i]=1 then break",
                "         count := count + 1",
                "      end",
                "   end",
                "   VSR[VRT+32].dword[i] := EXTZ64(count)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, starting on the ",
                "right, count the number of consecutive 0 bits in ",
                "doubleword element i of VSR[VRA+32] corresponding to ",
                "1 bits in doubleword element i of VSR[VRB+32]. Place ",
                "count in doubleword element i of VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctzh",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "29" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   n  := 0",
                "   do while n < 16",
                "      if VSR[VRB+32].hword[i].bit[15-n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].hword[i] := CHOP16(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Count Trailing Zeros Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vctzw",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "30" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   n  := 0",
                "   do while n < 32",
                "      if VSR[VRB+32].word[i].bit[31-n] = 0b1 then leave ",
                "      n  := n + 1",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(EXTZ(n))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivesd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "971" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTS(VSR[VRA+32].dword[i]) << 64",
                "   divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivesq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "779" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32]) << 128",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend ÷ divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32] ",
                "concatenated with 128 0s.",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique signed integer that satisfies",
                "where 0 £ r < |divisor| if dividend is nonnegative, ",
                "and |divisor| < r £ 0 if dividend is negative.",
                "If the quotient cannot be represented in 128 bits, or if ",
                "an attempt is made to perform the division ",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Extended Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivesw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "907" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTS(VSR[VRA+32].word[i]) << 32",
                "   divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdiveud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "715" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTZ(VSR[VRA+32].dword[i]) << 64",
                "   divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Extended Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdiveuq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "523" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32]) << 128",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend ÷ divisor)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32] ",
                "concatenated with 128 0s.",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique unsigned integer that ",
                "satisfies",
                "where 0 £ r < divisor.",
                "If the quotient cannot be represented in 128 bits, or if ",
                "an attempt is made to perform the division",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Extended Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdiveuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "651" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTZ(VSR[VRA+32].word[i]) << 32",
                "   divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivsd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "459" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTS(VSR[VRA+32].dword[i])",
                "   divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivsq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "267" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32])",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend ÷ divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique signed integer that satisfies",
                "where 0£r<|divisor| if the dividend is ",
                "nonnegative, and -|divisor|<r£0 if the dividend is ",
                "negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivsw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "395" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTS(VSR[VRA+32].word[i])",
                "   divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Divide Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "203" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTZ(VSR[VRA+32].dword[i])",
                "   divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Divide Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivuq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "11" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32])",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend ÷ divisor)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "The quotient of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The quotient is the unique unsigned integer that ",
                "satisfies",
                "where 0£r<divisor.",
                "If an attempt is made to perform the division",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Divide Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vdivuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "139" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTZ(VSR[VRA+32].word[i])",
                "   divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend ÷ divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Expand Byte Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vexpandbm",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   if VSR[VRB+32].byte[i].bit[0]=1 then",
                "      VSR[VRT+32].byte[i] := 0xFF",
                "   end",
                "      VSR[VRT+32].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Expand Doubleword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vexpanddm",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "3" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   if VSR[VRB+32].dword[i].bit[0]=1 then",
                "      VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "   else",
                "      VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Expand Halfword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vexpandhm",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   if VSR[VRB+32].hword[i].bit[0]=1 then",
                "      VSR[VRT+32].hword[i] := 0xFFFF",
                "   else",
                "      VSR[VRT+32].hword[i] := 0x0000",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Expand Quadword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vexpandqm",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if VSR[VRB+32].bit[0]=1 then",
                "   VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "else",
                "   VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000"
            ],
            "body": [
                "Let bmi be the contents of bit 0 of VSR[VRB+32].",
                "The contents of VSR[VRT+32] are set to all 0s if bmi is ",
                "equal to 0.",
                "The contents of VSR[VRT+32] are set to all 1s if bmi is ",
                "equal to 1."
            ]
        },
        {
            "description": "Vector Expand Word Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vexpandwm",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   if VSR[VRB+32].word[i].bit[0]=1 then",
                "      VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "   else",
                "      VSR[VRT+32].word[i] := 0x0000_0000",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Byte To Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextsb2d",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "24" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[VRB+32].dword[i].bit[56:63]",
                "",
                "   VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Byte To Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextsb2w",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "16" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i].bit[24:31]",
                "",
                "   VSR[VRT+32].word[i] := EXTS32(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Doubleword to Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextsd2q",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "27" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := EXTS128(VSR[VRB+32].bit[64:127])"
            ],
            "body": [
                "The signed integer in bits 64:127 of VSR[VRB+32] is ",
                "signed extended to 128 bits and placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Extend Sign Halfword To Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextsh2d",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "25" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[VRB+32].dword[i].bit[48:63]",
                "",
                "   VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Halfword To Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextsh2w",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "17" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i].bit[16:31]",
                "",
                "   VSR[VRT+32].word[i] := EXTS32(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Extend Sign Word To Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextsw2d",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "26" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := VSR[VRB+32].dword[i].bit[32:63]",
                "",
                "   VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Extract Byte Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractbm",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "8" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   GPR[RT].bit[48+i] := VSR[VRB+32].byte[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:47] := 0"
            ],
            "body": [
                "The contents of bit 0 of each byte element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "48:63 of GPR[RT]. Bits 0:47 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Double Doubleword to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextddvlx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "30" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := src.byte[index:index+7]",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements index:index+7 of src ",
                "are placed into doubleword 0 of VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 24, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Doubleword to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextddvrx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "31" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := src.byte[24-index:31-index]",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements 24-index:31-index of ",
                "src are placed into doubleword 0 of VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 24, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Byte to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextdubvlx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "24" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte element index of vsrc are ",
                "zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Byte to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextdubvrx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "25" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte element 31-index of vsrc are ",
                "zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Halfword to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextduhvlx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "26" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[index:index+1])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements index:index+1 of vsrc ",
                "are zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 30, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Halfword to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextduhvrx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "27" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[30-index:31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements 30-index:31-index of ",
                "vsrc are zero-extended and placed into doubleword 0 ",
                "of VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 30, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Word to VSR using GPR -specified Left-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextduwvlx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "28" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src.byte[index:index+3])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements index:index+3 of src ",
                "are zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 28, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Double Unsigned Word to VSR using GPR -specified Right-Index",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextduwvrx",
                    "regs": [ "VRT,VRA,VRB,RC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "RC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "29" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src.byte[28-index:31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "Let src be the concatenation of the contents of ",
                "VSR[VRA+32] and VSR[VRB+32].",
                "The contents of byte elements 28-index:31-index of ",
                "src are zero-extended and placed into doubleword 0 of ",
                "VSR[VRT+32].",
                "The contents of doubleword 1 of VSR[VRT+32] are set to ",
                "0.",
                "If index is greater than 28, the result is undefined."
            ]
        },
        {
            "description": "Vector Extract Doubleword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractdm",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "11" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   GPR[RT].bit[62+i] := VSR[VRB+32].dword[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:61] := 0"
            ],
            "body": [
                "The contents of bit 0 of each doubleword element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "62:63 of GPR[RT]. Bits 0:61 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Doubleword to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractd",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "717" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+7]",
                "",
                "VSR[VRT+32].dword[0] := src",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte elements UIM:UIM+7 of ",
                "VSR[VRB+32]  are placed into VSR[VRT+32]. The contents ",
                "of doubleword element 1 of VSR[VRT+32] are set to 0.",
                "If the value of UIM is greater than 8, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Halfword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextracthm",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "9" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   GPR[RT].bit[56+i] := VSR[VRB+32].hword[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:55] := 0"
            ],
            "body": [
                "The contents of bit 0 of each halfword element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "56:63 of GPR[RT]. Bits 0:55 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Quadword Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractqm",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "12" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RT] := EXTZ64(VSR[VRB+32].bit[0])"
            ],
            "body": [
                "The contents of bit 0 of VSR[VRB+32] are placed into bit ",
                "63 of GPR[RT]. Bits 0:62 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Byte to GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextublx",
                    "regs": [ "RT,RA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1549" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte element index of VSR[VRB+32] are ",
                "placed into bits 56:63 of GPR[RT].",
                "The contents of bits 0:55 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Byte to GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextubrx",
                    "regs": [ "RT,RA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1805" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[15-index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte element 15-index of VSR[VRB+32] ",
                "are placed into bits 56:63 of GPR[RT].",
                "The contents of bits 0:55 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Byte to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractub",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "525" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte element UIM of VSR[VRB+32] are ",
                "placed into bits 56:63 of VSR[VRT+32]. The contents of ",
                "the remaining byte elements of VSR[VRT+32] are set to ",
                "0."
            ]
        },
        {
            "description": "Vector Extract Unsigned Halfword to GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextuhlx",
                    "regs": [ "RT,RA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1613" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index:index+1])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements index:index+1 of ",
                "VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
                "The contents of bits 0:47 of GPR[RT] are set to 0.",
                "If the value of index is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Halfword to GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextuhrx",
                    "regs": [ "RT,RA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1869" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[14-index:15-index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements 14-index:15-index of ",
                "VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
                "The contents of bits 0:47 of GPR[RT] are set to 0.",
                "If the value of index is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Halfword to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractuh",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "589" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+1]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte elements UIM:UIM+1 of ",
                "VSR[VRB+32] are placed into halfword element 3 of ",
                "VSR[VRT+32]. The contents of the remaining halfword ",
                "elements of VSR[VRT+32] are set to 0.",
                "If the value of UIM is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Word to GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextuwlx",
                    "regs": [ "RT,RA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1677" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index:index+3])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements index:index+3 of ",
                "VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
                "The contents of bits 0:31 of GPR[RT] are set to 0.",
                "If the value of index is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Word to GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextuwrx",
                    "regs": [ "RT,RA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1933" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[12-index:15-index])"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of byte elements index:index+3 of ",
                "VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
                "The contents of bits 0:31 of GPR[RT] are set to 0.",
                "If the value of index is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Unsigned Word to VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractuw",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "653" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+3]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "The contents of byte elements UIM:UIM+3 of ",
                "VSR[VRB+32] are placed into word element 1 of ",
                "VSR[VRT+32]. The contents of the remaining word ",
                "elements of VSR[VRT+32] are set to 0.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Extract Word Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vextractwm",
                    "regs": [ "RT,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "10" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1602" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   GPR[RT].bit[60+i] := VSR[VRB+32].word[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:59] := 0"
            ],
            "body": [
                "The contents of bit 0 of each word element of ",
                "VSR[VRB+32] are concatenated and placed into bits ",
                "60:63 of GPR[RT]. Bits 0:59 of GPR[RT] are set to 0."
            ]
        },
        {
            "description": "Vector Gather Bits by Bytes by Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vgbbd",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1292" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "    do j = 0 to 7",
                "        do k = 0 to 7",
                "            b := VSR[VRB+32].dword[i].byte[k].bit[j]",
                "            VSR[VRT+32].dword[i].byte[j].bit[k] := b",
                "        end",
                "    end",
                "end"
            ],
            "body": [
                "Let src be the contents of VSR[VRB+32], composed of ",
                "two doubleword elements numbered 0 and 1.",
                "Let each doubleword element be composed of eight ",
                "bytes  numbered 0 through 7.",
                "An 8-bit × 8-bit bit-matrix transpose is performed on ",
                "the contents of each doubleword element of ",
                "VSR[VRB+32] (see Figure 106).",
                "For each integer value i from 0 to 1, do the following,"
            ]
        },
        {
            "description": "Vector Gather every Nth Bit",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vgnb",
                    "regs": [ "RT,VRB,N" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "RT", "size": "5" },
                { "name": "reserved", "size": "2" },
                { "name": "N", "size": "3" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1228" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "if N<2 | N>7 then",
                "   result := UNDEFINED",
                "else do",
                "   j := 0",
                "   result := 0x0000_0000_0000_0000",
                "   do i = 0 to 127 by N",
                "      result.bit[j] := VSR[VRB+32].bit[i]",
                "      j := j + 1",
                "   end",
                "end",
                "GPR[RT] := result"
            ],
            "body": [
                "Starting with bit 0, the contents of every Nth bit of ",
                "VSR[VRB+32] are concatenated and placed into GPR[RT].",
                "N can be any value between 2 and 7, inclusive."
            ]
        },
        {
            "description": "Vector Insert Byte from GPR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsblx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "527" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index] := GPR[RB].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of GPR[RB] are placed into ",
                "byte element index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsbrx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "783" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[15-index] := GPR[RB].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of GPR[RB] are placed into ",
                "byte element 15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from VSR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsbvlx",
                    "regs": [ "VRT,RA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "15" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index] := VSR[VRB+32].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of VSR[VRB+32] are placed ",
                "into byte element index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from VSR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsbvrx",
                    "regs": [ "VRT,RA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "271" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[15-index] := VSR[VRB+32].bit[56:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 56:63 of VSR[VRB+32] are placed ",
                "into byte element 15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified."
            ]
        },
        {
            "description": "Vector Insert Byte from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsertb",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "781" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM] := VSR[VRB+32].byte[7]"
            ],
            "body": [
                "The contents of byte element 7 of VSR[VRB+32] are ",
                "placed into byte element UIM of VSR[VRT+32]. The ",
                "contents of the remaining byte elements of ",
                "VSR[VRT+32] are not modified."
            ]
        },
        {
            "description": "Vector Insert Doubleword from GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsdlx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "719" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+7] := GPR[RB]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of GPR[RB] are placed into byte elements ",
                "index:index+7 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 8, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Doubleword from GPR using GPR-specified Right-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsdrx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "975" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[8-index:15-index] := GPR[RB]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of GPR[RB] are placed into byte elements ",
                "8-index:15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 8, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Doubleword from GPR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsd",
                    "regs": [ "VRT,RB,UIM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "463" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32].byte[UIM:UIM+7] := GPR[RB]"
            ],
            "body": [
                "The contents of GPR[RB] are placed into byte elements ",
                "UIM:UIM+7 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If UIM is greater than 8, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Doubleword from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsertd",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "973" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+7] := VSR[VRB+32].dword[0]"
            ],
            "body": [
                "The contents of doubleword element 0 of VSR[VRB+32] ",
                "are placed into byte elements UIM:UIM+7 of ",
                "VSR[VRT+32]. The contents of the remaining byte ",
                "elements of VSR[VRT+32] are not modified.",
                "If the value of UIM is greater than 8, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from GPR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinshlx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "591" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index:index+1] := GPR[RB].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of GPR[RB] are placed into ",
                "byte elements index:index+1 of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinshrx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "847" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[14-index:15-index] := GPR[RB].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of GPR[RB] are placed into ",
                "byte elements 14-index:15-index of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from VSR using GPR-specified Left - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinshvlx",
                    "regs": [ "VRT,RA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "79" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index:index+1] := VSR[VRB+32].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of VSR[VRB+32] are placed ",
                "into byte elements index:index+1 of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from VSR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinshvrx",
                    "regs": [ "VRT,RA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "335" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[14-index:15-index] := VSR[VRB+32].bit[48:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 48:63 of VSR[VRB+32] are placed ",
                "into byte elements 14-index:15-index of VSR[VRT+32].",
                "If index is greater than 14, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Halfword from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinserth",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "845" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+1] := VSR[VRB+32].hword[3]"
            ],
            "body": [
                "The contents of halfword element 3 of VSR[VRB+32] are ",
                "placed into byte elements UIM:UIM+1 of VSR[VRT+32]. ",
                "The contents of the remaining byte elements of ",
                "VSR[VRT+32] are not modified.",
                "If the value of UIM is greater than 14, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Insert Word from GPR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinswlx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "655" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+3] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of GPR[RB] are placed into ",
                "byte elements index:index+3 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from GPR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinswrx",
                    "regs": [ "VRT,RA,RB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "911" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[12-index:15-index] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of GPR[RB] are placed into ",
                "byte elements 12-index:15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from GPR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsw",
                    "regs": [ "VRT,RB,UIM" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "207" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32].byte[UIM:UIM+3] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "The contents of bits 32:63 of GPR[RB] are placed into ",
                "byte elements UIM:UIM+3 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If UIM is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from VSR using GPR-specified Left-Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinswvlx",
                    "regs": [ "VRT,RA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "143" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+3] := VSR[VRB+32].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of VSR[VRB+32] are placed ",
                "into byte elements index:index+3 of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from VSR using GPR-specified Right - Index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinswvrx",
                    "regs": [ "VRT,RA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "399" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[12-index:15-index] := VSR[VRB+32].bit[32:63]"
            ],
            "body": [
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "The contents of bits 32:63 of VSR[VRB+32] are placed ",
                "into byte elements 12-index:15-index of VSR[VRT+32].",
                "All other byte elements of VSR[VRT+32] are not ",
                "modified.",
                "If index is greater than 12, the result is undefined."
            ]
        },
        {
            "description": "Vector Insert Word from VSR using immediate-specified index",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vinsertw",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "909" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+3] := VSR[VRB+32].word[1]"
            ],
            "body": [
                "The contents of word element 1 of VSR[VRB+32] are ",
                "placed into byte elements UIM:UIM+3 of VSR[VRT+32]. ",
                "The contents of the remaining byte elements of ",
                "VSR[VRT+32] are not modified.",
                "If the value of UIM is greater than 12, the results are ",
                "undefined."
            ]
        },
        {
            "description": "Vector Log Base 2 Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vlogefp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "458" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_LOG_BASE2_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Let x be any single-precision floating-point input value. ",
                "Unless | x-1 | is less than or equal to 0.125 or the ",
                "single-precision floating-point result of computing the ",
                "base 2 logarithm of x would be an infinity or a QNaN, ",
                "the estimate has an absolute error in precision ",
                "(absolute value of the difference between the estimate ",
                "and the infinitely precise value) no greater than 2-5. ",
                "Under the same conditions, the estimate has a relative ",
                "error in precision no greater than one part in 8.",
                "The most significant 12 bits of the estimate’s ",
                "significand are monotonic. The estimate is exact if ",
                "x=2y, where y is an integer between -149 and +127 ",
                "inclusive. Otherwise the value placed into the element ",
                "of VSR[VRT+32] may vary between implementations, ",
                "and between different executions on the same ",
                "implementation.",
                "The result for various special cases of the source ",
                "value is given below.  "
            ]
        },
        {
            "description": "Vector Logical AND",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vand",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1028" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] & VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ANDed with the ",
                "contents of VSR[VRB+32] and the result is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical AND with Complement",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vandc",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1092" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] & ~VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ANDed with the ",
                "complement of the contents of VSR[VRB+32] and the ",
                "result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical Equivalence",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "veqv",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1668" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] == VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are XORed with the ",
                "contents of VSR[VRB+32] and the complemented result ",
                "is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical NAND",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vnand",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1412" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := ~( VSR[VRA+32] & VSR[VRB+32] )"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ANDed with the ",
                "contents of VSR[VRB+32] and the complemented result ",
                "is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical NOR",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vnor",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1284" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := ~( VSR[VRA+32] | VSR[VRB+32] )"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ORed with the ",
                "contents of VSR[VRB+32] and the complemented result ",
                "is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical OR",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vor",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1156" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] | VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ORed with the ",
                "contents of VSR[VRB+32] and the result is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical OR with Complement",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vorc",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1348" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] | ~VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are ORed with the ",
                "complement of the contents of VSR[VRB+32] and the ",
                "result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Logical XOR",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vxor",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1220" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] ^ VSR[VRB+32]"
            ],
            "body": [
                "The contents of VSR[VRA+32] are XORed with the ",
                "contents of VSR[VRB+32] and the result is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Maximum Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxfp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1034" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_MAXIMUM(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "The maximum of +0.0 and -0.0 is +0.0. The maximum ",
                "of any value and a NaN is a QNaN."
            ]
        },
        {
            "description": "Vector Maximum Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "258" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   gt_flag := EXTS(src1) > EXTS(src2)",
                "   VSR[VRT+32].byte[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Maximum Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "450" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   gt_flag := EXTS(src1) > EXTS(src2)",
                "   VSR[VRT+32].dword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Maximum Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "322" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   gt_flag := EXTS(src1) > EXTS(src2)",
                "   VSR[VRT+32].hword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Maximum Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxsw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "386" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   gt_flag := EXTS(src1) > EXTS(src2)",
                "   VSR[VRT+32].word[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxub",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "2" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   gt_flag := EXTZ(src1) > EXTZ(src2)",
                "   VSR[VRT+32].byte[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "194" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   gt_flag := EXTZ(src1) > EXTZ(src2)",
                "   VSR[VRT+32].dword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxuh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "66" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   gt_flag := EXTZ(src1) > EXTZ(src2)",
                "   VSR[VRT+32].hword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Maximum Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaxuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "130" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   gt_flag := EXTZ(src1) > EXTZ(src2)",
                "   VSR[VRT+32].word[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Merge Even Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrgew",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1932" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[0]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[0]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[2]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[2]"
            ],
            "body": [

            ]
        },
        {
            "description": "Vector Merge High Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrghb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "12" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i].byte[0] := VSR[VRA+32].byte[i]",
                "   VSR[VRT+32].hword[i].byte[1] := VSR[VRB+32].byte[i]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Merge High Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrghh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "76" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i].hword[0] := VSR[VRA+32].hword[i]",
                "   VSR[VRT+32].word[i].hword[1] := VSR[VRB+32].hword[i]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Merge High Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrghw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "140" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[0]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[0]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[1]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[1]"
            ],
            "body": [

            ]
        },
        {
            "description": "Vector Merge Low Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrglb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "268" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i].byte[0] := VSR[VRA+32].byte[i+8]",
                "   VSR[VRT+32].hword[i].byte[1] := VSR[VRB+32].byte[i+8]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Merge Low Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrglh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "332" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i].hword[0] := VSR[VRA+32].hword[i+4]",
                "   VSR[VRT+32].word[i].hword[1] := VSR[VRB+32].hword[i+4]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Merge Low Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrglw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "396" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[2]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[2]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[3]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[3]"
            ],
            "body": [

            ]
        },
        {
            "description": "Vector Merge Odd Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmrgow",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1676" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[1]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[1]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[3]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[3]"
            ],
            "body": [

            ]
        },
        {
            "description": "Vector Minimum Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminfp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1098" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_MINIMUM(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "The minimum of +0.0 and -0.0 is -0.0. The minimum ",
                "of any value and a NaN is a QNaN."
            ]
        },
        {
            "description": "Vector Minimum Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminsb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "770" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   lt_flag := EXTS(src1) < EXTS(src2)",
                "   VSR[VRT+32].byte[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Minimum Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminsd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "962" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   lt_flag := EXTS(src1) < EXTS(src2)",
                "   VSR[VRT+32].dword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Minimum Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminsh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "834" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   lt_flag := EXTS(src1) < EXTS(src2)",
                "   VSR[VRT+32].hword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Minimum Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminsw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "898" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   lt_flag := EXTS(src1) < EXTS(src2)",
                "   VSR[VRT+32].word[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminub",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "514" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i]",
                "",
                "   lt_flag := EXTZ(src1) < EXTZ(src2)",
                "   VSR[VRT+32].byte[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "706" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i]",
                "",
                "   lt_flag := EXTZ(src1) < EXTZ(src2)",
                "   VSR[VRT+32].dword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminuh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "578" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i]",
                "",
                "   lt_flag := EXTZ(src1) < EXTZ(src2)",
                "   VSR[VRT+32].hword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Minimum Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vminuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "642" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "",
                "   lt_flag := EXTZ(src1) < EXTZ(src2)",
                "   VSR[VRT+32].word[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Modulo Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmodsd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1995" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTS(VSR[VRA+32].dword[i])",
                "   divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Modulo Signed Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmodsq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1803" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32])",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend % divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "The remainder of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The remainder is the unique signed integer that ",
                "satisfies",
                "remainder = dividend - (quotient × divisor)",
                "where 0£remainder<|divisor| if the dividend is ",
                "nonnegative, and -|divisor|<remainder£0 if the ",
                "dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "<anything> % 0",
                "0x8000_0000_0000_0000 % -1",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Modulo Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmodsw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1931" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTS(VSR[VRA+32].word[i])",
                "   divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Modulo Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmodud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1739" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   dividend := EXTZ(VSR[VRA+32].dword[i])",
                "   divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Modulo Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmoduq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1547" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32])",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend % divisor)"
            ],
            "body": [
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "The remainder of src1 divided by src2 is placed into ",
                "VSR[VRT+32].",
                "The remainder is the unique signed integer that ",
                "satisfies",
                "remainder = dividend - (quotient × divisor)",
                "where 0 £ remainder < divisor.",
                "If an attempt is made to perform any of the divisions",
                "<anything> % 0",
                "then the contents of VSR[VRT+32] are undefined."
            ]
        },
        {
            "description": "Vector Modulo Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmoduw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1675" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   dividend := EXTZ(VSR[VRA+32].word[i])",
                "   divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(dividend % divisor)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulesb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "776" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].byte[2×i])",
                "   src2 := EXTS(VSR[VRB+32].byte[2×i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulesd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "968" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := EXTS(VSR[VRA+32].dword[0])",
                "src2 := EXTS(VSR[VRB+32].dword[0])",
                "",
                "VSR[VRT+32] := CHOP128(src1 × src2)"
            ],
            "body": [
                "Let src1 be the signed integer value in doubleword ",
                "element 0 of VSR[VRA+32].",
                "Let src2 be the signed integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulesh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "840" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].hword[2×i])",
                "   src2 := EXTS(VSR[VRB+32].hword[2×i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulesw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "904" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].word[2×i])",
                "   src2 := EXTS(VSR[VRB+32].word[2×i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuleub",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "520" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].byte[2×i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[2×i])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuleud",
                    "regs": [ "VRT", ",VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "712" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32].dword[0])",
                "src2 := EXTZ(VSR[VRB+32].dword[0])",
                "",
                "VSR[VRT+32] := CHOP128(src1 × src2)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in doubleword ",
                "element 0 of VSR[VRA+32].",
                "Let src2 be the unsigned integer value in doubleword ",
                "element 0 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuleuh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "584" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].hword[2×i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[2×i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Even Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuleuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "648" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].word[2×i])",
                "   src2 := EXTZ(VSR[VRB+32].word[2×i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulhsd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "969" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].dword[i])",
                "   src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64((src1 × src2) >> 64)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulhsw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "905" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32((src1 × src2) >> 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulhud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "713" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64((src1 × src2) >> 64)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply High Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulhuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "649" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32((src1 × src2) >> 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Low Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulld",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "457" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].dword[i])",
                "   src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulosb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "264" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].byte[2×i+1])",
                "   src2 := EXTS(VSR[VRB+32].byte[2×i+1])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulosd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "456" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTS(VSR[VRA+32].dword[1])",
                "src2 := EXTS(VSR[VRB+32].dword[1])",
                "",
                "VSR[VRT+32] := CHOP128(src1 × src2)"
            ],
            "body": [
                "Let src1 be the signed integer value in doubleword ",
                "element 1 of VSR[VRA+32].",
                "Let src2 be the signed integer value in doubleword ",
                "element 1 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulosh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "328" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].hword[2×i+1])",
                "   src2 := EXTS(VSR[VRB+32].hword[2×i+1])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulosw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "392" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTS(VSR[VRA+32].word[2×i+1])",
                "   src2 := EXTS(VSR[VRB+32].word[2×i+1])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuloub",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "8" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].byte[2×i+1])",
                "   src2 := EXTZ(VSR[VRB+32].byte[2×i+1])",
                "",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuloud",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "200" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := EXTZ(VSR[VRA+32].dword[1])",
                "src2 := EXTZ(VSR[VRB+32].dword[1])",
                "",
                "VSR[VRT+32] := CHOP128(src1 × src2)"
            ],
            "body": [
                "Let src1 be the unsigned integer value in doubleword ",
                "element 1 of VSR[VRA+32].",
                "Let src2 be the unsigned integer value in doubleword ",
                "element 1 of VSR[VRB+32].",
                "The 128-bit product of src1 multiplied by src2 is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulouh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "72" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].hword[2×i+1])",
                "   src2 := EXTZ(VSR[VRB+32].hword[2×i+1])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply Odd Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmulouw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "136" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].word[2×i+1])",
                "   src2 := EXTZ(VSR[VRB+32].word[2×i+1])",
                "",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Multiply Unsigned Word Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmuluwm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "137" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(src1 × src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                " "
            ]
        },
        {
            "description": "Vector Multiply-Add Floating-Point",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmaddfp",
                    "regs": [ "VRT,VRA,VRC,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "46" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   src3 := VSR[VRC+32].word[i]",
                "   result := bfp32_MULTIPLY_ADD(src1,src3,src2)",
                "   VSR[VRT+32].word[i] := result",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                " "
            ]
        },
        {
            "description": "Vector Multiply-High-Add Signed Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmhaddshs",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "32" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "   src3 := EXTS(VSR[VRC+32].hword[i])",
                "",
                "   result := ((src1 × src2)) >> 15) + src3 ",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(result)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply-High-Round-Add Signed Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmhraddshs",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "33" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "   src3 := EXTS(VSR[VRC+32].hword[i])",
                "",
                "   result := (((src1 × src2) + 0x0000_4000) >> 15) + src3",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(result)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Low-Add Unsigned Halfword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmladduhm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "34" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "   src3 := EXTZ(VSR[VRC+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := CHOP16((src1 × src2) + src3)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Multiply-Sum & write Carry-out Unsigned Doubleword",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumcud",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "23" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTZ(VSR[VRC+32])",
                "do i = 0 to 1",
                "   src1  := EXTZ(VSR[VRA+32].dword[i])",
                "   src2  := EXTZ(VSR[VRB+32].dword[i])",
                "   temp := temp + (src1 × src2)",
                "end",
                "",
                "VSR[VRT+32] := CHOP128(temp >> 128)"
            ],
            "body": [
                "Let prod0 be the quadword product of the unsigned ",
                "integer values in doubleword element 0 of VSR[VRA+32] ",
                "and doubleword element 0 of VSR[VRB+32]. ",
                "Let prod1 be the quadword product of the unsigned ",
                "integer values in doubleword element 1 of VSR[VRA+32] ",
                "and doubleword element 1 of VSR[VRB+32]. ",
                "The carry out of the low-order 128 bits of the sum of ",
                "prod0, prod1, and the unsigned integer value in ",
                "VSR[VRC+32] is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-Sum Mixed Byte Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsummbm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "37" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRC+32].word[i])",
                "   do j = 0 to 3",
                "      src1 := EXTS(VSR[VRA+32].word[i].byte[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].byte[j])",
                "      temp := temp + (src1 × src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Signed Halfword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumshm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "40" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTS(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTS(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + (src1 × src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Signed Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumshs",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "41" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTS(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTS(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + (src1 × src2)",
                "   end",
                "   VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Byte Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumubm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "36" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRC+32].word[i])",
                "   do j = 0 to 3",
                "      src1 := EXTZ(VSR[VRA+32].word[i].byte[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].byte[j])",
                "      temp := temp + (src1 × src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Doubleword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumudm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "35" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTZ(VSR[VRC+32])",
                "do i = 0 to 1",
                "   src1  := EXTZ(VSR[VRA+32].dword[i])",
                "   src2  := EXTZ(VSR[VRB+32].dword[i])",
                "   temp := temp + (src1 × src2)",
                "end",
                "VSR[VRT+32] := CHOP128(temp)"
            ],
            "body": [
                "Let prod0 be the product of the unsigned integer values ",
                "in doubleword element 0 of VSR[VRA+32] and ",
                "doubleword element 0 of VSR[VRB+32]. ",
                "Let prod1 be the product of the unsigned integer values ",
                "in doubleword element 1 of VSR[VRA+32] and ",
                "doubleword element 1 of VSR[VRB+32]. ",
                "The low-order 128 bits of the sum of prod0, prod1, and ",
                "the unsigned integer value in VSR[VRC+32] are placed ",
                "into VSR[VRT+32].",
                "  "
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Halfword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumuhm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "38" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTZ(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + (src1 × src2)",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-Sum Unsigned Halfword Saturate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmsumuhs",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "39" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRC+32].word[i])",
                "   do j = 0 to 1",
                "      src1 := EXTZ(VSR[VRA+32].word[i].hword[j])",
                "      src2 := EXTZ(VSR[VRB+32].word[i].hword[j])",
                "      temp := temp + src1 × src2",
                "   end",
                "   VSR[VRT+32].word[i] := ui32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Multiply-by-10 & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmul10cuq",
                    "regs": [ "VRT,VRA" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "prod := (src << 3) + (src << 1)",
                "VSR[VRT+32] := CHOP128(prod >> 128)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "The product of src multiplied by the value 10 is shifted ",
                "right by 128 bits. The rightmost 128 bits of the shifted ",
                "result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-by-10 Extended & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmul10ecuq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "65" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "cin  := EXTZ(VSR[VRB+32].bit[124:127])",
                "prod := (src << 3) + (src << 1) + cin",
                "VSR[VRT+32] := CHOP128(prod>>128)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "Let cin be the unsigned packed decimal value in bits ",
                "124:127 of VSR[VRA+32]. Values of cin greater than 9 ",
                "are undefined.",
                "The sum of cin and the product of src multiplied by the ",
                "value 10 is shifted right by 128 bits. The rightmost 128 ",
                "bits of the shifted result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-by-10 Extended Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmul10euq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "577" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "cin  := EXTZ(VSR[VRB+32].bit[124:127])",
                "prod := (src << 3) + (src << 1) + cin",
                "VSR[VRT+32] := CHOP128(prod)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "Let cin be the unsigned packed decimal value in bits ",
                "124:127 of VSR[VRB+32]. Values of cin greater than 9 ",
                "are undefined.",
                "The rightmost 128 bits of the sum of cin and the ",
                "product of src multiplied by the value 10 are placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Multiply-by-10 Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vmul10uq",
                    "regs": [ "VRT,VRA" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "513" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "prod := (src << 3) + (src << 1)",
                "VSR[VRT+32] := CHOP128(prod)"
            ],
            "body": [
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "The rightmost 128 bits of the product of src multiplied ",
                "by the value 10 are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Negate Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vnegd",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "7" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src := EXTS(VSR[VRB+32].dword[i])",
                "",
                "   VSR[VRT+32]dword[i] := CHOP64(~src + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Negate Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vnegw",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "6" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := CHOP32(~src + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Negative Multiply-Subtract Floating-Point",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vnmsubfp",
                    "regs": [ "VRT,VRA,VRC,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "47" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   src3 := VSR[VRC+32].word[i]",
                "   result := bfp32_NEGATIVE_MULTIPLY_SUBTRACT(src1,src3,src2)",
                "   VSR[VRT+32].word[i] := result",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Pixel",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkpx",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "782" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i].bit[0]     := vsrc.word[i].bit[7]",
                "   VSR[VRT+32].hword[i].bit[1:5]   := vsrc.word[i].bit[8:12]",
                "   VSR[VRT+32].hword[i].bit[6:10]  := vsrc.word[i].bit[16:20]",
                "   VSR[VRT+32].hword[i].bit[11:15] := vsrc.word[i].bit[24:28]",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Pack Signed Doubleword Signed Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpksdss",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1486" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := si32_CLAMP(EXTS(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := si32_CLAMP(EXTS(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := si32_CLAMP(EXTS(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := si32_CLAMP(EXTS(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Doubleword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpksdus",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1358" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := ui32_CLAMP(EXTS(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := ui32_CLAMP(EXTS(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := ui32_CLAMP(EXTS(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := ui32_CLAMP(EXTS(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Halfword Signed Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkshss",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "398" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := si8_CLAMP(EXTS(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Halfword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkshus",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "270" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := ui8_CLAMP(EXTS(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Word Signed Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkswss",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "462" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(EXTS(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Pack Signed Word Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkswus",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "334" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := ui16_CLAMP(EXTS(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Doubleword Unsigned Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkudum",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1102" }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].dword[0].bit[32:63]",
                "VSR[VRT+32].word[1] := VSR[VRA+32].dword[1].bit[32:63]",
                "VSR[VRT+32].word[2] := VSR[VRB+32].dword[0].bit[32:63]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].dword[1].bit[32:63]"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Doubleword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkudus",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1230" }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := ui32_CLAMP(EXTZ(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := ui32_CLAMP(EXTZ(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := ui32_CLAMP(EXTZ(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := ui32_CLAMP(EXTZ(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Halfword Unsigned Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkuhum",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "14" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := vsrc.hword[i].bit[8:15]",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Halfword Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkuhus",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "142" }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := ui8_CLAMP(EXTZ(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Word Unsigned Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkuwum",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "78" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := vsrc.word[i].bit[16:31]",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Pack Unsigned Word Unsigned Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpkuwus",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "206" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := ui16_CLAMP(EXTZ(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "Let vsrc be the concatenation of the contents of ",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Parallel Bits Deposit Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpdepd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1485" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   VSR[VRT+32].dword[i] := 0",
                "   m := 0",
                "   k := 0",
                "   do while(m < 64)",
                "      if VSR[VRB+32].dword[i].bit[63-m]=1 then do",
                "         result := VSR[VRA+32].dword[i].bit[63-k]",
                "         VSR[VRT+32].dword[i].bit[63-m] := result",
                "         k := k + 1",
                "      end",
                "      m := m + 1",
                "   end",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Parallel Bits Extract Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpextd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1421" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   result := 0",
                "   m := 0",
                "   k := 0",
                "   do while(m < 64)",
                "      if VSR[VRB+32].dword[i].bit[63-m]=1 then do",
                "         result.bit[63-k] := VSR[VRA+32].dword[i].bit[63-m]",
                "         k := k + 1",
                "      end",
                "      m := m + 1",
                "   end",
                "   VSR[VRT+32].dword[i] := result",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Parity Byte Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vprtybd",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "9" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   s := 0",
                "   do j = 0 to 7",
                "       s := s ^ VSR[VRB+32].dword[i].byte[j].bit[7]",
                "   end",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTZ(s))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following"
            ]
        },
        {
            "description": "Vector Parity Byte Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vprtybq",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "10" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "s := 0",
                "do j = 0 to 15",
                "   s := s ^ VSR[VRB+32].byte[j].bit[7]",
                "end",
                "VSR[VRT+32] := CHOP128(EXTZ(s))"
            ],
            "body": [
                "If the sum of the least significant bit in each byte ",
                "element of VSR[VRB+32] is odd, the value 1 is placed ",
                "into VSR[VRT+32]; otherwise the value 0 is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Parity Byte Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vprtybw",
                    "regs": [ "VRT,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "8" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1538" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   s := 0",
                "   do j = 0 to 3",
                "      s := s ^ VSR[VRB+32].word[i].byte[j].bit[7]",
                "   end",
                "   VSR[VRT+32].word[i] := CHOP32(EXTZ(s))",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following"
            ]
        },
        {
            "description": "Vector Permute",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vperm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "43" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   index := VSR[VRC+32].byte[i].bit[3:7]",
                "   VSR[VRT+32].byte[i] := src.byte[index]",
                "end"
            ],
            "body": [
                "Let the source vector be the concatenation of the ",
                "contents of VSR[VRA+32] followed by the contents of ",
                "VSR[VRB+32]. ",
                "For each integer value i from 0 to 15, do the following.",
                "  "
            ]
        },
        {
            "description": "Vector Permute & Exclusive-OR",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpermxor",
                    "regs": [ "VRT,VRA,", "VRB,VRC" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "45" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   indexA := VSR[VRC+32].byte[i].bit[0:3]",
                "   indexB := VSR[VRC+32].byte[i].bit[4:7]",
                "   src1   := VSR[VRA+32].byte[indexA]",
                "   src2   := VSR[VRB+32].byte[indexB]",
                "   VSR[VRT+32].byte[i] := src1 ^ src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Permute Right-indexed",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpermr",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "59" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "   index := VSR[VRC+32].byte[i].bit[3:7]",
                "   VSR[VRT+32].byte[i] := src.byte[31-index]",
                "end"
            ],
            "body": [
                "Let the source vector be the concatenation of the ",
                "contents of VSR[VRA+32] followed by the contents of ",
                "VSR[VRB+32]. ",
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumb",
                    "regs": [ "VRT,VRA,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1032" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   prod[i].bit[0:14] := 0",
                "   srcA := VSR[VRA+32].byte[i]",
                "   srcB := VSR[VRB+32].byte[i]",
                "   do j = 0 to 7",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] & srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 8 to 14",
                "      do k = j-7 to 7",
                "         gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := 0b0 || (prod[2×i] ^ prod[2×i+1])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following.",
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumd",
                    "regs": [ "VRT,VRA,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1224" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   prod[i].bit[0:126] := 0",
                "   srcA := VSR[VRA+32].doubleword[i]",
                "   srcB := VSR[VRB+32].doubleword[i]",
                "   do j = 0 to 63",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] & srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 64 to 126",
                "      do k = j-63 to 63",
                "         gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "VSR[VRT+32] := 0b0 || (prod[0] ^ prod[1])"
            ],
            "body": [
                "Let prod[0] be the 127-bit result of a binary polynomial ",
                "multiplication of the contents of doubleword element 0 ",
                "of VSR[VRA+32] and the contents of doubleword ",
                "element 0 of VSR[VRB+32].",
                "Let prod[1] be the 127-bit result of a binary polynomial ",
                "multiplication of the contents of doubleword element 1 ",
                "of VSR[VRA+32] and the contents of doubleword ",
                "element 1 of VSR[VRB+32].",
                "The exclusive-OR of prod[0] and prod[1] is placed in ",
                "bits 1:127 of VSR[VRT+32]. Bit 0 of VSR[VRT+32] is set to ",
                "0."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumh",
                    "regs": [ "VRT,VRA,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1096" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   prod.bit[0:30] := 0",
                "   srcA := VSR[VRA+32].halfword[i]",
                "   srcB := VSR[VRB+32].halfword[i]",
                "   do j = 0 to 15",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] & srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 16 to 30",
                "      do k = j-15 to 15",
                "         gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "VSR[VRT+32].word[0] := 0b0 || (prod[0] ^ prod[1])",
                "VSR[VRT+32].word[1] := 0b0 || (prod[2] ^ prod[3])",
                "VSR[VRT+32].word[2] := 0b0 || (prod[4] ^ prod[5])",
                "VSR[VRT+32].word[3] := 0b0 || (prod[6] ^ prod[7])"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following.",
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Polynomial Multiply-Sum Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpmsumw",
                    "regs": [ "VRT,VRA,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1160" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   prod[i].bit[0:62] := 0",
                "   srcA := VSR[VRA+32].word[i]",
                "   srcB := VSR[VRB+32].word[i]",
                "   do j = 0 to 31",
                "      do k = 0 to j",
                "         gbit := srcA.bit[k] & srcB.bit[j-k]",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "   do j = 32 to 62",
                "      do k = j-31 to 31",
                "         gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "         prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "      end",
                "   end",
                "end",
                "VSR[VRT+32].dword[0] := 0b0 || (prod[0] ^ prod[1])",
                "VSR[VRT+32].dword[1] := 0b0 || (prod[2] ^ prod[3])"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Population Count Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpopcntb",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1795" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   n := 0",
                "   do j = 0 to 7",
                "      n := n + VSR[VRB+32].byte[i].bit[j]",
                "   end",
                "   VSR[VRT+32].byte[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Population Count Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpopcntd",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1987" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   n := 0",
                "   do j = 0 to 63",
                "      n := n + VSR[VRB+32].dword[i].bit[j]",
                "   end",
                "   VSR[VRT+32].dword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Population Count Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpopcnth",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1859" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   n := 0",
                "   do j = 0 to 15",
                "      n := n + VSR[VRB+32].hword[i].bit[j]",
                "   end",
                "   VSR[VRT+32].hword[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Population Count Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vpopcntw",
                    "regs": [ "VRT,", "VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1923" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   n := 0",
                "   do j = 0 to 31",
                "      n := n + VSR[VRB+32].word[i].bit[j]",
                "   end",
                "   VSR[VRT+32].word[i] := n",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Reciprocal Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrefp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "266" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_RECIPROCAL_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Unless the single-precision floating-point result of ",
                "computing the reciprocal of a value would be a zero, ",
                "an infinity, or a QNaN, the estimate has a relative error ",
                "in precision no greater than one part in 4096.",
                "Note that results may vary between implementations, ",
                "and between different executions on the same ",
                "implementation.",
                "The result for various special cases of the source ",
                "value is given below.  "
            ]
        },
        {
            "description": "Vector Reciprocal Square Root Estimate Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrsqrtefp",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "330" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_RECIPROCAL_SQRT_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "Let x be any single-precision floating-point value. ",
                "Unless the single-precision floating-point result of ",
                "computing the reciprocal of the square root of x would ",
                "be a zero, an infinity, or a QNaN, the estimate has a ",
                "relative error in precision no greater than one part in ",
                "4096.",
                "Note that results may vary between implementations, ",
                "and between different executions on the same ",
                "implementation.",
                "The result for various special cases of the source ",
                "value is given below.  "
            ]
        },
        {
            "description": "Vector Rotate Left Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "4" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src := VSR[VRA+32].byte[i]",
                "   sh  := VSR[VRB+32].byte[i].bit[5:7]",
                "",
                "   VSR[VRT+32].byte[i] := src <<< sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrld",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "196" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src := VSR[VRA+32].dword[i]",
                "   sh  := VSR[VRB+32].dword[i].bit[58:63]",
                "",
                "   VSR[VRT+32].dword[i] := src <<< sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Doubleword then AND with Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrldnm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "453" }
            ],
            "code": [

            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Doubleword then Mask Insert",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrldmi",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "197" }
            ],
            "code": [

            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "68" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src := VSR[VRA+32].hword[i]",
                "   sh  := VSR[VRB+32].hword[i].bit[12:15]",
                "",
                "   VSR[VRT+32].hword[i] := src <<< sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "5" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := ROTL128(VSR[VRA+32], n)"
            ],
            "body": [
                "Let SH be the contents of bits 57:63 of VSR[VRB+32].",
                "Let src1 be the contents of VSR[VRA+32].",
                "src1 is rotated left by SH bits. Bits shifted out on the left ",
                "are shifted in on the right to replace vacated bits."
            ]
        },
        {
            "description": "Vector Rotate Left Quadword then AND with Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlqnm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "325" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "b := VSR[VRB+32].bit[41:47]",
                "e := VSR[VRB+32].bit[49:55]",
                "n := VSR[VRB+32].bit[57:63]",
                "r := ROTL128(VSR[VRA+32],n)",
                "m := MASK128(b, e)",
                "VSR[VRT+32] := r & m"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "Let mb be the contents of bits 41:47 of src2.",
                "src1 is rotated left sh bits.",
                "A mask is generated having 1-bits from bit mb through ",
                "bit me and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Rotate Left Quadword then Mask Insert",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlqmi",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "69" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := VSR[VRB+32].bit[41:47]",
                "e := VSR[VRB+32].bit[49:55]",
                "n := VSR[VRB+32].bit[57:63]",
                "r := ROTL128(VSR[VRA+32],n)",
                "m := MASK128(b, e)",
                "VSR[VRT+32] := (r & m) | (VSR[VRT+32] & ~m)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "Let mb be the contents of bits 41:47 of src2.",
                "src1 is rotated left sh bits.",
                "A mask is generated having 1-bits from bit mb through ",
                "bit me and 0-bits elsewhere.",
                "The rotated data are inserted into src3 under control of ",
                "the generated mask.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Rotate Left Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "132" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRA+32].word[i]",
                "   sh  := VSR[VRB+32].word[i].bit[27:31]",
                "",
                "   VSR[VRT+32].word[i] := src <<< sh",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Word then AND with Mask",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlwnm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "389" }
            ],
            "code": [

            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Rotate Left Word then Mask Insert",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrlwmi",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "133" }
            ],
            "code": [

            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer Nearest",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrfin",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "522" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_NEAR(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                " ",
                " "
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer toward +Infinity",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrfip",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "650" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_CEIL(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer toward -Infinity",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrfim",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "714" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_FLOOR(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Round to Floating-Point Integer toward Zero",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vrfiz",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "586" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_TRUNC(src)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector SHA-256 Sigma Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vshasigmaw",
                    "regs": [ "VRT,VRA,", "ST,SIX" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "ST", "size": "1" },
                { "name": "SIX", "size": "4" },
                { "name": "opcode", "size": "11", "value": "1666" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src := VSR[VRA+32].word[i]",
                "",
                "   if ST=0 & SIX.bit[i]=0 then  // SHA-256 s0 function",
                "      VSR[VRT+32].word[i] := (src >>>  7) ^",
                "      VSR[VRT+32].word[i] := (src >>> 18) ^",
                "      VSR[VRT+32].word[i] := (src >>  3)",
                "",
                "   if ST=0 & SIX.bit[i]=1 then  // SHA-256 s1 function",
                "      VSR[VRT+32].word[i] := (src >>> 17) ^",
                "      VSR[VRT+32].word[i] := (src >>> 19) ^",
                "      VSR[VRT+32].word[i] := (src >> 10)",
                "",
                "   if ST=1 & SIX.bit[i]=0 then  // SHA-256 S0 function",
                "      VSR[VRT+32].word[i] := (src >>>  2) ^",
                "      VSR[VRT+32].word[i] := (src >>> 13) ^",
                "      VSR[VRT+32].word[i] := (src >>> 22)",
                "",
                "   if ST=1 & SIX.bit[i]=1 then  // SHA-256 S1 function",
                "      VSR[VRT+32].word[i] := (src >>>  6) ^",
                "      VSR[VRT+32].word[i] := (src >>> 11) ^",
                "      VSR[VRT+32].word[i] := (src >>> 25)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector SHA-512 Sigma Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vshasigmad",
                    "regs": [ "VRT,VRA,", "ST,SIX" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "ST", "size": "1" },
                { "name": "SIX", "size": "4" },
                { "name": "opcode", "size": "11", "value": "1730" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src := VSR[VRA+32].dword[i]",
                "",
                "   if ST=0 & SIX.bit[2×i]=0 then  // SHA-512 s0 function",
                "      VSR[VRT+32].dword[i] := (src >>>  1) ^",
                "      VSR[VRT+32].dword[i] := (src >>>  8) ^",
                "      VSR[VRT+32].dword[i] := (src >> 7)",
                "",
                "   if ST=0 & SIX.bit[2×i]=1 then  // SHA-512 s1 function",
                "      VSR[VRT+32].dword[i] := (src >>> 19) ^",
                "      VSR[VRT+32].dword[i] := (src >>> 61) ^",
                "      VSR[VRT+32].dword[i] := (src >> 6)",
                "",
                "   if ST=1 & SIX.bit[2×i]=0 then  // SHA-512 S0 function",
                "      VSR[VRT+32].dword[i] := (src >>> 28) ^",
                "      VSR[VRT+32].dword[i] := (src >>> 34) ^",
                "      VSR[VRT+32].dword[i] := (src >>> 39)",
                "",
                "   if ST=1 & SIX.bit[2×i]=1  then  // SHA-512 S1 function",
                "      VSR[VRT+32].dword[i] := (src >>> 14) ^",
                "      VSR[VRT+32].dword[i] := (src >>> 18) ^",
                "      VSR[VRT+32].dword[i] := (src >>> 41)",
                "end   "
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following.",
                "Bits 1 and 3 of SIX are reserved."
            ]
        },
        {
            "description": "Vector Select",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsel",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "42" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32]",
                "mask := VSR[VRC+32]",
                "",
                "VSR[VRT+32] := (src1 & ~mask) | (src2 & mask)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "The value, (src1&~mask)|(src2&mask), is placed ",
                "into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Left",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsl",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "452" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[125:127]",
                "",
                "t := 1",
                "do i = 0 to 14",
                "   t := t & (VSR[VRB+32].byte[i].bit[5:7] = sh)",
                "end",
                "if t=1 then",
                "   VSR[VRT+32] := VSR[VRA+32] << sh",
                "else",
                "   VSR[VRT+32] := UNDEFINED"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted left by the ",
                "number of bits specified in bits 125:127 of VSR[VRB+32]. ",
                "The result is place into VSR[VRT+32], except if, for any ",
                "byte element in VSR[VRB+32], the low-order 3 bits are ",
                "not equal to the shift amount, then VSR[VRT+32] is ",
                "undefined."
            ]
        },
        {
            "description": "Vector Shift Left Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vslb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "260" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := src1 << src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Shift Left Double by Bit Immediate",
            "form": "VN-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsldbi",
                    "regs": [ "VRT,VRA,VRB,SH" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "2", "value": "0" },
                { "name": "SH", "size": "3" },
                { "name": "opcode", "size": "6", "value": "22" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32]   := vsrc.bit[SH:SH+127]"
            ],
            "body": [
                "Let vsrc be the contents of VSR[VRA+32] concatenated ",
                "with the contents of VSR[VRB+32].",
                "The contents of bits SH:SH+127 of vsrc are placed into ",
                "VSR[VRT+32].",
                "SH can be any integer value between 0 and 7."
            ]
        },
        {
            "description": "Vector Shift Left Double by Octet Immediate",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsldoi",
                    "regs": [ "VRT,VRA,VRB,SHB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "SHB", "size": "4" },
                { "name": "opcode", "size": "6", "value": "44" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32] := src.byte[SHB:SHB+15]"
            ],
            "body": [
                "Let vsrc be the contents of VSR[VRA+32] concatenated ",
                "with the contents of VSR[VRB+32].",
                "Bytes SHB:SHB+15 of vsrc are placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Left Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsld",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1476" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "",
                "   VSR[VRT+32].dword[i] := src1 << src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Shift Left Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vslh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "324" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "   VSR[VRT+32].hword[i] := src1 << src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Shift Left Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vslq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "261" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := VSR[VRA+32] << VSR[VRB+32].bit[57:63]"
            ],
            "body": [
                "Let n be the contents of bits 57:63 of VSR[VRB+32].",
                "Let src1 be the contents of VSR[VRA+32].",
                "Let src2 be the contents of VSR[VRB+32].",
                "src1 is shifted left by the number of bits specified in the ",
                "low-order 7 bits of src2.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Left Variable",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vslv",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1860" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable_Interrupt()",
                "",
                "vsrc.byte[0:15] := VSR[VRA+32]",
                "vsrc.byte[16]   := 0x00",
                "",
                "do i = 0 to 15",
                "   sh := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := src.byte[i:i+1].bit[sh:sh+7]",
                "end"
            ],
            "body": [

            ]
        },
        {
            "description": "Vector Shift Left Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vslw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "388" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i].bit[27:31]",
                "",
                "   VSR[VRT+32].word[i] := src1 << src2",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Shift Left by Octet",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vslo",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1036" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[121:124] << 3",
                "",
                "VSR[VRT+32] := VSR[VRA+32] << shb"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted left by the ",
                "number of bytes specified in bits 121:124 of ",
                "VSR[VRB+32]. ",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Right",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsr",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "708" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "sh := VSR[VRB+32].bit[125:127]",
                "",
                "t := 1",
                "do i = 0 to 14",
                "   t := t & (VSR[VRB+32].byte[i].bit[5:7]=sh)",
                "end",
                "if t=1 then",
                "   VSR[VRT+32] := CHOP128(EXTZ(VSR[VRA+32]) >> sh)",
                "else",
                "   VSR[VRT+32] := UNDEFINED"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted right by the ",
                "number of bits specified in bits 125:127 of VSR[VRB+32]. ",
                "The result is place into VSR[VRT+32], except if, for any ",
                "byte element in VSR[VRB+32], the low-order 3 bits are ",
                "not equal to the shift amount, then VSR[VRT+32] is ",
                "undefined."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrab",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "772" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := CHOP8(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrad",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "964" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrah",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "836" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src1 := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "   VSR[VRT+32].hword[i] := CHOP16(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsraq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "773" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := CHOP128(EXTS(src1) >> src2)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "src1 is shifted right by the number of bits specified in ",
                "the low-order 7 bits of src2.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Right Algebraic Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsraw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "900" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i].bit[27:31]",
                "   VSR[VRT+32].word[i] := CHOP32(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrb",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "516" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "   src1 := VSR[VRA+32].byte[i]",
                "   src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := CHOP8(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Double by Bit Immediate",
            "form": "VN-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrdbi",
                    "regs": [ "VRT,VRA,VRB,SH" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "2", "value": "1" },
                { "name": "SH", "size": "3" },
                { "name": "opcode", "size": "6", "value": "22" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32]   := vsrc.bit[128-SH:255-SH]"
            ],
            "body": [
                "Let vsrc be the contents of VSR[VRA+32] concatenated ",
                "with the contents of VSR[VRB+32].",
                "The contents of bits 128-SH:255-SH of vsrc are placed ",
                "into VSR[VRT+32].",
                "SH can be any integer value between 0 and 7."
            ]
        },
        {
            "description": "Vector Shift Right Doubleword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrd",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1732" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   src1 := VSR[VRA+32].dword[i]",
                "   src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "   VSR[VRT+32].dword[i] := CHOP64(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrh",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "580" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "   src := VSR[VRA+32].hword[i]",
                "   src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "   VSR[VRT+32].hword[i] := CHOP16(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Shift Right Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "517" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := CHOP128(EXTZ(src1) >> src2)"
            ],
            "body": [
                "Let src1 be the contents of VSR[VRA+32].",
                "src1 is shifted right by the number of bits specified in ",
                "the low-order 7 bits of src2.",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Shift Right Variable",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrv",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1796" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable_Interrupt()",
                "",
                "vsrc.byte[0]   := 0x00",
                "vsrc.byte[1:16] := VSR[VRA+32]",
                "",
                "do i = 0 to 15",
                "   sh := VSR[VRB+32].byte[i].bit[5:7]",
                "   VSR[VRT+32].byte[i] := src.byte[i:i+1].bit[8-sh:15-sh]",
                "end"
            ],
            "body": [

            ]
        },
        {
            "description": "Vector Shift Right Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsrw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "644" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i].bit[27:31]",
                "   VSR[VRT+32].word[i] := CHOP32(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Shift Right by Octet",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsro",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1100" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[121:124] << 3",
                "",
                "VSR[VRT+32] := VSR[VRA+32] >> shb"
            ],
            "body": [
                "The contents of VSR[VRA+32] are shifted right by the ",
                "number of bytes specified in bits 121:124 of ",
                "VSR[VRB+32]. ",
                "The result is placed into VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Splat Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vspltb",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "1" },
                { "name": "UIM", "size": "4" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "524" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b000",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := VSR[VRB+32].bit[b:b+7]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Splat Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsplth",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "2" },
                { "name": "UIM", "size": "3" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "588" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b0000",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := VSR[VRB+32].bit[b:b+15]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Splat Immediate Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vspltisb",
                    "regs": [ "VRT,SIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "SIM", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "780" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   VSR[VRT+32].byte[i] := EXTS8(SIM, 8)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Splat Immediate Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vspltish",
                    "regs": [ "VRT,SIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "SIM", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "844" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := EXTS16(SIM, 16)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Splat Immediate Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vspltisw",
                    "regs": [ "VRT,SIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "SIM", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "opcode", "size": "11", "value": "908" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i] := EXTS32(SIM, 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Splat Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vspltw",
                    "regs": [ "VRT,VRB,UIM" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "3" },
                { "name": "UIM", "size": "2" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "652" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b00000",
                "do i = 0 to 3",
                "   VSR[VRT+32].word[i] := VSR[VRB+32].bit[b:b+31]",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector String Isolate Byte Left-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vstribl",
                    "regs": [ "VRT,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "0" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "13" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 15",
                "   null_found := (VSR[VRB+32].byte[i]=0)",
                "   VSR[VRT+32].byte[i] := VSR[VRB+32].byte[i]",
                "end",
                "",
                "do j = i to 15",
                "   VSR[VRT+32].byte[j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From left-to-right, the contents of each byte element of ",
                "VSR[VRB+32] are placed into the corresponding byte ",
                "element in VSR[VRT+32]. If a byte element in ",
                "VSR[VRB+32] is found to contain 0, the corresponding ",
                "byte element and all byte elements to the right of that ",
                "byte element in VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector String Isolate Byte Right-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vstribr",
                    "regs": [ "VRT,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "1" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "13" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 15",
                "   null_found := (VSR[VRB+32].byte[15-i]=0)",
                "   VSR[VRT+32].byte[15-i] := VSR[VRB+32].byte[15-i]",
                "end",
                "",
                "do j = i to 15",
                "   VSR[VRT+32].byte[15-j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From right-to-left, the contents of each byte element of ",
                "VSR[VRB+32] are placed into the corresponding byte ",
                "element in VSR[VRT+32]. If a byte element in ",
                "VSR[VRB+32] is found to contain 0, the corresponding ",
                "byte element and all byte elements to the left of that ",
                "byte element in VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector String Isolate Halfword Left-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vstrihl",
                    "regs": [ "VRT,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "2" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "13" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 7",
                "   null_found := (VSR[VRB+32].hword[i] = 0)",
                "   VSR[VRT+32].hword[i] := VSR[VRB+32].hword[i]",
                "end",
                "",
                "do j = i to 7",
                "   VSR[VRT+32].hword[j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From left-to-right, the contents of each halfword ",
                "element of VSR[VRB+32] are placed into the ",
                "corresponding halfword element in VSR[VRT+32]. If a ",
                "halfword element in VSR[VRB+32] is found to contain 0, ",
                "the corresponding halfword element and all halfword ",
                "elements to the right of that halfword element in ",
                "VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector String Isolate Halfword Right-justified",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vstrihr",
                    "regs": [ "VRT,VRB", "(", "Rc=0", ")" ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "opcode", "size": "5", "value": "3" },
                { "name": "VRB", "size": "5" },
                { "name": "Rc", "size": "1" },
                { "name": "opcode", "size": "10", "value": "13" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 7",
                "   null_found := (VSR[VRB+32].hword[7-i] = 0)",
                "   VSR[VRT+32].hword[7-i] := VSR[VRB+32].hword[7-i]",
                "end",
                "",
                "do j = i to 7",
                "   VSR[VRT+32].hword[7-j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "   CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "From right-to-left, the contents of each halfword ",
                "element of VSR[VRB+32] are placed into the ",
                "corresponding halfword element in VSR[VRT+32]. If a ",
                "halfword element in VSR[VRB+32] is found to contain 0, ",
                "the corresponding halfword element and all halfword ",
                "elements to the left of that halfword element in ",
                "VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector Subtract & Write Carry-Out Unsigned Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubcuw",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1408" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(:=VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := EXTZ32((src1+src2+1) >> 32)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract & write Carry-out Unsigned Quadword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubcuq",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1344" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128((src1 + src2 + 1) >> 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1, the one’s ",
                "complement of src2, and the value 1 is placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Extended & write Carry-out Unsigned Quadword",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubecuq",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "63" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128((src1 + src2 + cin) >> 128)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The carry out of the sum of src1, the one’s ",
                "complement of src2, and cin are placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Extended Unsigned Quadword Modulo",
            "form": "VA-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubeuqm",
                    "regs": [ "VRT,VRA,VRB,VRC" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "VRC", "size": "5" },
                { "name": "opcode", "size": "6", "value": "62" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + cin)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1, the one’s ",
                "complement of src2, and cin are placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Floating-Point",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubfp",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "74" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "   src1 := VSR[VRA+32].word[i]",
                "   src2 := VSR[VRB+32].word[i]",
                "   VSR[VRT+32].word[i] := bfp32_SUBTRACT(src1,src2)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract Signed Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubsbs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1792" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTS(VSR[VRA+32].byte[i])",
                "   src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "   VSR[VRT+32].byte[i] := si8_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Subtract Signed Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubshs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1856" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTS(VSR[VRA+32].hword[i])",
                "   src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "   VSR[VRT+32].hword[i] := si16_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Subtract Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubsws",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1920" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTS(VSR[VRA+32].word[i])",
                "   src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "   VSR[VRT+32].word[i] := si32_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Byte Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsububm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1024" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "   VSR[VRT+32].byte[i] := CHOP8(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsububs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1536" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "   src1 := EXTZ(VSR[VRA+32].byte[i])",
                "   src2 := EXTZ(VSR[VRB+32].byte[i])",
                "   VSR[VRT+32].byte[i] := ui8_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 15, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Doubleword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubudm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1216" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   src1 := EXTZ(VSR[VRA+32].dword[i])",
                "   src2 := EXTZ(VSR[VRB+32].dword[i])",
                "   VSR[VRT+32].dword[i] := CHOP64(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Halfword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubuhm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1088" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "   VSR[VRT+32].hword[i] := CHOP16(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubuhs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1600" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   src1 := EXTZ(VSR[VRA+32].hword[i])",
                "   src2 := EXTZ(VSR[VRB+32].hword[i])",
                "   VSR[VRT+32].hword[i] := ui16_CLAMP(src1 + ~src2 + 1)",
                "   VSCR.SAT := VSCR.SAT | sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Quadword Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubuqm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1280" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(:=VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + 1)"
            ],
            "body": [
                "Let src1 be the integer value in VSR[VRA+32].",
                "src1 and src2 can be signed or unsigned integers.",
                "The rightmost 128 bits of the sum of src1, the one’s ",
                "complement of src2, and the value 1 are placed into ",
                "VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Word Modulo",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubuwm",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1152" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "   VSR[VRT+32].word[i] := CHOP32(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Subtract Unsigned Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsubuws",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1664" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src1 := EXTZ(VSR[VRA+32].word[i])",
                "   src2 := EXTZ(VSR[VRB+32].word[i])",
                "   VSR[VRT+32].word[i] := ui32_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Sum across Half Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsum2sws",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1672" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "   temp := EXTS(VSR[VRB+32].dword[i].word[1])",
                "   do j = 0 to 1",
                "      temp := temp + EXTS(VSR[VRA+32].dword[i].word[j])",
                "   end",
                "   VSR[VRT+32].dword[i].word[0] := 0x0000_0000",
                "   VSR[VRT+32].dword[i].word[1] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "Word elements 0 and 2 of VSR[VRT+32] are set to 0.",
                "The sum of the signed integer values in word elements ",
                "0 and 1 in VSR[VRA+32] is added to the signed integer ",
                "value in word element 1 of VSR[VRB+32]. ",
                "The low-order 32 bits of the result are placed into word ",
                "element 1 of VSR[VRT+32]. ",
                "The sum of the signed integer values in word elements ",
                "2 and 3 in VSR[VRA+32] is added to the signed integer ",
                "value in word element 3 of VSR[VRB+32].",
                "The low-order 32 bits of the result are placed into word ",
                "element 3 of VSR[VRT+32]."
            ]
        },
        {
            "description": "Vector Sum across Quarter Signed Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsum4sbs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1800" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRB+32].word[i])",
                "   do j = 0 to 3",
                "      temp := temp + EXTS(VSR[VRA+32].word[i].byte[j])",
                "   end",
                "   VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Sum across Quarter Signed Halfword Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsum4shs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1608" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTS(VSR[VRB+32].word[i])",
                "   do j = 0 to 1",
                "      temp := temp + EXTS(VSR[VRA+32].word[i].hword[j])",
                "   end",
                "   VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Sum across Quarter Unsigned Byte Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsum4ubs",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1544" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   temp := EXTZ(VSR[VRB+32].word[i])",
                "   do j = 0 to 3",
                "      temp := temp + EXTZ(VSR[VRA+32].word[i].byte[j])",
                "   end",
                "   VSR[VRT+32].word[i] := ui32_CLAMP(temp)",
                "   VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Sum across Signed Word Saturate",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vsumsws",
                    "regs": [ "VRT,VRA,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "VRA", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1928" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTS(VSR[VRB+32].word[3])",
                "do i = 0 to 3",
                "   temp := temp + EXTS(VSR[VRA+32].word[i])",
                "end",
                "VSR[VRT+32].word[0] := 0x0000_0000",
                "VSR[VRT+32].word[1] := 0x0000_0000",
                "VSR[VRT+32].word[2] := 0x0000_0000",
                "VSR[VRT+32].word[3] := si32_CLAMP(temp)",
                "VSCR.SAT := sat_flag"
            ],
            "body": [
                "The sum of the signed integer values in the four word ",
                "elements of VSR[VRA+32] is added to the signed integer ",
                "value in the word element 3 of VSR[VRB+32].",
                "The low-order 32 bits of the result are placed into word ",
                "element 3 of VSR[VRT+32].",
                "Word elements 0 to 2 of VSR[VRT+32] are set to 0."
            ]
        },
        {
            "description": "Vector Unpack High Pixel",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupkhpx",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "846" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].hword[i]",
                "",
                "   VSR[VRT+32].word[i].byte[0] := EXTS8(src.bit[0])",
                "   VSR[VRT+32].word[i].byte[1] := EXTZ8(src.bit[1:5])",
                "   VSR[VRT+32].word[i].byte[2] := EXTZ8(src.bit[6:10])",
                "   VSR[VRT+32].word[i].byte[3] := EXTZ8(src.bit[11:15])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Unpack High Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupkhsb",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "526" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := EXTS16(VSR[VRB+32].byte[i])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Unpack High Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupkhsh",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "590" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := EXTS32(VSR[VRB+32].hword[0])",
                "VSR[VRT+32].word[1] := EXTS32(VSR[VRB+32].hword[1])",
                "VSR[VRT+32].word[2] := EXTS32(VSR[VRB+32].hword[2])",
                "VSR[VRT+32].word[3] := EXTS32(VSR[VRB+32].hword[3])"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Unpack High Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupkhsw",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1614" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].dword[0] := EXTS64(VSR[VRB+32].word[0])",
                "VSR[VRT+32].dword[1] := EXTS64(VSR[VRB+32].word[1])"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "Vector Unpack Low Pixel",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupklpx",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "974" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "   src := VSR[VRB+32].hword[i+4]",
                "",
                "   VSR[VRT+32].word[i].byte[0] := EXTS8(src.bit[0])",
                "   VSR[VRT+32].word[i].byte[1] := EXTZ8(src.bit[1:5])",
                "   VSR[VRT+32].word[i].byte[2] := EXTZ8(src.bit[6:10])",
                "   VSR[VRT+32].word[i].byte[3] := EXTZ8(src.bit[11:15])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Vector Unpack Low Signed Byte",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupklsb",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "654" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "   VSR[VRT+32].hword[i] := EXTS16(VSR[VRB+32].byte[i+8])",
                "end"
            ],
            "body": [
                "For each integer value i from 0 to 7, do the following."
            ]
        },
        {
            "description": "Vector Unpack Low Signed Halfword",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupklsh",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "718" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := EXTS32(VSR[VRB+32].hword[4])",
                "VSR[VRT+32].word[1] := EXTS32(VSR[VRB+32].hword[5])",
                "VSR[VRT+32].word[2] := EXTS32(VSR[VRB+32].hword[6])",
                "VSR[VRT+32].word[3] := EXTS32(VSR[VRB+32].hword[7])"
            ],
            "body": [
                "For each integer value i from 0 to 3, do the following."
            ]
        },
        {
            "description": "Vector Unpack Low Signed Word",
            "form": "VX-form",
            "category": "Vector Facility ",
            "mnemonics": [
                {
                    "mnemonic": "vupklsw",
                    "regs": [ "VRT,VRB" ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "4" },
                { "name": "VRT", "size": "5" },
                { "name": "reserved", "size": "5" },
                { "name": "VRB", "size": "5" },
                { "name": "opcode", "size": "11", "value": "1742" }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].dword[0] := EXTS64(VSR[VRB+32].word[2])",
                "VSR[VRT+32].dword[1] := EXTS64(VSR[VRB+32].word[3])"
            ],
            "body": [
                "For each integer value i from 0 to 1, do the following."
            ]
        },
        {
            "description": "XOR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "xor",
                    "regs": [ "RA,RS,RB", "(", "Rc=0", ")" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "xor.",
                    "regs": [ "RA,RS,RB", "(", "Rc=1", ")" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "31" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "RB", "size": "5" },
                { "name": "opcode", "size": "10", "value": "316" },
                { "name": "Rc", "size": "1" }
            ],
            "code": [
                "RA := (RS) ^ (RB)"
            ],
            "body": [
                "The contents of register RS are XORed with the con",
                "tents of register RB and the result is placed into register ",
                "RA."
            ]
        },
        {
            "description": "XOR Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "xori",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "26" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "RA := (RS) XOR (<sup>48</sup>0 || UI)",
                "xori   0,0,0"
            ],
            "body": [
                "The contents of register RS are XORed with 480||UI ",
                "and the result is placed into register RA.",
                "The executed form of a “no-op” (an instruction that ",
                "does nothing, but consumes execution resources nev",
                "ertheless) is:",
                "Example of extended mnemonics for XOR Immediate:",
                "  ",
                "  "
            ]
        },
        {
            "description": "XOR Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "xoris",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                { "name": "opcode", "size": "6", "value": "27" },
                { "name": "RS", "size": "5" },
                { "name": "RA", "size": "5" },
                { "name": "UI", "size": "16" }
            ],
            "code": [
                "RA := (RS) XOR (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "The contents of register RS are XORed with ",
                "320||UI||160 and the result is placed into register ",
                "RA."
            ]
        }
    ],
    "forms": [
        "8LS:D-form",
        "8RR:D-form",
        "8RR:XX4-form",
        "A-form",
        "B-form",
        "D-form",
        "DQ-form",
        "DS-form",
        "DX-form",
        "I-form",
        "M-form",
        "MD-form",
        "MDS-form",
        "MLS:D-form",
        "MMIRR:XX3-form",
        "MRR:*-form",
        "SC-form",
        "VA-form",
        "VC-form",
        "VN-form",
        "VX-form",
        "X-form",
        "X2-form",
        "XFL-form",
        "XFX-form",
        "XL-form",
        "XO-form",
        "XS-form",
        "XX2-form",
        "XX3-form",
        "XX4-form",
        "Z22-form",
        "Z23-form"
    ],
    "chapters": [
        {
            "name": "Branch Facility",
            "chapters": []
        },
        {
            "name": "Fixed-Point Facility",
            "chapters": []
        },
        {
            "name": "Floating-Point Facility",
            "chapters": []
        },
        {
            "name": "Decimal Floating-Point",
            "chapters": []
        },
        {
            "name": "Vector Facility ",
            "chapters": []
        },
        {
            "name": "Vector-Scalar Extension Facility",
            "chapters": []
        }
    ]
}
