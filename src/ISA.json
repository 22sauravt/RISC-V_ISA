{
    "instructions": [
        {
            "description": "Load Byte and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbz",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "34", "RT", "RA", "D" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "RT := 560 || MEM(EA, 1)"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "The byte in storage addressed by EA is loaded into ",
                "RT56:63. RT0:55 are set to 0."
            ]
        },
        {
            "description": "Load Byte and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbzx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "87", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := 560 || MEM(EA, 1)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The byte in storage addressed by EA ",
                "is loaded into RT56:63. RT0:55 are set to 0."
            ]
        },
        {
            "description": "Load Byte and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbzu",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "35", "RT", "RA", "D" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := 560 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "The byte in storage addressed by EA is loaded into ",
                "RT56:63. RT0:55 are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Byte and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lbzux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "119", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := 560 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). The byte in storage addressed by EA is ",
                "loaded into RT56:63. RT0:55 are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhz",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "40", "RT", "RA", "D" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "RT := 480 || MEM(EA, 2)"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT48:63. RT0:47 are set to 0."
            ]
        },
        {
            "description": "Load Halfword and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhzx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "279", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := 480 || MEM(EA, 2)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The halfword in storage addressed by ",
                "EA is loaded into RT48:63. RT0:47 are set to 0."
            ]
        },
        {
            "description": "Load Halfword and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhzu",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "41", "RT", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := 480 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT48:63. RT0:47 are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhzux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "311", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := 480 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). The halfword in storage addressed by ",
                "EA is loaded into RT48:63. RT0:47 are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword Algebraic",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lha",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "42", "RT", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT48:63. RT0:47 are filled with a copy of bit 0 of the ",
                "loaded halfword."
            ]
        },
        {
            "description": "Load Halfword Algebraic Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhax",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "343", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The halfword in storage addressed by ",
                "EA is loaded into RT48:63. RT0:47 are filled with a copy ",
                "of bit 0 of the loaded halfword."
            ]
        },
        {
            "description": "Load Halfword Algebraic with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhau",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "43", "RT", "RA", "D" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "The halfword in storage addressed by EA is loaded into ",
                "RT48:63. RT0:47 are filled with a copy of bit 0 of the ",
                "loaded halfword.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Halfword Algebraic with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhaux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "375", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). The halfword in storage addressed by ",
                "EA is loaded into RT48:63. RT0:47 are filled with a copy ",
                "of bit 0 of the loaded halfword.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word and Zero",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwz",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "32", "RT", "RA", "D" ],
                [ "0 ", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "RT := 320 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "The word in storage addressed by EA is loaded into ",
                "RT32:63. RT0:31 are set to 0."
            ]
        },
        {
            "description": "Load Word and Zero Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "23", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := 320 || MEM(EA, 4)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The word in storage addressed by EA ",
                "is loaded into RT32:63. RT0:31 are set to 0."
            ]
        },
        {
            "description": "Load Word and Zero with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzu",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "33", "RT", "RA", "D" ],
                [ "0", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := 320 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "The word in storage addressed by EA is loaded into ",
                "RT32:63. RT0:31 are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word and Zero with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "55", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := 320 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). The word in storage addressed by EA is ",
                "loaded into RT32:63. RT0:31 are set to 0.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word Algebraic",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwa",
                    "regs": [ "RT,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "58", "RT", "RA", "DS", "2" ],
                [ "0 ", "6", "11", "16", "30 31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS || 0b00)",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(DS||0b00). The word in storage addressed ",
                "by EA is loaded into RT32:63. RT0:31 are filled with a ",
                "copy of bit 0 of the loaded word."
            ]
        },
        {
            "description": "Load Word Algebraic Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwax",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "341", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The word in storage addressed by EA ",
                "is loaded into RT32:63. RT0:31 are filled with a copy of bit ",
                "0 of the loaded word."
            ]
        },
        {
            "description": "Load Word Algebraic with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwaux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "373", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). The word in storage addressed by EA is ",
                "loaded into RT32:63. RT0:31 are filled with a copy of bit 0 ",
                "of the loaded word.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Doubleword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ld",
                    "regs": [ "RT,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "58", "RT", "RA", "DS", "0" ],
                [ "0 ", "6 ", "11 ", "16 ", "30 31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS || 0b00)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(DS||0b00). The doubleword in storage ",
                "addressed by EA is loaded into RT."
            ]
        },
        {
            "description": "Load Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "21", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). The doubleword in storage addressed ",
                "by EA is loaded into RT."
            ]
        },
        {
            "description": "Load Doubleword with Update",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldu",
                    "regs": [ "RT,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "58", "RT", "RA", "DS", "1" ],
                [ "0 ", "6", "11", "16", "30 31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(DS||0b00). The doubleword in storage ",
                "addressed by EA is loaded into RT.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Doubleword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldux",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "53", "/" ],
                [ "0", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). The doubleword in storage addressed ",
                "by EA is loaded into RT.",
                "EA is placed into register RA.",
                "If RA=0 or RA=RT, the instruction form is invalid."
            ]
        },
        {
            "description": "Load Word and Zero Monitored Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwzmx",
                    "regs": [ "RT,RA,RB" ],
                    "release": ""
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "437", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "loaded_ea := 320 || MEM(EA,4)",
                "n := (LMRRSHIFT)",
                "if n=1",
                " loaded_ea := ROTL(loaded_ea,3)",
                " else if n=2",
                " loaded_ea := ROTL(loaded_ea,4)",
                "if :=((loaded_ea is in enabled section of",
                "  load-monitored region) & BESCRGE LME=0b11)",
                "RT := loaded_ea",
                " "
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). ",
                "The word in storage addressed by EA is accessed, ",
                "zero-extended to a doubleword with bits 0:31 set to 0s, ",
                "and rotated left by 3 if the value of LMRRSHIFT=1 or by ",
                "4 if the value of LMRRSHIFT=2.",
                "If the doubleword resulting from the above operations, ",
                "interpreted as an effective address, is not equal to an ",
                "effective address within an enabled section of the Load ",
                "Monitored region, or if Load Monitored event-based ",
                "exceptions are disabled (BESCRLME=0 or BES",
                "CRGE=0), the doubleword is placed into RT; otherwise ",
                "a Load Monitored event-based branch occurs. (The ",
                "Load Monitored region is described in Section 3.2.4. ",
                "Event-based branches and the BESCR are described ",
                "in Chapter 7 of Book II.)",
                "The word in storage specified by the lwzmx instruction ",
                "should not be in storage that is either Caching Inhibited ",
                "or Guarded; execution of an lwzmx instruction to ",
                "access storage with either of these attributes will result ",
                "in boundedly undefined behavior. (See Section 1.6.2 ",
                "and Section1.6.4 of Book II.)",
                "In privileged state, this instruction is an illegal instruc",
                "tion and an attempt to execute it will invoke the system ",
                "illegal instruction error handler. See Section4.4.4 of ",
                "Book III.",
                " ",
                ""
            ]
        },
        {
            "description": "Load Doubleword Monitored Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldmx",
                    "regs": [ "RT,RA,", "RB" ],
                    "release": ""
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "309", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "loaded_ea := MEM(EA,8)",
                "if :=((loaded_ea is in enabled section of",
                "  load-monitored region) & BESCRGE LME=0b11)",
                "RT := loaded_ea",
                " "
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). ",
                "The doubleword in storage addressed by EA is ",
                "accessed. If the accessed doubleword, interpreted as ",
                "an effective address, is not equal to an effective ",
                "address within an enabled section of the Load Moni",
                "tored region, or if Load Monitored event-based ",
                "branches are disabled (BESCRLME=0 or BESCRGE=0), ",
                "the doubleword is placed into RT; otherwise a Load ",
                "Monitored event-based branch occurs. (The Load Mon",
                "itored region is described in Section 3.2.4. Event-based ",
                "branches and the BESCR are described in Chapter 7 of ",
                "Book II.)",
                "The doubleword in storage specified by the ldmx ",
                "instruction should not be in storage that is either Cach",
                "ing Inhibited or Guarded; execution of an ldmx instruc",
                "tion to access storage with either of these attributes will ",
                "result in boundedly undefined behavior. (See ",
                "Section1.6 of Book II.)",
                "In privileged state, this instruction is an illegal instruc",
                "tion and an attempt to execute it will invoke the system ",
                "illegal instruction error handler. See Section4.4.4 of ",
                "Book III for additional information.",
                " ",
                " ",
                "  "
            ]
        },
        {
            "description": "Store Byte",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stb",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "38", "RS", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "MEM(EA, 1) := (RS)56:63",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "(RS)56:63 are stored into the byte in storage addressed ",
                "by EA."
            ]
        },
        {
            "description": "Store Byte Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stbx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "215", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 1) := (RS)56:63",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)56:63 are stored into the byte in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Byte with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stbu",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "39", "RS", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 1) := (RS)56:63",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "(RS)56:63 are stored into the byte in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Byte with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stbux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "247", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 1) := (RS)56:63",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). (RS)56:63 are stored into the byte in stor",
                "age addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Halfword",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sth",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "44", "RS", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "MEM(EA, 2) := (RS)48:63",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "(RS)48:63 are stored into the halfword in storage ",
                "addressed by EA."
            ]
        },
        {
            "description": "Store Halfword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "407", "/" ],
                [ "0", "6", "11", "16 ", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)48:63",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)48:63 are stored into the halfword ",
                "in storage addressed by EA."
            ]
        },
        {
            "description": "Store Halfword with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthu",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "45", "RS", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 2) := (RS)48:63",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "(RS)48:63 are stored into the halfword in storage ",
                "addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Halfword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "439", "/" ],
                [ "0", "6", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 2) := (RS)48:63",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). (RS)48:63 are stored into the halfword in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stw",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "36", "RS", "RA", "D" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "MEM(EA, 4) := (RS)32:63",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+D. ",
                "(RS)32:63 are stored into the word in storage addressed ",
                "by EA."
            ]
        },
        {
            "description": "Store Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "151", "/" ],
                [ "0", "6 ", "11", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)32:63",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)32:63 are stored into the word in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Word with Update",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwu",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "37", "RS", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := (RS)32:63",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA)+D. ",
                "(RS)32:63 are stored into the word in storage addressed ",
                "by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Word with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "183", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := (RS)32:63",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). (RS)32:63 are stored into the word in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Doubleword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "std",
                    "regs": [ "RS,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "62", "RS", "RA", "DS", "0" ],
                [ "0 ", "6 ", "11 ", "16 ", "30 31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS || 0b00)",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(DS||0b00). (RS) is stored into the double",
                "word in storage addressed by EA."
            ]
        },
        {
            "description": "Store Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "149", "/" ],
                [ "0", "6", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS) is stored into the doubleword in ",
                "storage addressed by EA."
            ]
        },
        {
            "description": "Store Doubleword with Update",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdu",
                    "regs": [ "RS,DS(RA)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "62", "RS", "RA", "DS", "1" ],
                [ "0 ", "6 ", "11 ", "16 ", "30 31" ]
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "MEM(EA, 8) := (RS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(DS||0b00). (RS) is stored into the doubleword ",
                "in storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Doubleword with Update Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdux",
                    "regs": [ "RS,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "181", "/" ],
                [ "0", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (RS)",
                "",
                "RA := EA"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA)+(RB). (RS) is stored into the doubleword in ",
                "storage addressed by EA.",
                "EA is placed into register RA.",
                "If RA=0, the instruction form is invalid."
            ]
        },
        {
            "description": "Store Quadword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stq",
                    "regs": [ "RSp,DS(RA)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "62", "RSp", "RA", "DS", "2" ],
                [ "0 ", "6", "11", "16", "30 31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +tea EXTS(DS || 0b00)",
                "",
                "MEM(EA, 16) := RSp",
                "if tags active then MEMtag(EA) := XER43",
                "else                MEMtag(EA) := 0"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+tea(DS||0b00). The content of register pair RSp ",
                "is stored into the quadword in storage addressed by ",
                "EA.",
                "In tags active mode, the tag bit of the quadword in stor",
                "age is set to the value of XER43. In tags inactive mode, ",
                "the tag bit of the quadword in storage is set to zero.",
                "In tags active mode, EA must be a multiple of 16. If it is ",
                "not, the system alignment error handler is invoked.",
                " If RSp is odd, the instruction form is invalid. "
            ]
        },
        {
            "description": "Load Quadword",
            "form": "DQ-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lq",
                    "regs": [ "RTp,DQ(RA)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "56", "RTp", "RA", "DQ", "///" ],
                [ "0 ", "6", "11 ", "16", "28    31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DQ || 0b0000)",
                "RTp := MEM(EA, 16)"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+ ",
                "(DQ||0b0000). The quadword in storage addressed by ",
                "EA is loaded into register pair RTp.",
                "If RTp is odd or RTp=RA, the instruction form is invalid. ",
                "If RTp=RA, an attempt to execute this instruction will ",
                "invoke the system illegal instruction error handler. (The ",
                "RTp=RA case includes the case of RTp=RA=0.)",
                "The quadword in storage addressed by EA is loaded ",
                "into an even-odd pair of GPRs as follows. In ",
                "Big-Endian mode, the even-numbered GPR is loaded ",
                "with the doubleword from storage addressed by EA ",
                "and the odd-numbered GPR is loaded with the double",
                "word addressed by EA+8. In Little-Endian mode, the ",
                "even-numbered GPR is loaded with the byte-reversed  ",
                "doubleword from storage addressed by EA+8 and the ",
                "odd-numbered GPR is loaded with the byte-reversed ",
                "doubleword addressed by EA.",
                " "
            ]
        },
        {
            "description": "Store Quadword",
            "form": "DS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stq",
                    "regs": [ "RSp,DS(RA)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "62", "RSp", "RA", "DS", "2" ],
                [ "0 ", "6", "11 ", "16", "30 31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS || 0b00)",
                "MEM(EA, 16) := RSp"
            ],
            "body": [
                "Let the effective address (EA) be the sum (RA|0)+ ",
                "(DS||0b00). The contents of register pair RSp are ",
                "stored into the quadword in storage addressed by EA.",
                "If RSp is odd, the instruction form is invalid.",
                "The contents of an even-odd pair of GPRs is stored into ",
                "the quadword in storage addressed by EA as follows. ",
                "In Big-Endian mode, the even-numbered GPR is stored ",
                "into the doubleword in storage addressed by EA and ",
                "the odd-numbered GPR is stored into the doubleword ",
                "addressed by EA+8. In Little-Endian mode, the ",
                "even-numbered GPR is stored byte-reversed into the ",
                "doubleword in storage addressed by EA+8 and the ",
                "odd-numbered GPR is stored byte-reversed into the ",
                "doubleword addressed by EA.",
                " "
            ]
        },
        {
            "description": "Load Tagged Pointer",
            "form": "DQE-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ltptr",
                    "regs": [ "RT,DQ(RA),EPT" ],
                    "release": "v2.06AS"
                }
            ],
            "layout": [
                [ "57", "RT", "RA", "DQ", "EPT", "1" ],
                [ "0 ", "6", "11 ", "16", "28", " 30   31" ]
            ],
            "code": [
                "This instruction uses a DECODE function",
                "   y = DECODE(x) defined by:",
                "           x    y",
                "          00   1000",
                "          01   0100",
                "          10   0010",
                "          11   0001",
                "",
                "and a DECODE1 function",
                "   y = DECODE1(x) defined by:",
                "           x    y",
                "          00   0010",
                "          01   0100",
                "          10   0110",
                "          11   1000",
                "",
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +tea EXTS(DQ || 0b0000)",
                "pt := DECODE1(EPT)",
                "if ((DECODE(MEM0:1(EA,1)) & pt) ¹ 0b0000) &",
                "(MEM2(EA,1) = 0) & (MEMtag(EA) = 1)",
                "then RT := MEM(EA+8, 8)",
                "else RT := 0",
                "XER41:43 := undefined",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+tea(DQ||0b0000). The doubleword in storage ",
                "addressed by EA+8 is loaded into register RT if all of ",
                "the following conditions are met:",
                "Otherwise RT is set to 0. The DECODE and DECODE1 ",
                "functions are defined above in the RTL description.",
                "The contents of XER41:43 are undefined. ",
                "EA must be a multiple of 16. If it is not, the system ",
                "alignment error handler is invoked.",
                "",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute it will invoke the ",
                "system illegal instruction error handler.",
                "  ",
                "  "
            ]
        },
        {
            "description": "Load Halfword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lhbrx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "790", "/" ],
                [ "0", "6", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 2)",
                "RT := 480 || load_data8:15 || load_data0:7"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). Bits 0:7 of the halfword in storage ",
                "addressed by EA are loaded into RT56:63. Bits 8:15 of ",
                "the halfword in storage addressed by EA are loaded ",
                "into RT48:55. RT0:47 are set to 0."
            ]
        },
        {
            "description": "Store Halfword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sthbrx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "918", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)56:63 || (RS)48:55",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)56:63 are stored into bits 0:7 of the ",
                "halfword in storage addressed by EA. (RS)48:55 are ",
                "stored into bits 8:15 of the halfword in storage ",
                "addressed by EA."
            ]
        },
        {
            "description": "Load Word Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lwbrx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "534", "/" ],
                [ "0", "6", "11 ", "16", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 4)",
                "RT := 320 || load_data24:31 || load_data16:23",
                "         || load_data8:15 || load_data0:7"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). Bits 0:7 of the word in storage ",
                "addressed by EA are loaded into RT56:63. Bits 8:15 of ",
                "the word in storage addressed by EA are loaded into ",
                "RT48:55. Bits 16:23 of the word in storage addressed by ",
                "EA are loaded into RT40:47. Bits 24:31 of the word in ",
                "storage addressed by EA are loaded into RT32:39. ",
                "RT0:31 are set to 0."
            ]
        },
        {
            "description": "Store Word Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stwbrx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "662", "/" ],
                [ "0 ", "6 ", "11 ", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)56:63 || (RS)48:55 || (RS)40:47",
                "               ||(RS)32:39",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)56:63 are stored into bits 0:7 of the ",
                "word in storage addressed by EA. (RS)48:55 are stored ",
                "into bits 8:15 of the word in storage addressed by EA. ",
                "(RS)40:47 are stored into bits 16:23 of the word in stor",
                "age addressed by EA. (RS)32:39 are stored into bits ",
                "24:31 of the word in storage addressed by EA."
            ]
        },
        {
            "description": "Load Doubleword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ldbrx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "532", "/" ],
                [ "0", "6", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 8)",
                "RT :=  load_data56:63 || load_data48:55",
                "|| load_data40:47 || load_data32:39",
                "|| load_data24:31 || load_data16:23",
                "|| load_data8:15  || load_data0:7"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). Bits 0:7 of the doubleword in storage ",
                "addressed by EA are loaded into RT56:63. Bits 8:15 of ",
                "the doubleword in storage addressed by EA are loaded ",
                "into RT48:55. Bits 16:23 of the doubleword in storage ",
                "addressed by EA are loaded into RT40:47. Bits 24:31 of ",
                "the doubleword in storage addressed by EA are loaded ",
                "into RT32:39. Bits 32:39 of the doubleword in storage ",
                "addressed by EA are loaded into RT24:31. Bits 40:47 of ",
                "the doubleword in storage addressed by EA are loaded ",
                "into RT16:23. Bits 48:55 of the doubleword in storage ",
                "addressed by EA are loaded into RT8:15. Bits 56:63 of ",
                "the doubleword in storage addressed by EA are loaded ",
                "into RT0:7."
            ]
        },
        {
            "description": "Store Doubleword Byte-Reverse Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stdbrx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "660", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)56:63 || (RS)48:55",
                "|| (RS)40:47 || (RS)32:39",
                "|| (RS)24:31 || (RS)16:23",
                "|| (RS)8:15  || (RS)0:7",
                ""
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). (RS)56:63 are stored into bits 0:7 of the ",
                "doubleword in storage addressed by EA. (RS)48:55 are ",
                "stored into bits 8:15 of the doubleword in storage ",
                "addressed by EA. (RS)40:47 are stored into bits 16:23 of ",
                "the doubleword in storage addressed by EA. (RS)32:39 ",
                "are stored into bits 23:31 of the doubleword in storage ",
                "addressed by EA. (RS)24:31 are stored into bits 32:39 of ",
                "the doubleword in storage addressed by EA. (RS)16:23 ",
                "are stored into bits 40:47 of the doubleword in storage ",
                "addressed by EA. (RS)8:15 are stored into bits 48:55 of ",
                "the doubleword in storage addressed by EA. (RS)0:7 ",
                "are stored into bits 56:63 of the doubleword in storage ",
                "addressed by EA."
            ]
        },
        {
            "description": "Load Multiple Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lmw",
                    "regs": [ "RT,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "46", "RT", "RA", "D" ],
                [ "0 ", "6 ", "11 ", "16                                                     31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RT",
                "do while r <= 31",
                "GPR(r) := 320 || MEM(EA, 4)",
                "r := r + 1",
                "EA := EA + 4"
            ],
            "body": [
                "Let n = (32-RT). Let the effective address (EA) be the ",
                "sum (RA|0)+D.",
                "n consecutive words starting at EA are loaded into the ",
                "low-order 32 bits of GPRs RT through 31. The ",
                "high-order 32 bits of these GPRs are set to zero.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Store Multiple Word",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stmw",
                    "regs": [ "RS,D(RA)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "47", "RS", "RA", "D" ],
                [ "0 ", "6", "11 ", "16                                                     31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RS",
                "do while r <= 31",
                "MEM(EA, 4) := GPR(r)32:63",
                "",
                "r := r + 1",
                "EA := EA + 4"
            ],
            "body": [
                "Let n = (32-RS). Let the effective address (EA) be the ",
                "sum (RA|0)+D.",
                "n consecutive words starting at EA are stored from the ",
                "low-order 32 bits of GPRs RS through 31.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "",
            "form": "",
            "category": "",
            "mnemonics": [
                {
                    "mnemonic": "stmd",
                    "regs": [ "RS,DS(RA)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "62", "RS", "RA", "DS", "3" ],
                [ "0", "6", "11", "16", "30   31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +tea EXTS(DS || 0b00)",
                "r := RS",
                "do while r <= 31",
                "MEM(EA, 8) := GPR(r)",
                "MEMtag(EA, 8) := 0",
                "r := r + 1",
                "EA := EA +tea 8"
            ],
            "body": [

            ]
        },
        {
            "description": "Load String Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lswi",
                    "regs": [ "RT,RA,NB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "NB", "597", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RT - 1",
                "i := 32",
                "do while n > 0",
                "if i = 32 then",
                "  r := r + 1 (mod 32)",
                "  GPR(r) := 0",
                "GPR(r)i:i+7 := MEM(EA, 1)",
                "i := i + 8",
                "if i = 64 then i := 32",
                "EA := EA + 1",
                "n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB¹0, n = 32 if NB=0; n is the number of bytes to load. ",
                "Let nr=CEIL(n/4); nr is the number of registers to ",
                "receive data.",
                "n consecutive bytes starting at EA are loaded into ",
                "GPRs RT through RT+nr-1. Data are loaded into the ",
                "low-order four bytes of each GPR; the high-order four ",
                "bytes are set to 0.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If the low-order four bytes of register RT+nr-1 ",
                "are only partially filled, the unfilled low-order byte(s) of ",
                "that register are set to 0.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Load String Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lswx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "533", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER57:63",
                "r := RT - 1",
                "i := 32",
                "RT := undefined",
                "do while n > 0",
                "if i = 32 then",
                " r := r + 1 (mod 32)",
                " GPR(r) := 0",
                "GPR(r)i:i+7 := MEM(EA, 1)",
                "i := i + 8",
                "if i = 64 then i := 32",
                "EA := EA + 1",
                "n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). Let n=XER57:63; n is the number of ",
                "bytes to load. Let nr=CEIL(n/4); nr is the number of reg",
                "isters to receive data.",
                "If n>0, n consecutive bytes starting at EA are loaded ",
                "into GPRs RT through RT+nr-1. Data are loaded into ",
                "the low-order four bytes of each GPR; the high-order ",
                "four bytes are set to 0.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If the low-order four bytes of register RT+nr-1 ",
                "are only partially filled, the unfilled low-order byte(s) of ",
                "that register are set to 0.",
                "If n=0, the contents of register RT are undefined.",
                "If RA or RB is in the range of registers to be loaded, ",
                "including the case in which RA=0, the instruction is ",
                "treated as if the instruction form were invalid. If RT=RA ",
                "or RT=RB, the instruction form is invalid.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode and n>0, the sys",
                "tem alignment error handler is invoked."
            ]
        },
        {
            "description": "",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lsdi",
                    "regs": [ "RT,RA,NB" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "NB", "629", "/" ],
                [ "0", "6", "11 ", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RT - 1",
                "i := 0",
                "do while n > 0",
                "  if i = 0 then",
                "    r := r + 1 (mod 32)",
                "    GPR(r) := 0",
                "  GPR(r)i:i+7 := MEM(EA, 1)",
                "  i := i + 8 (mod 64)",
                "  EA := EA +tea 1",
                "  n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n=NB if ",
                "NB¹0, n=32 if NB=0: n is the number of bytes to load. ",
                "Let nr=CEIL(n/8): nr is the number of registers to ",
                "receive data.",
                "n consecutive bytes starting at EA are loaded into ",
                "GPRs RT through RT+nr-1. Data are loaded into all ",
                "eight bytes of each GPR.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If register RT+nr-1 is only partially filled, the ",
                "unfilled low-order byte(s) of that register are set to 0.",
                "If RA is in the range of registers to be loaded, including ",
                "the case in which RA=0, the instruction form is invalid.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler."
            ]
        },
        {
            "description": "Load String Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "lsdx",
                    "regs": [ "RT,RA,RB" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "565", "/" ],
                [ "0 ", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +tea (RB)",
                "n := XER57:63",
                "r := RT - 1",
                "i := 0",
                "RT := undefined",
                "do while n > 0",
                "  if i = 0 then",
                "    r := r + 1 (mod 32)",
                "    GPR(r) := 0",
                "  GPR(r)i:i+7 := MEM(EA, 1)",
                "  i := i + 8 (mod 64)",
                "  EA := EA +tea 1",
                "  n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+tea(RB). Let n=XER57:63: n is the number of ",
                "bytes to load. Let nr=CEIL(n/8): nr is the number of reg",
                "isters to receive data.",
                "If n>0, n consecutive bytes starting at EA are loaded ",
                "into GPRs RT through RT+nr-1. Data are loaded into ",
                "all eight bytes of each GPR.",
                "Bytes are loaded left to right in each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required. If register RT+nr-1 is only partially filled, the ",
                "unfilled low-order byte(s) of that register are set to 0.",
                "If n=0, the contents of register RT are undefined.",
                "If RA or RB is in the range of registers to be loaded, ",
                "including the case in which RA=0, the instruction is ",
                "treated as if the instruction form were invalid. If RT=RA ",
                "or RT=RB, the instruction form is invalid.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler."
            ]
        },
        {
            "description": "Store String Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stswi",
                    "regs": [ "RS,RA,NB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "NB", "725", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RS - 1",
                "i := 32",
                "do while n > 0",
                "  if i = 32 then r := r + 1 (mod 32)",
                "  MEM(EA, 1) := GPR(r)i:i+7",
                " ",
                "  i := i + 8",
                "  if i = 64 then i := 32",
                "  EA := EA + 1",
                "  n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB¹0, n = 32 if NB=0; n is the number of bytes to store. ",
                "Let nr =CEIL(n/4); nr is the number of registers to sup",
                "ply data.",
                "n consecutive bytes starting at EA are stored from ",
                "GPRs RS through RS+nr-1. Data are stored from the ",
                "low-order four bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode, the system align",
                "ment error handler is invoked."
            ]
        },
        {
            "description": "Store String Word Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stswx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "661", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER57:63",
                "r := RS - 1",
                "i := 32",
                "do while n > 0",
                "  if i = 32 then r := r + 1 (mod 32)",
                "  MEM(EA, 1) := GPR(r)i:i+7",
                "  ",
                "  i := i + 8",
                "  if i = 64 then i := 32",
                "  EA := EA + 1",
                "  n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+(RB). Let n = XER57:63; n is the number of ",
                "bytes to store. Let nr = CEIL(n/4); nr is the number of ",
                "registers to supply data.",
                "If n>0, n consecutive bytes starting at EA are stored ",
                "from GPRs RS through RS+nr-1. Data are stored from ",
                "the low-order four bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "If n=0, no bytes are stored.",
                "This instruction is not supported in Little-Endian mode. ",
                "If it is executed in Little-Endian mode and n>0, the sys",
                "tem alignment error handler is invoked."
            ]
        },
        {
            "description": "X-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stsdi",
                    "regs": [ "RS,RA,NB" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "NB", "757", "/" ],
                [ "0", "6", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RS - 1",
                "i := 0",
                "do while n > 0",
                "  if i = 0 then r := r + 1 (mod 32)",
                "  MEM(EA, 1) := GPR(r)i:i+7",
                "  MEMtag(EA) := 0",
                "  i := i + 8 (mod 64)",
                "  EA := EA +tea 1",
                "  n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be (RA|0). Let n = NB if ",
                "NB¹0, n=32 if NB=0: n is the number of bytes to store. ",
                "Let nr =CEIL(n/8): nr is the number of registers to sup",
                "ply data.",
                "n consecutive bytes starting at EA are stored from ",
                "GPRs RS through RS+nr-1. Data are stored from all ",
                "eight bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler."
            ]
        },
        {
            "description": "Store String Doubleword Indexed",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "stsdx",
                    "regs": [ "RS,RA,RB" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "693", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21", "31" ]
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +tea (RB)",
                "n := XER57:63",
                "r := RS - 1",
                "i := 0",
                "do while n > 0",
                "  if i = 0 then r := r + 1 (mod 32)",
                "  MEM(EA, 1) := GPR(r)i:i+7",
                "  MEMtag(EA) := 0",
                "  i := i + 8 (mod 64)",
                "  EA := EA +tea 1",
                "  n := n - 1"
            ],
            "body": [
                "Let the effective address (EA) be the sum ",
                "(RA|0)+tea(RB). Let n=XER57:63: n is the number of ",
                "bytes to store. Let nr=CEIL(n/8): nr is the number of ",
                "registers to supply data.",
                "If n>0, n consecutive bytes starting at EA are stored ",
                "from GPRs RS through RS+nr-1. Data are stored from ",
                "all eight bytes of each GPR.",
                "Bytes are stored left to right from each register. The ",
                "sequence of registers wraps around to GPR 0 if ",
                "required.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler.",
                "If n=0, no bytes are stored."
            ]
        },
        {
            "description": "Add Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addi",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "14", "RT", "RA", "SI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then RT := EXTS(SI)",
                "else           RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA|0) + SI is placed into register RT.",
                "Examples of extended mnemonics for Add Immediate:",
                "  "
            ]
        },
        {
            "description": "Add Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addis",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "15", "RT", "RA", "SI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "if RA = 0 then RT := EXTS(SI || 160)",
                "else           RT := (RA) + EXTS(SI || 160)"
            ],
            "body": [
                "The sum (RA|0) + (SI||0x0000) is placed into register ",
                "RT.",
                "Examples of extended mnemonics for Add Immediate ",
                "Shifted:"
            ]
        },
        {
            "description": "Add PC Immediate Shifted",
            "form": "DX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addpcis",
                    "regs": [ "RT,D" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                [ "19", "", "", "", "", "", "RT", "", "", "", "", "d1", "", "", "", "", "d0", "", "", "", "", "", "", "", "", "", "2", "", "", "", "", "d2" ]
            ],
            "code": [
                "D := d0||d1||d2",
                "RT := NIA + EXTS(D || 160)"
            ],
            "body": [
                "The sum of NIA + (D||0x0000) is placed into register ",
                "RT. ",
                "",
                "Examples of extended mnemonics for Add PC Immedi",
                "ate Shifted:"
            ]
        },
        {
            "description": "Add",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "add",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "add.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "266", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21", "22 ", "31" ]
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "The sum (RA) + (RB) is placed into register RT."
            ]
        },
        {
            "description": "Subtract From",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subf",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subf.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subfo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "subfo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "40", "Rc" ],
                [ "0 ", "6  ", "11 ", "16", "21", "22 ", "31" ]
            ],
            "code": [
                "RT := :=(RA) + (RB) + 1"
            ],
            "body": [
                "The sum ¬(RA) + (RB) +1 is placed into register RT.",
                "Example of extended mnemonics for Subtract From:"
            ]
        },
        {
            "description": "Add Immediate Carrying",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addic",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "12", "RT", "RA", "SI" ],
                [ "0", "6", "11", "16                                                     31" ]
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA) + SI is placed into register RT.",
                "Example of extended mnemonics for Add Immediate ",
                "Carrying:"
            ]
        },
        {
            "description": "Add Immediate Carrying and Record",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addic.",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "13", "RT", "RA", "SI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "The sum (RA) + SI is placed into register RT.",
                "Example of extended mnemonics for Add Immediate ",
                "Carrying and Record:"
            ]
        },
        {
            "description": "Subtract From Immediate Carrying",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfic",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "8", "RT", "RA", "SI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [

            ],
            "body": [
                "RT ¬ ¬(RA) + EXTS(SI) + 1",
                "The sum ¬(RA) + SI + 1 is placed into register RT.",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        {
            "description": "Add Carrying",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addc",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addc.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addco",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addco.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "10", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "The sum (RA) + (RB) is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Carrying",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfc",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfc.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfco",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfco.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "8", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := :=(RA) + (RB) + 1"
            ],
            "body": [
                "The sum ¬(RA) + (RB) + 1 is placed into register RT.",
                "Example of extended mnemonics for Subtract From ",
                "Carrying:"
            ]
        },
        {
            "description": "Add Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "adde",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "adde.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addeo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addeo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "138", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := (RA) + (RB) + CA"
            ],
            "body": [
                "The sum (RA) + (RB) + CA is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfe",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfe.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfeo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfeo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "136", "Rc" ],
                [ "0", "6", "11 ", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := :=(RA) + (RB) + CA"
            ],
            "body": [
                "The sum ¬(RA) + (RB) + CA is placed into register RT."
            ]
        },
        {
            "description": "Add to Minus One Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addme",
                    "regs": [ "RT,RA", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addme.",
                    "regs": [ "RT,RA", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addmeo",
                    "regs": [ "RT,RA", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addmeo.",
                    "regs": [ "RT,RA", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "///", "OE", "234", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21", "22", "31" ]
            ],
            "code": [
                "RT := (RA) + CA - 1"
            ],
            "body": [
                "The sum (RA) + CA + 641 is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Minus One Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfme",
                    "regs": [ "RT,RA", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfme.",
                    "regs": [ "RT,RA", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfmeo",
                    "regs": [ "RT,RA", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfmeo.",
                    "regs": [ "RT,RA", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "///", "OE", "232", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := :=(RA) + CA - 1"
            ],
            "body": [
                "The sum ¬(RA) + CA + 641 is placed into register RT."
            ]
        },
        {
            "description": "Add Extended using alternate carry bit Z23",
            "form": "-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addex",
                    "regs": [ "RT,RA,RB,CY" ],
                    "release": "v3.0B"
                }
            ],
            "layout": [

            ],
            "code": [
                "if CY=0 then RT := (RA) + (RB) + OV"
            ],
            "body": [
                "For CY=0, the sum (RA) + (RB) + OV is placed into regis",
                "ter RT.",
                "For CY=0, OV is set to 1 if there is a carry out of bit 0 of ",
                "the sum in 64-bit mode or there is a carry out of bit 32 ",
                "of the sum in 32-bit mode, and set to 0 otherwise. ",
                "OV32 is set to 1 if there is a carry out of bit 32 bit of the ",
                "sum.",
                "CY=1, CY=2, and CY=3 are reserved.",
                "  "
            ]
        },
        {
            "description": "Add to Zero Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addze",
                    "regs": [ "RT,RA", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addze.",
                    "regs": [ "RT,RA", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addzeo",
                    "regs": [ "RT,RA", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "addzeo.",
                    "regs": [ "RT,RA", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "///", "OE", "202", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := (RA) + CA"
            ],
            "body": [
                "The sum (RA) + CA is placed into register RT."
            ]
        },
        {
            "description": "Subtract From Zero Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "subfze",
                    "regs": [ "RT,RA", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfze.",
                    "regs": [ "RT,RA", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfzeo",
                    "regs": [ "RT,RA", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "subfzeo.",
                    "regs": [ "RT,RA", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "///", "OE", "200", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := :=(RA) + CA"
            ],
            "body": [
                "The sum ¬(RA) + CA is placed into register RT.",
                ""
            ]
        },
        {
            "description": "Negate",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "neg",
                    "regs": [ "RT,RA", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "neg.",
                    "regs": [ "RT,RA", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nego",
                    "regs": [ "RT,RA", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nego.",
                    "regs": [ "RT,RA", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "///", "OE", "104", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := :=(RA) + 1"
            ],
            "body": [
                "The sum ¬(RA) + 1 is placed into register RT.",
                "If the processor is in 64-bit mode and register RA con",
                "tains the most negative 64-bit number (0x8000_ ",
                "0000_0000_0000), the result is the most negative num",
                "ber and, if OE=1, OV is set to 1. If (RA)32:63 contain the ",
                "most negative 32-bit number (0x8000_0000) and ",
                "OE=1, OV32 is set to 1.",
                "Similarly, if the processor is in 32-bit mode and ",
                "(RA)32:63 contain the most negative 32-bit number ",
                "(0x8000_0000), the low-order 32 bits of the result con",
                "tain the most negative 32-bit number and, if OE=1, OV ",
                "and OV32 are set to 1. "
            ]
        },
        {
            "description": "Multiply Low Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulli",
                    "regs": [ "RT,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "7", "RT", "RA", "SI" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "prod0:127 := (RA) ´ EXTS(SI)",
                "RT := prod64:127"
            ],
            "body": [
                "The 64-bit first operand is (RA). The 64-bit second ",
                "operand is the sign-extended value of the SI field. The ",
                "low-order 64 bits of the 128-bit product of the operands ",
                "are placed into register RT.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply Low Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mullw",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullw.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullwo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "mullwo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "235", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "RT := (RA)32:63 ´ (RB)32:63"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA ",
                "and of RB. The 64-bit product of the operands is placed ",
                "into register RT.",
                "If OE=1 then OV and OV32 are set to 1 if the product ",
                "cannot be represented in 32 bits.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhw",
                    "regs": [ "RT,RA,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhw.",
                    "regs": [ "RT,RA,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "/", "75", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21", "22 ", "31" ]
            ],
            "code": [
                "prod0:63 := (RA)32:63 ´ (RB)32:63",
                "RT32:63 := prod0:31",
                "RT0:31 := undefined"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA ",
                "and of RB. The high-order 32 bits of the 64-bit product ",
                "of the operands are placed into RT32:63. The contents ",
                "of RT0:31 are undefined.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Word Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhwu",
                    "regs": [ "RT,RA,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhwu.",
                    "regs": [ "RT,RA,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "/", "11", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "prod0:63 := (RA)32:63 ´ (RB)32:63",
                "RT32:63 := prod0:31",
                "RT0:31 := undefined"
            ],
            "body": [
                "The 32-bit operands are the low-order 32 bits of RA ",
                "and of RB. The high-order 32 bits of the 64-bit product ",
                "of the operands are placed into RT32:63. The contents ",
                "of RT0:31 are undefined.",
                "Both operands and the product are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero."
            ]
        },
        {
            "description": "Divide Word",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divw",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divw.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "491", "Rc" ],
                [ "0", "6 ", "11 ", "16 ", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:31  := (RA)32:63",
                "divisor0:31 := (RB)32:63",
                "RT32:63 := dividend ¸ divisor",
                "RT0:31 := undefined",
                "",
                "   0x8000_0000 ¸ -1",
                "   <anything> ¸ 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)32:63. The 32-bit divisor is ",
                "(RB)32:63. The 32-bit quotient is placed into RT32:63. ",
                "The contents of RT0:31 are undefined. The remainder is ",
                "not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnegative, ",
                "and -|divisor| < r £ 0 if the dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined as are ",
                "(ifRc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divwu",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwu.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwuo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divwuo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "459", "Rc" ],
                [ "0 ", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:31  := (RA)32:63",
                "divisor0:31 := (RB)32:63",
                "RT32:63 := dividend ¸ divisor",
                "RT0:31 := undefined",
                "",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 32 bit dividend is (RA)32:63. The 32-bit divisor is ",
                "(RB)32:63. The 32-bit quotient is placed into RT32:63. ",
                "The contents of RT0:31 are undefined. The remainder is ",
                "not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero. The quotient is the unique unsigned inte",
                "ger that satisfies",
                "where 0 £ r < divisor.",
                "If an attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In this case, if OE=1 then OV ",
                "and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divwe",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divwe.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "427", "Rc" ],
                [ "0", "6 ", "11 ", "16 ", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:63 := (RA)32:63 || 320",
                "divisor0:31 := (RB)32:63",
                "RT32:63 := dividend ¸ divisor",
                "RT0:31 := undefined",
                "",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA)32:63 || 320. The 32-bit divisor ",
                "is (RB)32:63. If the quotient can be represented in 32 ",
                "bits, it is placed into RT32:63. The contents of RT0:31 are ",
                "undefined. The remainder is not supplied as a result. ",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnegative, ",
                "and -|divisor| < r £ 0 if the dividend is negative.",
                "If the quotient cannot be represented in 32 bits, or if an ",
                "attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Word Extended Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divweu",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweu.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweuo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divweuo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "395", "Rc" ],
                [ "0 ", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:63 := (RA)32:63 || 320",
                "divisor0:31 := (RB)32:63",
                "RT32:63 := dividend ¸ divisor",
                "RT0:31 := undefined",
                "",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA)32:63 || 320. The 32-bit divisor ",
                "is (RB)32:63. If the quotient can be represented in 32 ",
                "bits, it is placed into RT32:63. The contents of RT0:31 are ",
                "undefined. The remainder is not supplied as a result. ",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero. The quotient is the unique unsigned inte",
                "ger that satisfies",
                "where 0 £ r < divisor.",
                "If (RA) ³ (RB), or if an attempt is made to perform the ",
                "division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1.",
                "Unsigned long division of a 64-bit dividend contained in ",
                "two 32-bit registers by a 32-bit divisor can be computed ",
                "as follows. The algorithm is shown first, followed by ",
                "Assembler code that implements the algorithm. The ",
                "dividend is Dh || Dl, the divisor is Dv, and the quotient ",
                "and remainder are Q and R respectively, where these ",
                "variables and all intermediate variables represent ",
                "unsigned 32-bit integers. It is assumed that Dv > Dh, ",
                "and that assigning a value to an intermediate variable ",
                "assigns the low-order 32 bits of the value and ignores ",
                "any higher-order bits of the value. (In both the algorithm ",
                "and the Assembler code, “r1” and “r2” refer to “remain",
                "der 1” and “remainder 2”, rather than to GPRs 1 and 2.)",
                "Algorithm:",
                "Assembler Code:",
                "Notes:"
            ]
        },
        {
            "description": "Modulo Signed Word X-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "modsw",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "remainder = dividend - (quotient × divisor)",
                "0x8000_0000 % -1"
            ],
            "body": [
                "The 32-bit dividend is (RA)32:63. The 32-bit divisor is ",
                "(RB)32:63. The 32-bit remainder of the dividend divided ",
                "by the divisor is placed into RT32:63. The contents of ",
                "RT0:31 are undefined. The quotient is not supplied as a ",
                "result.",
                "where 0 £ remainder < |divisor| if the dividend is ",
                "nonnegative, and -|divisor| < remainder £ 0 if the ",
                "dividend is negative.",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Unsigned Word X-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "moduw",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "remainder = dividend - (quotient × divisor)",
                "<anything> % 0"
            ],
            "body": [
                "The 32-bit dividend is (RA)32:63. The 32-bit divisor is ",
                "(RB)32:63. The 32-bit remainder of the dividend divided ",
                "by the divisor is placed into RT32:63. The contents of ",
                "RT0:31 are undefined. The quotient is not supplied as a ",
                "result.",
                "where 0 £ remainder < divisor.",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Deliver A Random Number",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "darn",
                    "regs": [ "RT,L" ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                [ "31", "RT", "///", " L", "///", "755", "/" ],
                [ "0", "6", "11     13", "14", "16 ", "21", "31" ]
            ],
            "code": [
                "RT := random(L)",
                " ",
                " "
            ],
            "body": [
                "A random number is placed into register RT in a format ",
                "selected by L as shown in the following table.  The ",
                "value 0xFFFFFFFF_FFFFFFFF indicates an error con",
                "dition.  For L=0, the random number range is ",
                "0:0xFFFFFFFF.  For L=1 and L=2, the random number ",
                "range is 0:0xFFFFFFFF_FFFFFFFE.",
                "",
                " ",
                "",
                "",
                "",
                " ",
                ""
            ]
        },
        {
            "description": "Multiply Low Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulld",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulld.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulldo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulldo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "233", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "prod0:127 := (RA) ´ (RB)",
                "RT := prod64:127"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The low-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "If OE=1 then OV and OV32 are set to 1 if the product ",
                "cannot be represented in 64 bits.",
                "Both operands and the product are interpreted as ",
                "signed integers.",
                "  "
            ]
        },
        {
            "description": "Multiply High Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhd",
                    "regs": [ "RT,RA,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhd.",
                    "regs": [ "RT,RA,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "/", "73", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "prod0:127 := (RA) ´ (RB)",
                "RT := prod0:63"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The high-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "Both operands and the product are interpreted as ",
                "signed integers."
            ]
        },
        {
            "description": "Multiply High Doubleword Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mulhdu",
                    "regs": [ "RT,RA,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "mulhdu.",
                    "regs": [ "RT,RA,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "/", "9", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "prod0:127 := (RA) ´ (RB)",
                "RT := prod0:63"
            ],
            "body": [
                "The 64-bit operands are (RA) and (RB). The high-order ",
                "64 bits of the 128-bit product of the operands are ",
                "placed into register RT.",
                "Both operands and the product are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero."
            ]
        },
        {
            "description": "Multiply-Add High Doubleword VA-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "maddhd",
                    "regs": [ "RT,RA.RB,RC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "prod0:127 := (RA) × (RB)"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is ",
                "added to (RC). The high-order 64 bits of the 128-bit ",
                "sum are placed into register RT."
            ]
        },
        {
            "description": "Multiply-Add High Doubleword Unsigned",
            "form": "VA-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "maddhdu",
                    "regs": [ "RT,RA.RB,RC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "prod0:127 := (RA) × (RB)"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is ",
                "added to (RC). The high-order 64 bits of the 128-bit ",
                "sum are placed into register RT."
            ]
        },
        {
            "description": "Multiply-Add Low Doubleword VA-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "maddld",
                    "regs": [ "RT,RA.RB,RC" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "prod0:127 := (RA) × (RB)"
            ],
            "body": [
                "The 64-bit operands are (RA), (RB), and (RC). The ",
                "128-bit product of the operands (RA) and (RB) is ",
                "added to (RC). The low-order 64 bits of the 128-bit ",
                "sum are placed into register RT."
            ]
        },
        {
            "description": "Divide Doubleword",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divd",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divd.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "489", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:63 := (RA)",
                "divisor0:63 := (RB)",
                "RT := dividend ¸ divisor",
                "",
                "   0x8000_0000_0000_0000 ¸ -1",
                "   <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit quotient is placed into register RT. The ",
                "remainder is not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnegative, ",
                "and -|divisor| < r £ 0 if the dividend is negative.",
                "If an attempt is made to perform any of the divisions",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1.",
                "  "
            ]
        },
        {
            "description": "Divide Doubleword Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divdu",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divdu.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divduo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "divduo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "457", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:63 := (RA)",
                "divisor0:63 := (RB)",
                "RT := dividend ¸ divisor",
                "",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit quotient is placed into register RT. The ",
                "remainder is not supplied as a result.",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero. The quotient is the unique unsigned inte",
                "ger that satisfies",
                "where 0 £ r < divisor.",
                "If an attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In this case, if OE=1 then OV ",
                "and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Doubleword Extended",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divde",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divde.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "425", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:127 := (RA) || 640",
                "divisor0:63 := (RB)",
                "RT := dividend ¸ divisor",
                "",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 128-bit dividend is (RA) || 640. The 64-bit divisor is ",
                "(RB). If the quotient can be represented in 64 bits, it is ",
                "placed into register RT. The remainder is not supplied ",
                "as a result. ",
                "Both operands and the quotient are interpreted as ",
                "signed integers. The quotient is the unique signed inte",
                "ger that satisfies",
                "where 0 £ r < |divisor| if the dividend is nonnegative, ",
                "and -|divisor| < r £ 0 if the dividend is negative.",
                "If the quotient cannot be represented in 64 bits, or if an ",
                "attempt is made to perform the division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1."
            ]
        },
        {
            "description": "Divide Doubleword Extended Unsigned",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "divdeu",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeu.",
                    "regs": [ "RT,RA,RB", "(OE=0 Rc=1)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeuo",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=0)" ],
                    "release": "v2.06"
                },
                {
                    "mnemonic": "divdeuo.",
                    "regs": [ "RT,RA,RB", "(OE=1 Rc=1", ")" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "OE", "393", "Rc" ],
                [ "0", "6", "11", "16", "21", "22", "31" ]
            ],
            "code": [
                "dividend0:127 := (RA) || 640",
                "divisor0:63 := (RB)",
                "RT := dividend ¸ divisor",
                "",
                "    <anything> ¸ 0"
            ],
            "body": [
                "The 128-bit dividend is (RA) || 640. The 64-bit divisor is ",
                "(RB). If the quotient can be represented in 64 bits, it is ",
                "placed into register RT. The remainder is not supplied ",
                "as a result. ",
                "Both operands and the quotient are interpreted as ",
                "unsigned integers, except that if Rc=1 the first three ",
                "bits of CR Field 0 are set by signed comparison of the ",
                "result to zero. The quotient is the unique unsigned inte",
                "ger that satisfies",
                "where 0 £ r < divisor.",
                "If (RA) ³ (RB), or if an attempt is made to perform the ",
                "division",
                "then the contents of register RT are undefined as are (if ",
                "Rc=1) the contents of the LT, GT, and EQ bits of CR ",
                "Field 0. In these cases, if OE=1 then ",
                "OV and OV32 are set to 1.",
                "  "
            ]
        },
        {
            "description": "Modulo Signed Doubleword X-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "modsd",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "remainder = dividend - (quotient × divisor)",
                "<anything> % 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit remainder of the dividend divided by the ",
                "divisor is placed into register RT. The quotient is not ",
                "supplied as a result.",
                "where 0 £ remainder < |divisor| if the dividend is ",
                "nonnegative, and -|divisor| < remainder £ 0 if the ",
                "dividend is negative.",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Modulo Unsigned Doubleword X-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "modud",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "remainder = dividend - (quotient × divisor)",
                "<anything> % 0"
            ],
            "body": [
                "The 64-bit dividend is (RA). The 64-bit divisor is (RB). ",
                "The 64-bit remainder of the dividend divided by the ",
                "divisor is placed into register RT. The quotient is not ",
                "supplied as a result.",
                "where 0 £ remainder < divisor.",
                "then the contents of register RT are undefined."
            ]
        },
        {
            "description": "Compare Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpi",
                    "regs": [ "BF,L,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "11", "BF", "/", "L", "RA", "SI" ],
                [ "0", "6", "9", "10", "11", "16                                              31" ]
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)32:63)",
                "         else a := (RA)",
                "if      a < EXTS(SI) then c := 0b100",
                "else if a > EXTS(SI) then c := 0b010",
                "else                      c := 0b001",
                "CR4´BF+32:4´BF+35 := c || XERSO",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)32:63 sign-extended to ",
                "64 bits if L=0) are compared with the sign-extended ",
                "value of the SI field, treating the operands as signed ",
                "integers. The result of the comparison is placed into CR ",
                "field BF.",
                "Examples of extended mnemonics for Compare Imme",
                "diate:"
            ]
        },
        {
            "description": "Compare",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmp",
                    "regs": [ "BF,L,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "BF", "/", "L", "RA", "RB", "0", "/" ],
                [ "0", "6", "9", "10", "11", "16", "21", "31" ]
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)32:63)",
                "                b := EXTS((RB)32:63)",
                "           else a := (RA)",
                "                b := (RB)",
                "if      a < b then c := 0b100",
                "else if a > b then c := 0b010",
                "else               c := 0b001",
                "CR4´BF+32:4´BF+35 := c || XERSO",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)32:63 if L=0) are com",
                "pared with the contents of register RB ((RB)32:63 if ",
                "L=0), treating the operands as signed integers. The ",
                "result of the comparison is placed into CR field BF",
                "in tags active mode, into the FXCC.",
                "Examples of extended mnemonics for Compare:"
            ]
        },
        {
            "description": "Compare Logical Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpli",
                    "regs": [ "BF,L,RA,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "10", "BF", "/", "L", "RA", "UI" ],
                [ "0 ", "6 ", "9 ", "10", "11 ", "16                                        31" ]
            ],
            "code": [
                "if L = 0 then a := 320 || (RA)32:63",
                "         else a := (RA)",
                "if      a <u (480 || UI) then c := 0b100",
                "else if a >u (480 || UI) then c := 0b010",
                "else                         c := 0b001",
                "CR4´BF+32:4´BF+35 := c || XERSO",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)32:63 zero-extended ",
                "to 64 bits if L=0) are compared with 480||UI, treating ",
                "the operands as unsigned integers. The result of the ",
                "comparison is placed into CR field BF",
                "active mode, into the FXCC.",
                "Examples of extended mnemonics for Compare Logical ",
                "Immediate:"
            ]
        },
        {
            "description": "Compare Logical",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpl",
                    "regs": [ "BF,L,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "BF", "/", "L", "RA", "RB", "32", "/" ],
                [ "0", "6", "9", "10", "11", "16", "21", "31" ]
            ],
            "code": [
                "if L = 0 then a := 320 || (RA)32:63",
                "              b := 320 || (RB)32:63",
                "         else a := (RA)",
                "              b := (RB)",
                "if      a <u b then c := 0b100",
                "else if a >u b then c := 0b010",
                "else                c := 0b001",
                "CR4´BF+32:4´BF+35 := c || XERSO",
                ""
            ],
            "body": [
                "The contents of register RA ((RA)32:63 if L=0) are com",
                "pared with the contents of register RB ((RB)32:63 if ",
                "L=0), treating the operands as unsigned integers. The ",
                "result of the comparison is placed into CR field BF",
                "in tags active mode, into the FXCC.",
                "Examples of extended mnemonics for Compare Logi",
                "cal:"
            ]
        },
        {
            "description": "Compare Ranged Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmprb",
                    "regs": [ "BF,L,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let src1 be the unsigned integer value in bits 56:63 of ",
                "register RA.",
                ""
            ]
        },
        {
            "description": "Compare Equal Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpeqb",
                    "regs": [ "BF,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "CR field BF is set to indicate if the contents of bits 56:63 ",
                "of register RA are equal to the contents of any of the 8 ",
                "bytes in register RB.",
                ""
            ]
        },
        {
            "description": "Trap Word Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "twi",
                    "regs": [ "TO,RA,SI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "3", "TO", "RA", "SI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "a := EXTS((RA)32:63)",
                "if (a < EXTS(SI)) & TO0  then TRAP",
                "if (a > EXTS(SI)) & TO1  then TRAP",
                "if (a = EXTS(SI)) & TO2  then TRAP",
                "if (a <u EXTS(SI)) & TO3 then TRAP",
                "if (a >u EXTS(SI)) & TO4 then TRAP"
            ],
            "body": [
                "The contents of RA32:63 are compared with the ",
                "sign-extended value of the SI field. If any bit in the TO ",
                "field is set to 1 and its corresponding condition is met ",
                "by the result of the comparison, the system trap han",
                "dler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "Examples of extended mnemonics for Trap Word ",
                "Immediate:"
            ]
        },
        {
            "description": "Trap Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "tw",
                    "regs": [ "TO,RA,RB" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "TO", "RA", "RB", "4", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "a := EXTS((RA)32:63)",
                "b := EXTS((RB)32:63)",
                "if (a < b) & TO0 then TRAP",
                "if (a > b) & TO1 then TRAP",
                "if (a = b) & TO2 then TRAP",
                "if (a <u b) & TO3 then TRAP",
                "if (a >u b) & TO4 then TRAP"
            ],
            "body": [
                "The contents of RA32:63 are compared with the con",
                "tents of RB32:63. If any bit in the TO field is set to 1 and ",
                "its corresponding condition is met by the result of the ",
                "comparison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "Examples of extended mnemonics for Trap Word:"
            ]
        },
        {
            "description": "Trap Doubleword Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "tdi",
                    "regs": [ "TO,RA,SI" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "2", "TO", "RA", "SI" ],
                [ "0", "6 ", "11 ", "16                                                     31" ]
            ],
            "code": [
                "a := (RA)",
                "b := EXTS(SI)",
                "",
                "     ( a0:15 ¹ 0  &",
                "     ( ( a16:39 ¹ b16:39) | (a < b) ) ) ) &",
                "    TO = 0b11100 & (tags active) then TRAP",
                "if ( a0:15 ¹ b0:15 | ",
                "     ( a0:15 ¹ 0  & (a16:39 ¹ b16:39) ) ) &",
                "     (TO = 0b11101) & (tags active) then TRAP",
                "if (a0:39 ¹ b0:39) &",
                "     (TO = 0b11110) & (tags active) then TRAP",
                "if (a < b) & TO0",
                "   ((TO ¹ 0b11100 &",
                "     TO ¹ 0b11101)| tags inactive) then TRAP",
                "if (a > b) & TO1",
                "   ((TO ¹ 0b11100 &",
                "     TO ¹ 0b11101 &",
                "     TO ¹ 0b11110) | tags inactive) then TRAP",
                "if (a = b) & TO2",
                "   ((TO ¹ 0b11100 &",
                "     TO ¹ 0b11101 &",
                "     TO ¹ 0b11110) | tags inactive) then TRAP",
                "if (a <u b) & TO3 then TRAP",
                "if (a >u b) & TO4 ",
                "   ((TO ¹ 0b11101) | tags inactive) then TRAP"
            ],
            "body": [
                "The contents of register RA are compared with the ",
                "sign-extended value of the SI field. If ",
                "mode or if TO is equal to any value other than 0b11100, ",
                "0b11101, or 0b11110, if any bit in the TO field is set to 1 ",
                "and its corresponding condition is met by the result of ",
                "the comparison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "handler is invoked if any of the following conditions are ",
                "met.",
                "In tags active mode with TO=0b11101 the system trap ",
                "handler is invoked if any of the following conditions are ",
                "met.",
                "In tags active mode with TO = 0b11110 the system trap ",
                "handler is invoked if any of the following conditions are ",
                "met.",
                "Examples of extended mnemonics for Trap Double",
                "word Immediate:"
            ]
        },
        {
            "description": "Trap Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "td",
                    "regs": [ "TO,RA,RB" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "TO", "RA", "RB", "68", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "a := (RA)",
                "b := (RB)",
                "",
                "     ( a0:15 ¹ 0  &",
                "     ( ( a16:39 ¹ b16:39) | (a < b) ) ) ) &",
                "    TO = 0b11100 & (tags active) then TRAP",
                "if ( a0:15 ¹ b0:15 | ",
                "     ( a0:15 ¹ 0  & (a16:39 ¹ b16:39) ) ) &",
                "     (TO = 0b11101) & (tags active) then TRAP",
                "if (a0:39 ¹ b0:39) &",
                "   (TO = 0b11110) & (tags active) then TRAP",
                "if (a < b) & TO0",
                "   ((TO ¹ 0b11100 &",
                "     TO ¹ 0b11101)| tags inactive) then TRAP",
                "if (a > b) & TO1",
                "   ((TO ¹ 0b11100 &",
                "     TO ¹ 0b11101 &",
                "     TO ¹ 0b11110) | tags inactive) then TRAP",
                "if (a = b) & TO2",
                "   ((TO ¹ 0b11100 &",
                "     TO ¹ 0b11101 &",
                "     TO ¹ 0b11110) | tags inactive) then TRAP",
                "if (a <u b) & TO3 then TRAP",
                "if (a >u b) & TO4 ",
                "   ((TO ¹ 0b11101) | tags inactive) then TRAP"
            ],
            "body": [
                "The contents of register RA are compared with the con",
                "tents of register RB. If ",
                "equal to any value other than 0b11100, 0b11101, or ",
                "0b11110, if any bit in the TO field is set to 1 and its cor",
                "responding condition is met by the result of the compar",
                "ison, the system trap handler is invoked.",
                "If the trap conditions are met, this instruction is context ",
                "synchronizing (see Book III).",
                "",
                "handler is invoked if any of the following conditions are ",
                "met.",
                "In tags active mode with TO = 0b11101 the system trap ",
                "handler is invoked if any of the following conditions are ",
                "met.",
                "In tags active mode with TO = 0b11110 the system trap ",
                "handler is invoked if any of the following conditions are ",
                "met.",
                "Examples of extended mnemonics for Trap Double",
                "word:"
            ]
        },
        {
            "description": "Select Immediate-Immediate",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "selii",
                    "regs": [ "RA,IS,IB,XBI", "(Rc=0)" ],
                    "release": "PPCAS"
                },
                {
                    "mnemonic": "selii.",
                    "regs": [ "RA,IS,IB,XBI", "(Rc=1)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "30", "IS", "RA", "IB", "XBI", "//", "12", "Rc" ],
                [ "0", "6", "11", "16", "21", "25", "27", "31" ]
            ],
            "code": [
                "if XERXBI+32 then RA := EXTS(IS)",
                "             else RA := EXTS(IB)"
            ],
            "body": [
                "The XER bit at position XBI+32 is tested. If it is 1, regis",
                "ter RA is set to the sign-extended value of IS. Other",
                "wise register RA is set to the sign-extended value of IB.",
                "OV32 and CA32 are always read as 0 by this instruc",
                "tion.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler.",
                "Examples of extended mnemonics for Select Immedi",
                "ate-Immediate:"
            ]
        },
        {
            "description": "Select Immediate-Register",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "selir",
                    "regs": [ "RA,IS,RB,XBI", "(Rc=0)" ],
                    "release": "PPCAS"
                },
                {
                    "mnemonic": "selir.",
                    "regs": [ "RA,IS,RB,XBI", "(Rc=1)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "30", "IS", "RA", "RB", "XBI", "//", "13", "Rc" ],
                [ "0", "6", "11", "16", "21", "25", "27", "31" ]
            ],
            "code": [
                "if XERXBI+32 then RA := EXTS(IS)",
                "              else RA := (RB)"
            ],
            "body": [
                "The XER bit at position XBI+32 is tested. If it is 1, regis",
                "ter RA is set to the sign-extended value of IS. Other",
                "wise register RA is set to (RB).",
                "OV32 and CA32 are always read as 0 by this instruc",
                "tion.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler.",
                "Examples of extended mnemonics for Select Immedi",
                "ate-Register:"
            ]
        },
        {
            "description": "Select Register-Immediate",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "selri",
                    "regs": [ "RA,RS,IB,XBI", "(Rc=0)" ],
                    "release": "PPCAS"
                },
                {
                    "mnemonic": "selri.",
                    "regs": [ "RA,RS,IB,XBI", "(Rc=1)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "IB", "XBI", "//", "14", "Rc" ],
                [ "0", "6", "11", "16", "21", "25", "27", "31" ]
            ],
            "code": [
                "if XERXBI+32 then RA := (RS)",
                "else RA := EXTS(IB)"
            ],
            "body": [
                "The XER bit at position XBI+32 is tested. If it is 1, regis",
                "ter RA is set to (RS). Otherwise register RA is set to the ",
                "sign-extended value of IB.",
                "OV32 and CA32 are always read as 0 by this instruc",
                "tion.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler.",
                "Examples of extended mnemonics for Select Regis",
                "ter-Immediate:"
            ]
        },
        {
            "description": "Select Register-Register",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "selrr",
                    "regs": [ "RA,RS,RB,XBI", "(Rc=0)" ],
                    "release": "PPCAS"
                },
                {
                    "mnemonic": "selrr.",
                    "regs": [ "RA,RS,RB,XBI", "(Rc=1)" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "RB", "XBI", "//", "15", "Rc" ],
                [ "0", "6", "11", "16", "21", "25", "27", "31" ]
            ],
            "code": [
                "if XERXBI+32 then RA := (RS)",
                "else RA := (RB)"
            ],
            "body": [
                "The XER bit at position XBI+32 is tested. If it is 1, regis",
                "ter RA is set to (RS). Otherwise register RA is set to ",
                "(RB).",
                "OV32 and CA32 are always read as 0 by this instruc",
                "tion.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler.",
                "Examples of extended mnemonics for Select Regis",
                "ter-Register:"
            ]
        },
        {
            "description": "Integer Select",
            "form": "A-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "isel",
                    "regs": [ "RT,RA,RB,BC" ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                [ "31", "RT", "RA", "RB", "BC", "15", "/" ],
                [ "0", "6", "11", "16", "21", "26", "31" ]
            ],
            "code": [
                "if RA=0 then a := 0 else a := (RA)",
                "if CRBC+32=1 then RT := a",
                "else           RT := (RB)"
            ],
            "body": [
                "If the contents of bit BC+32 of the Condition Register ",
                "are equal to 1, then the contents of register RA (or 0) ",
                "are placed into register RT. Otherwise, the contents of ",
                "register RB are placed into register RT.",
                "Examples of extended mnemonics for Integer Select:"
            ]
        },
        {
            "description": "AND Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "andi.",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "28", "RS", "RA", "UI" ],
                [ "0", "6", "11", "16                                        31" ]
            ],
            "code": [
                "RA := (RS) & (480 || UI)"
            ],
            "body": [
                "The contents of register RS are ANDed with 480||UI ",
                "and the result is placed into register RA."
            ]
        },
        {
            "description": "AND Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "andis.",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "29", "RS", "RA", "UI" ],
                [ "0", "6", "11", "16                                        31" ]
            ],
            "code": [
                "RA := (RS) & (320 || UI || 160)"
            ],
            "body": [
                "The contents of register RS are ANDed with ",
                "320||UI||160 and the result is placed into register RA."
            ]
        },
        {
            "description": "OR Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "ori",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "24", "RS", "RA", "UI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "RA := (RS) | (480 || UI)",
                "",
                "ori0,0,0"
            ],
            "body": [
                "The contents of register RS are ORed with 480||UI and ",
                "the result is placed into register RA.",
                "The preferred “no-op” (an instruction that does nothing) ",
                "is:",
                "Example of extended mnemonics for OR Immediate:",
                "  "
            ]
        },
        {
            "description": "OR Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "",
                    "regs": [  ],
                    "release": ""
                }
            ],
            "layout": [

            ],
            "code": [
                "RA := (RS) | (320 || UI || 160)"
            ],
            "body": [
                "oris      RA,RS,UI",
                "The contents of register RS are ORed with ",
                "320||UI||160 and the result is placed into register RA."
            ]
        },
        {
            "description": "XOR Immediate",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "xori",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "26", "RS", "RA", "UI" ],
                [ "0 ", "6 ", "11 ", "16                                                    31" ]
            ],
            "code": [
                "RA := (RS) XOR (480 || UI)",
                "",
                "xori0,0,0"
            ],
            "body": [
                "The contents of register RS are XORed with 480||UI ",
                "and the result is placed into register RA.",
                "The executed form of a “no-op” (an instruction that ",
                "does nothing, but consumes execution resources nev",
                "ertheless) is:",
                "Example of extended mnemonics for XOR Immediate:",
                "  ",
                "  "
            ]
        },
        {
            "description": "XOR Immediate Shifted",
            "form": "D-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "xoris",
                    "regs": [ "RA,RS,UI" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "27", "RS", "RA", "UI" ],
                [ "0", "6", "11", "16                                                    31" ]
            ],
            "code": [
                "RA := (RS) XOR (320 || UI || 160)"
            ],
            "body": [
                "The contents of register RS are XORed with ",
                "320||UI||160 and the result is placed into register RA."
            ]
        },
        {
            "description": "AND",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "and",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "and.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "28", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "RA := (RS) & (RB)"
            ],
            "body": [
                "The contents of register RS are ANDed with the con",
                "tents of register RB and the result is placed into register ",
                "RA.",
                "Some forms of and Rx, Rx, Rx provide special func",
                "tions; see Section9.3 of Book III.",
                ""
            ]
        },
        {
            "description": "XOR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "xor",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "xor.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "316", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "RA := (RS) / (RB)"
            ],
            "body": [
                "The contents of register RS are XORed with the con",
                "tents of register RB and the result is placed into register ",
                "RA.",
                ""
            ]
        },
        {
            "description": "NAND",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "nand",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nand.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "476", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "RA := :=((RS) & (RB))"
            ],
            "body": [
                "The contents of register RS are ANDed with the con",
                "tents of register RB and the complemented result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "OR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "or",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "or.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "444", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "RA := (RS) | (RB)"
            ],
            "body": [
                "The contents of register RS are ORed with the contents ",
                "of register RB and the result is placed into register RA.",
                "Some forms of or Rx,Rx,Rx provide special functions; ",
                "see Section 3.2 and Section 4.3.3, both in Book II.",
                "Example of extended mnemonics for OR:"
            ]
        },
        {
            "description": "NOR",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "nor",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "nor.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "124", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "   RA := :=((RS) | (RB))"
            ],
            "body": [
                "The contents of register RS are ORed with the contents ",
                "of register RB and the complemented result is placed ",
                "into register RA.",
                "Example of extended mnemonics for NOR:"
            ]
        },
        {
            "description": "Equivalent",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "eqv",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "eqv.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "284", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "RA := (RS) not xor (RB)"
            ],
            "body": [
                "The contents of register RS are XORed with the con",
                "tents of register RB and the complemented result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "AND with Complement",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "andc",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "andc.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "60", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "RA := (RS) & :=(RB)"
            ],
            "body": [
                "The contents of register RS are ANDed with the com",
                "plement of the contents of register RB and the result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "OR with Complement",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "orc",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "orc.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "412", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "RA := (RS) | :=(RB)"
            ],
            "body": [
                "The contents of register RS are ORed with the comple",
                "ment of the contents of register RB and the result is ",
                "placed into register RA."
            ]
        },
        {
            "description": "Extend Sign Byte",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extsb",
                    "regs": [ "RA,RS", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "extsb.",
                    "regs": [ "RA,RS", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "954", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "s := (RS)56",
                "RA56:63 := (RS)56:63",
                "RA0:55 := 56s"
            ],
            "body": [
                "(RS)56:63 are placed into RA56:63. RA0:55 are filled with ",
                "a copy of (RS)56."
            ]
        },
        {
            "description": "Extend Sign Halfword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extsh",
                    "regs": [ "RA,RS", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "extsh.",
                    "regs": [ "RA,RS", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "922", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "s := (RS)48",
                "RA48:63 := (RS)48:63",
                "RA0:47 := 48s"
            ],
            "body": [
                "(RS)48:63 are placed into RA48:63. RA0:47 are filled with ",
                "a copy of (RS)48."
            ]
        },
        {
            "description": "Count Leading Zeros Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cntlzw",
                    "regs": [ "RA,RS", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "cntlzw.",
                    "regs": [ "RA,RS", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [

            ],
            "code": [
                "n := 32",
                "",
                "do while n < 64",
                "   if (RS)n = 1 then leave",
                "   n := n + 1",
                "",
                "RA := n - 32"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 32 of register RS is placed into register RA. This ",
                "number ranges from 0 to 32, inclusive.",
                "  "
            ]
        },
        {
            "description": "Count Trailing Zeros Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cnttzw",
                    "regs": [ "RA,", "RS", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "cnttzw.",
                    "regs": [ "RA,", "RS", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "n := 0",
                "",
                "do while n < 32",
                "   if (RS)63-n = 0b1 then leave ",
                "   n  := n + 1",
                "",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 63 of the rightmost word of register RS is placed ",
                "into register RA. This number ranges from 0 to 32, ",
                "inclusive."
            ]
        },
        {
            "description": "Compare Bytes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cmpb",
                    "regs": [ "RA,RS,RB" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                [ "31", "", "", "", "", "", "RS", "", "", "", "", "RA", "", "", "", "", "RB", "", "", "", "", "508", "", "", "", "", "", "", "", "", "", "/" ],
                [ "0", "", "", "", "", "", "6", "", "", "", "", "11", "", "", "", "", "16", "", "", "", "", "21", "", "", "", "", "", "", "", "", "", "31" ]
            ],
            "code": [
                "do n = 0 to 7 ",
                "if RS8´n:8´n+7 = (RB)8´n:8´n+7 then",
                "   RA8´n:8´n+7 := 81",
                "else ",
                "   RA8´n:8´n+7 := 80"
            ],
            "body": [
                "Each byte of the contents of register RS is compared to ",
                "each corresponding byte of the contents in register RB. ",
                "If they are equal, the corresponding byte in RA is set to ",
                "0xFF. Otherwise the corresponding byte in RA is set to ",
                "0x00."
            ]
        },
        {
            "description": "Population Count Bytes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "popcntb",
                    "regs": [ "RA, RS" ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "122", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "do i = 0 to 7",
                "   n := 0",
                "   do j = 0 to 7",
                "      if (RS)(i´8)+j = 1 then",
                "          n := n+1",
                "   RA(i´8):(i´8)+7 := n"
            ],
            "body": [
                "A count of the number of one bits in each byte of regis",
                "ter RS is placed into the corresponding byte of register ",
                "RA. This number ranges from 0 to 8, inclusive."
            ]
        },
        {
            "description": "Population Count Words",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "popcntw",
                    "regs": [ "RA, R", "S" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "378", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "do i = 0 to 1",
                "   n := 0",
                "   do j = 0 to 31",
                "      if (RS)(i´32)+j = 1 then",
                "          n := n+1",
                "   RA(i´32):(i´32)+31 := n"
            ],
            "body": [
                "A count of the number of one bits in each word of regis",
                "ter RS is placed into the corresponding word of register ",
                "RA. This number ranges from 0 to 32, inclusive."
            ]
        },
        {
            "description": "Parity Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "prtyd",
                    "regs": [ "RA,R", "S" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "186", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "s := 0",
                "do i = 0 to 7",
                "s := s / (RS)i%8+7",
                "RA := 630 || s"
            ],
            "body": [
                "The least significant bit in each byte of the contents of ",
                "register RS is examined. If there is an odd number of ",
                "one bits the value 1 is placed into register RA; other",
                "wise the value 0 is placed into register RA.",
                " "
            ]
        },
        {
            "description": "Parity Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "prtyw",
                    "regs": [ "RA,RS" ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "154", "/" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "s := 0",
                "t := 0",
                "do i = 0 to 3",
                "s := s / (RS)i%8+7",
                "do i = 4 to 7",
                "t := t / (RS)i%8+7",
                "RA0:31 := 310 || s ",
                "RA32:63 := 310 || t"
            ],
            "body": [
                "The least significant bit in each byte of (RS)0:31 is ",
                "examined. If there is an odd number of one bits the ",
                "value 1 is placed into RA0:31; otherwise the value 0 is ",
                "placed into RA0:31. The least significant bit in each byte ",
                "of (RS)32:63 is examined. If there is an odd number of ",
                "one bits the value 1 is placed into RA32:63; otherwise ",
                "the value 0 is placed into RA32:63.",
                "  ",
                "  ",
                ""
            ]
        },
        {
            "description": "Extend Sign Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extsw",
                    "regs": [ "RA,RS", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "extsw.",
                    "regs": [ "RA,RS", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [

            ],
            "code": [
                "s := (RS)32",
                "RA32:63 := (RS)32:63",
                "RA0:31 := 32s"
            ],
            "body": [
                "(RS)32:63 are placed into RA32:63. RA0:31 are filled with ",
                "a copy of (RS)32.",
                ""
            ]
        },
        {
            "description": "Population Count Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "popcntd",
                    "regs": [ "RA, R", "S" ],
                    "release": "v2.06"
                }
            ],
            "layout": [

            ],
            "code": [
                "n := 0",
                "do i = 0 to 63",
                "   if (RS)i = 1 then",
                "   n := n+1",
                "RA := n"
            ],
            "body": [
                "A count of the number of one bits in register RS is ",
                "placed into register RA. This number ranges from 0 to ",
                "64, inclusive."
            ]
        },
        {
            "description": "Count Leading Zeros Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cntlzd",
                    "regs": [ "RA,RS", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "cntlzd.",
                    "regs": [ "RA,RS", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [

            ],
            "code": [
                "n := 0",
                "do while n < 64",
                "  if (RS)n = 1 then leave",
                "  n := n + 1",
                "RA := n"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 0 of register RS is placed into register RA. This ",
                "number ranges from 0 to 64, inclusive."
            ]
        },
        {
            "description": "Count Trailing Zeros Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cnttzd",
                    "regs": [ "RA,", "RS", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                },
                {
                    "mnemonic": "cnttzd.",
                    "regs": [ "RA,", "RS", "(", "Rc=1", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "n  := 0",
                "do while n < 64",
                "   if (RS)63-n = 0b1 then leave ",
                "   n  := n + 1",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "A count of the number of consecutive zero bits starting ",
                "at bit 63 of register RS is placed into register RA. This ",
                "number ranges from 0 to 64, inclusive."
            ]
        },
        {
            "description": "Bit Permute Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "bpermd",
                    "regs": [ "RA,RS,R", "B]" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "252", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "For i = 0 to 7 ",
                "   index := (RS)8*i:8*i+7",
                "   If index < 64",
                "      then permi := (RB)index",
                "      else permi := 0",
                "RA := 560 || perm0:7"
            ],
            "body": [
                "Eight permuted bits are produced. For each permuted ",
                "bit i where i ranges from 0 to 7 and for each byte i of ",
                "RS, do the following.",
                "The permuted bits are placed in the least-significant ",
                "byte of RA, and the remaining bits are filled with 0s.",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word Immediate then AND with Mask",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rlwinm",
                    "regs": [ "RA,RS,SH,MB,ME", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwinm.",
                    "regs": [ "RA,RS,SH,MB,ME", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "21", "RS", "RA", "SH", "MB", "ME", "Rc" ],
                [ "0 ", "6 ", "11", "16 ", "21 ", "26 ", "31" ]
            ],
            "code": [
                "n := SH",
                "r := ROTL32((RS)32:63, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated32 left SH bits. A ",
                "mask is generated having 1-bits from bit MB+32 ",
                "through bit ME+32 and 0-bits elsewhere. The rotated ",
                "data are ANDed with the generated mask and the ",
                "result is placed into register RA.",
                "Examples of extended mnemonics for Rotate Left Word ",
                "Immediate then AND with Mask:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word then AND with Mask",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rlwnm",
                    "regs": [ "RA,RS,RB,MB,ME", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwnm.",
                    "regs": [ "RA,RS,RB,MB,ME", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "23", "RS", "RA", "RB", "MB", "ME", "Rc" ],
                [ "0", "6", "11", "16", "21", "26", "31" ]
            ],
            "code": [
                "n := (RB)59:63",
                "r := ROTL32((RS)32:63, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated32 left the num",
                "ber of bits specified by (RB)59:63. A mask is generated ",
                "having 1-bits from bit MB+32 through bit ME+32 and ",
                "0-bits elsewhere. The rotated data are ANDed with the ",
                "generated mask and the result is placed into register ",
                "RA.",
                "Example of extended mnemonics for Rotate Left Word ",
                "then AND with Mask:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Word Immediate then Mask Insert",
            "form": "M-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rlwimi",
                    "regs": [ "RA,RS,SH,MB,ME", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "rlwimi.",
                    "regs": [ "RA,RS,SH,MB,ME", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "20", "RS", "RA", "SH", "MB", "ME", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "26 ", "31" ]
            ],
            "code": [
                "n := SH",
                "r := ROTL32((RS)32:63, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r&m | (RA)&:=m"
            ],
            "body": [
                "The contents of register RS are rotated32 left SH bits. A ",
                "mask is generated having 1-bits from bit MB+32 ",
                "through bit ME+32 and 0-bits elsewhere. The rotated ",
                "data are inserted into register RA under control of the ",
                "generated mask.",
                "Example of extended mnemonics for Rotate Left Word ",
                "Immediate then Mask Insert:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear Left",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldicl",
                    "regs": [ "RA,RS,SH,MB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldicl.",
                    "regs": [ "RA,RS,SH,MB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "sh", "mb", "0", "sh", "Rc" ],
                [ "0 ", "6", "11 ", "16 ", "21 ", "27 ", "30", "31" ]
            ],
            "code": [
                "n := sh5 || sh0:4",
                "r := ROTL64((RS), n)",
                "b := mb5 || mb0:4",
                "m := MASK(b, 63)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated64 left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63 and 0-bits elsewhere. The rotated data are ANDed ",
                "with the generated mask and the result is placed into ",
                "register RA.",
                "Examples of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear Left:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear Right",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldicr",
                    "regs": [ "RA,RS,SH,ME", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldicr.",
                    "regs": [ "RA,RS,SH,ME", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "sh", "me", "1", "sh", "Rc" ],
                [ "0", "6", "11", "16", "21", "27", "30", "31" ]
            ],
            "code": [
                "n := sh5 || sh0:4",
                "r := ROTL64((RS), n)",
                "e := me5 || me0:4",
                "m := MASK(0, e)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated64 left SH bits. A ",
                "mask is generated having 1-bits from bit 0 through bit ",
                "ME and 0-bits elsewhere. The rotated data are ANDed ",
                "with the generated mask and the result is placed into ",
                "register RA.",
                "Examples of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear Right:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Clear",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldic",
                    "regs": [ "RA,RS,SH,MB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldic.",
                    "regs": [ "RA,RS,SH,MB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "sh", "mb", "2", "sh", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "27", "30", "31" ]
            ],
            "code": [
                "n := sh5 || sh0:4",
                "r := ROTL64((RS), n)",
                "b := mb5 || mb0:4",
                "m := MASK(b, :=n)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated64 left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63-SH and 0-bits elsewhere. The rotated data are ",
                "ANDed with the generated mask and the result is ",
                "placed into register RA.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Clear:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword then Clear Left",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldcl",
                    "regs": [ "RA,RS,RB,MB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldcl.",
                    "regs": [ "RA,RS,RB,MB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "RB", "mb", "8", "Rc" ],
                [ "0", "6", "11", "16", "21", "27", "31" ]
            ],
            "code": [
                "n := (RB)58:63",
                "r := ROTL64((RS), n)",
                "b := mb5 || mb0:4",
                "m := MASK(b, 63)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated64 left the num",
                "ber of bits specified by (RB)58:63. A mask is generated ",
                "having 1-bits from bit MB through bit 63 and 0-bits else",
                "where. The rotated data are ANDed with the generated ",
                "mask and the result is placed into register RA.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword then Clear Left:",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword then Clear Right",
            "form": "MDS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldcr",
                    "regs": [ "RA,RS,RB,ME", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldcr.",
                    "regs": [ "RA,RS,RB,ME", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "RB", "me", "9", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "27 ", "31" ]
            ],
            "code": [
                "n := (RB)58:63",
                "r := ROTL64((RS), n)",
                "e := me5 || me0:4",
                "m := MASK(0, e)",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are rotated64 left the num",
                "ber of bits specified by (RB)58:63. A mask is generated ",
                "having 1-bits from bit 0 through bit ME and 0-bits else",
                "where. The rotated data are ANDed with the generated ",
                "mask and the result is placed into register RA.",
                "  "
            ]
        },
        {
            "description": "Rotate Left Doubleword Immediate then Mask Insert",
            "form": "MD-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "rldimi",
                    "regs": [ "RA,RS,SH,MB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "rldimi.",
                    "regs": [ "RA,RS,SH,MB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "30", "RS", "RA", "sh", "mb", "3", "sh", "Rc" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "27 ", "30", "31" ]
            ],
            "code": [
                "n := sh5 || sh0:4",
                "r := ROTL64((RS), n)",
                "b := mb5 || mb0:4",
                "m := MASK(b, :=n)",
                "RA := r&m | (RA)&:=m"
            ],
            "body": [
                "The contents of register RS are rotated64 left SH bits. A ",
                "mask is generated having 1-bits from bit MB through bit ",
                "63-SH and 0-bits elsewhere. The rotated data are ",
                "inserted into register RA under control of the generated ",
                "mask.",
                "Example of extended mnemonics for Rotate Left Dou",
                "bleword Immediate then Mask Insert:",
                "  ",
                "The instructions in this section perform left and right ",
                "shifts.",
                "Immediate-form logical (unsigned) shift operations are ",
                "obtained by specifying appropriate masks and shift val",
                "ues for certain Rotate instructions. A set of extended ",
                "mnemonics is provided to make coding of such shifts ",
                "simpler and easier to understand. Some of these are ",
                "shown as examples with the Rotate instructions. See ",
                "AppendixC, “Assembler Extended Mnemonics” on ",
                "page815 for additional extended mnemonics."
            ]
        },
        {
            "description": "Shift Left Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "slw",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "slw.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "24", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "n := (RB)59:63",
                "r := ROTL32((RS)32:63, n)",
                "if (RB)58 = 0 then",
                "     m := MASK(32, 63-n)",
                "else m := 640",
                "RA := r & m"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted left the number of bits specified by (RB)58:63. ",
                "Bits shifted out of position 32 are lost. Zeros are sup",
                "plied to the vacated positions on the right. The 32-bit ",
                "result is placed into RA32:63. RA0:31 are set to zero. ",
                "Shift amounts from 32 to 63 give a zero result."
            ]
        },
        {
            "description": "Shift Right Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srw",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "srw.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "536", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "n := (RB)59:63",
                "r := ROTL32((RS)32:63, 64-n)",
                "if (RB)58 = 0 then",
                "    m := MASK(n+32, 63)",
                "else m := 640",
                "RA := r & m"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right the number of bits specified by (RB)58:63. ",
                "Bits shifted out of position 63 are lost. Zeros are sup",
                "plied to the vacated positions on the left. The 32-bit ",
                "result is placed into RA32:63. RA0:31 are set to zero. ",
                "Shift amounts from 32 to 63 give a zero result."
            ]
        },
        {
            "description": "Shift Right Algebraic Word Immediate",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srawi",
                    "regs": [ "RA,RS,SH", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "srawi.",
                    "regs": [ "RA,RS,SH", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "SH", "824", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "n := SH",
                "r := ROTL32((RS)32:63, 64-n)",
                "m := MASK(n+32, 63)",
                "s := (RS)32",
                "RA := r&m | (64s)&:=m",
                "carry := s & ((r&:=m)32:63¹0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right SH bits. Bits shifted out of position 63 are ",
                "lost. Bit 32 of RS is replicated to fill the vacated posi",
                "tions on the left. The 32-bit result is placed into RA32:63. ",
                "Bit 32 of RS is replicated to fill RA0:31. CA and CA32 ",
                "are set to 1 if the low-order 32 bits of (RS) contain a ",
                "negative number and any 1-bits are shifted out of posi",
                "tion 63; otherwise CA and CA32 are set to 0. A shift ",
                "amount of zero causes RA to receive EXTS((RS)32:63), ",
                "and CA and CA32 to be set to 0.",
                "",
                "undefined value."
            ]
        },
        {
            "description": "Shift Right Algebraic Word",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sraw",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "P1"
                },
                {
                    "mnemonic": "sraw.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "792", "Rc" ],
                [ "0 ", "6 ", "11 ", "16  ", "21 ", "31" ]
            ],
            "code": [
                "n := (RB)59:63",
                "r := ROTL32((RS)32:63, 64-n)",
                "if (RB)58 = 0 then",
                "    m := MASK(n+32, 63)",
                "else m := 640",
                "s := (RS)32",
                "RA := r&m | (64s)&:=m",
                "carry := s & ((r&:=m)32:63¹0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of the low-order 32 bits of register RS are ",
                "shifted right the number of bits specified by (RB)58:63. ",
                "Bits shifted out of position 63 are lost. Bit 32 of RS is ",
                "replicated to fill the vacated positions on the left. The ",
                "32-bit result is placed into RA32:63. Bit 32 of RS is repli",
                "cated to fill RA0:31. CA and CA32 are set to 1 if the ",
                "low-order 32 bits of (RS) contain a negative number ",
                "and any 1-bits are shifted out of position 63; otherwise ",
                "CA and CA32 are set to 0. A shift amount of zero ",
                "causes RA to receive EXTS((RS)32:63), and CA and ",
                "CA32 to be set to 0. Shift amounts from 32 to 63 give a ",
                "result of 64 sign bits, and cause CA and CA32 to ",
                "receive the sign bit of (RS)32:63.",
                "",
                "undefined value.",
                "  "
            ]
        },
        {
            "description": "Shift Left Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sld",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "sld.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "27", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "n := (RB)58:63",
                "r := ROTL64((RS), n)",
                "if (RB)57 = 0 then",
                "     m := MASK(0, 63-n)",
                "else m := 640",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are shifted left the number ",
                "of bits specified by (RB)57:63. Bits shifted out of position ",
                "0 are lost. Zeros are supplied to the vacated positions ",
                "on the right. The result is placed into register RA. Shift ",
                "amounts from 64 to 127 give a zero result."
            ]
        },
        {
            "description": "Shift Right Doubleword",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srd",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "srd.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "539", "Rc" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "n := (RB)58:63",
                "r := ROTL64((RS), 64-n)",
                "if (RB)57 = 0 then",
                "    m := MASK(n, 63)",
                "else m := 640",
                "RA := r & m"
            ],
            "body": [
                "The contents of register RS are shifted right the num",
                "ber of bits specified by (RB)57:63. Bits shifted out of ",
                "position 63 are lost. Zeros are supplied to the vacated ",
                "positions on the left. The result is placed into register ",
                "RA. Shift amounts from 64 to 127 give a zero result."
            ]
        },
        {
            "description": "Shift Right Algebraic Doubleword Immediate",
            "form": "XS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "sradi",
                    "regs": [ "RA,RS,SH", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "sradi.",
                    "regs": [ "RA,RS,SH", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "sh", "413", "sh", "Rc" ],
                [ "0", "6", "11", "16", "21", "30", "31" ]
            ],
            "code": [
                "n := sh5 || sh0:4",
                "r := ROTL64((RS), 64-n)",
                "m := MASK(n, 63)",
                "s := (RS)0",
                "RA := r&m | (64s)&:=m",
                "carry := s & ((r&:=m)¹0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of register RS are shifted right SH bits. ",
                "Bits shifted out of position 63 are lost. Bit 0 of RS is rep",
                "licated to fill the vacated positions on the left. The result ",
                "is placed into register RA. CA and CA32 are set to 1 if ",
                "(RS) is negative and any 1-bits are shifted out of posi",
                "tion 63; otherwise CA and CA32 are set to 0. A shift ",
                "amount of zero causes RA to be set equal to (RS), and ",
                "CA and CA32 to be set to 0.",
                "",
                "to an undefined value.",
                "Special Registers Altered:"
            ]
        },
        {
            "description": "Shift Right Algebraic Doubleword  X-form",
            "form": "",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "srad",
                    "regs": [ "RA,RS,RB", "(Rc=0)" ],
                    "release": "PPC"
                },
                {
                    "mnemonic": "srad.",
                    "regs": [ "RA,RS,RB", "(Rc=1)" ],
                    "release": "PPC"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "RB", "794", "Rc" ],
                [ "0", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "n := (RB)58:63",
                "r := ROTL64((RS), 64-n)",
                "if (RB)57 = 0 then",
                "    m := MASK(n, 63)",
                "else m := 640",
                "s := (RS)0",
                "RA := r&m | (64s)&:=m",
                "carry := s & ((r&:=m)¹0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "The contents of register RS are shifted right the num",
                "ber of bits specified by (RB)57:63. Bits shifted out of ",
                "position 63 are lost. Bit 0 of RS is replicated to fill the ",
                "vacated positions on the left. The result is placed into ",
                "register RA. CA and CA32 are set to 1 if (RS) is nega",
                "tive and any 1-bits are shifted out of position 63; other",
                "wise CA and CA32 are set to 0. A shift amount of zero ",
                "causes RA to be set equal to (RS), and CA and CA32 ",
                "to be set to 0. Shift amounts from 64 to 127 give a ",
                "result of 64 sign bits in RA, and cause CA and CA32 to ",
                "receive the sign bit of (RS).",
                "",
                "to an undefined value."
            ]
        },
        {
            "description": "Extend-Sign Word and Shift Left",
            "form": "Immediate XS-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "extswsli",
                    "regs": [ "RA,RS,SH", "(", "Rc=0", ")" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "n  := sh5 || sh0:4"
            ],
            "body": [
                "The contents of the low order 32 bits of RS are ",
                "sign-extended to 64 bits and then shifted left SH bits. ",
                "Bits shifted out of bit 0 are lost. Zeros are supplied to ",
                "vacated bits on the right. The result is placed in ",
                "register RA."
            ]
        },
        {
            "description": "Convert Declets To Binary Coded Decimal",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cdtbcd",
                    "regs": [ "RA, RS" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "", "", "", "", "", "RS", "", "", "", "", "RA", "", "", "", "", "/ / /", "", "", "", "", "282", "", "", "", "", "", "", "", "", "", "/" ],
                [ "0", "", "", "", "", "", "6", "", "", "", "", "11", "", "", "", "", "16", "", "", "", "", "21", "", "", "", "", "", "", "", "", "", "31" ]
            ],
            "code": [
                "do i = 0 to 1",
                "  n := i x 32",
                "  RAn+0:n+7 := 0 ",
                "  RAn+8:n+19 := DPD_TO_BCD( (RS)n+12:n+21 ) ",
                "  RAn+20:n+31 := DPD_TO_BCD( (RS)n+22:n+31 )"
            ],
            "body": [
                "The low-order 20 bits of each word of register RS con",
                "tain two declets which are converted to six, 4-bit BCD ",
                "fields; each set of six, 4-bit BCD fields is placed into the ",
                "low-order 24 bits of the corresponding word in RA. The ",
                "high-order 8 bits in each word of RA are set to 0."
            ]
        },
        {
            "description": "Convert Binary Coded Decimal To Declets",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "cbcdtd",
                    "regs": [ "RA, RS" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "", "", "", "", "", "RS", "", "", "", "", "RA", "", "", "", "", "/ / /", "", "", "", "", "314", "", "", "", "", "", "", "", "", "", "/" ],
                [ "0", "", "", "", "", "", "6", "", "", "", "", "11", "", "", "", "", "16", "", "", "", "", "21", "", "", "", "", "", "", "", "", "", "31" ]
            ],
            "code": [
                "do i = 0 to 1",
                "  n := i x 32",
                "  RAn+0:n+11 := 0 ",
                "  RAn+12:n+21 := BCD_TO_DPD( (RS)n+8:n+19 ) ",
                "  RAn+22:n+31 := BCD_TO_DPD( (RS)n+20:n+31 )"
            ],
            "body": [
                "The low-order 24 bits of each word of register RS con",
                "tain six, 4-bit BCD fields which are converted to two ",
                "declets; each set of two declets is placed into the ",
                "low-order 20 bits of the corresponding word in RA. The ",
                "high-order 12 bits in each word of RA are set to 0.",
                "If a 4-bit BCD field has a value greater than 9 the ",
                "results are undefined."
            ]
        },
        {
            "description": "Add and Generate Sixes",
            "form": "XO-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "addg6s",
                    "regs": [ "RT,RA,RB" ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                [ "31", "", "", "", "", "", "RT", "", "", "", "", "RA", "", "", "", "", "RB", "", "", "", "", "/", "74", "", "", "", "", "", "", "", "", "/" ],
                [ "0", "", "", "", "", "", "6", "", "", "", "", "11", "", "", "", "", "16", "", "", "", "", "21", "22", "", "", "", "", "", "", "", "", "31" ]
            ],
            "code": [
                "do i = 0 to 15",
                "dci := carry_out(RA4xi:63 + RB4xi:63)",
                "c := 4(dc0) || 4(dc1) || ... || 4(dc15)",
                "RT := (:=c) & 0x6666_6666_6666_6666"
            ],
            "body": [
                "The contents of register RA are added to the contents ",
                "of register RB. Sixteen carry bits are produced, one ",
                "for each carry out of decimal position n (bit posi",
                "tion 4xn).",
                "A doubleword is composed from the 16 carry bits, and ",
                "placed into RT. The doubleword consists of a decimal ",
                "six (0b0110) in every decimal digit position for which ",
                "the corresponding carry bit is 0, and a zero (0b0000) in ",
                "every position for which the corresponding carry bit is ",
                "1.",
                "  ",
                "",
                "  "
            ]
        },
        {
            "description": "Decimal Sixes",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "dsixes",
                    "regs": [ "RA" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "31", "///", "RA", "///", "61", "/" ],
                [ "0 ", "6 ", "11 ", "16 ", "21 ", "31" ]
            ],
            "code": [
                "c := 4(DC0) || 4(DC1) || ... || 4(DC15)",
                "RA := (:=c) & 0x6666_6666_6666_6666"
            ],
            "body": [
                "A doubleword is composed from the Decimal Carry bits ",
                "in the XER, and placed into RA. The doubleword con",
                "sists of a decimal six (0b0110) in every decimal digit ",
                "position for which the corresponding bit in XERDC is ",
                "zero, and a zero (0b0000) in every position for which ",
                "the corresponding bit in XERDC is one. Bit i of XERDC ",
                "corresponds to decimal digit position i of RA, for i = 0, ",
                "1, ..., 15.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler."
            ]
        },
        {
            "description": "Decimal Test and Clear Sign",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "dtcs.",
                    "regs": [ "RA,RS" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [
                [ "31", "RS", "RA", "///", "93", "1" ],
                [ "0", "6", "11", "16", "21", "31" ]
            ],
            "code": [
                "s := (RS)60 & ((RS)61 / (RS)62) & (RS)63",
                "if s = 1 then CR0:3 := 0b100 || XERSO",
                "              FXCC := 0b1000",
                "         else CR0:3 := 0b010 || XERSO",
                "              FXCC := 0b0100",
                "RA   := (RS)0:59 || 0b0000",
                "CA   := 0",
                "CA32 := 0"
            ],
            "body": [
                "CR0 and the FXCC are set to reflect “Less Than” if the ",
                "sign in the low-order four bits of (RS) is 0xB or 0xD, and ",
                "to reflect “Greater Than” otherwise. RA0:59 is set to ",
                "(RS)0:59. RA60:63 are set to 0. XERCA is set to 0.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler."
            ]
        },
        {
            "description": "Move From VSR Doubleword X",
            "form": "-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrd",
                    "regs": [ "RA,XS" ],
                    "release": "v2.07"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XS be the value 32×SX + S."
            ]
        },
        {
            "description": "Move From VSR Lower Doubleword X",
            "form": "-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrld",
                    "regs": [ "RA,XS" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XS be the value 32×SX + S."
            ]
        },
        {
            "description": "Move From VSR Word and Zero X",
            "form": "-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfvsrwz",
                    "regs": [ "RA,XS" ],
                    "release": "v2.07"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XS be the value 32×SX + S."
            ]
        },
        {
            "description": "Move To VSR Doubleword X for",
            "form": "m",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrd",
                    "regs": [ "XT,RA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XT be the value 32×TX + T."
            ]
        },
        {
            "description": "Move To VSR Word Algebraic X for",
            "form": "m",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwa",
                    "regs": [ "XT,RA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XT be the value 32×TX + T."
            ]
        },
        {
            "description": "Move To VSR Word and Zero X for",
            "form": "m",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrwz",
                    "regs": [ "XT,RA" ],
                    "release": "v2.07"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XT be the value 32×TX + T."
            ]
        },
        {
            "description": "Move To VSR Double Doubleword X",
            "form": "-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrdd",
                    "regs": [ "XT,RA,RB" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XT be the value 32×TX + T."
            ]
        },
        {
            "description": "Move To VSR Word & Splat X",
            "form": "-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtvsrws",
                    "regs": [ "XT,RA" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "Let XT be the value 32×TX + T."
            ]
        },
        {
            "description": "Move To Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtspr",
                    "regs": [ "SPR,RS" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "spr", "467", "/" ],
                [ "0 ", "6", "11 ", "21 ", "31" ]
            ],
            "code": [
                "n := spr5:9 || spr0:4",
                "switch (n)",
                "  case(13): see Book III",
                "  case(808, 809, 810, 811):",
                "  default:",
                "    if length(SPR(n)) = 64 then",
                "      SPR(n) := (RS)",
                "    else",
                "      SPR(n) := (RS)32:63"
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in the table below. If the SPR field ",
                "contains a value from 808 through 811, the instruction ",
                "specifies a reserved SPR, and is treated as a no-op;  ",
                "see Section1.3.3, “Reserved Fields, Reserved Values, ",
                "and Reserved SPRs”.  Otherwise, unless the SPR field ",
                "contains 13 (denoting the AMR), the contents of regis",
                "ter RS are placed into the designated Special Purpose ",
                "Register. For Special Purpose Registers that are 32 bits ",
                "long, the low-order 32 bits of RS are placed into the ",
                "SPR. ",
                "The AMR (Authority Mask Register) is used for “stor",
                "age protection.” This use, and operation of mtspr for ",
                "the AMR, are described in Book III.",
                "If execution of this instruction is attempted specifying ",
                "an SPR number that is not shown above, one of the fol",
                "lowing occurs.",
                "If an attempt is made to execute mtspr specifying a TM ",
                "SPR in other than Non-transactional state, with the ",
                "exception of TFHAR in suspended state, a TM Bad ",
                "Thing type Program interrupt is generated.",
                "A complete description of this instruction can be found ",
                "in Book III.",
                "Examples of extended mnemonics for Move To Special ",
                "Purpose Register:",
                "     ",
                "  ",
                " "
            ]
        },
        {
            "description": "Move From Special Purpose Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfspr",
                    "regs": [ "RT,SPR" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "spr", "339", "/" ],
                [ "0", "6", "11", "21", "31" ]
            ],
            "code": [
                "n := spr5:9 || spr0:4",
                "switch (n)",
                "  case(129): see Book III",
                "  case(808, 809, 810, 811):",
                "  default:",
                "    if length(SPR(n)) = 64 then",
                "      RT := SPR(n)",
                "    else",
                "      RT := 320 || SPR(n)"
            ],
            "body": [
                "The SPR field denotes a Special Purpose Register, ",
                "encoded as shown in the table below.  If the SPR field ",
                "contains 129,  the instruction references the Transac",
                "tion Failure Instruction Address Register (TFIAR)  and ",
                "the result is dependent on the privilege with which it is ",
                "executed.  See Book III.  If the SPR field contains a ",
                "value from 808 through 811, the instruction specifies a ",
                "reserved SPR, and is treated as a no-op; see ",
                "Section1.3.3, “Reserved Fields, Reserved Values, and ",
                "Reserved SPRs”.  Otherwise, the contents of the desig",
                "nated Special Purpose Register are placed into register ",
                "RT. For Special Purpose Registers that are 32 bits long, ",
                "the low-order 32 bits of RT receive the contents of the ",
                "Special Purpose Register and the high-order 32 bits of ",
                "RT are set to zero.",
                "If execution of this instruction is attempted specifying ",
                "an SPR number that is not shown above, one of the fol",
                "lowing occurs.",
                "A complete description of this instruction can be found ",
                "in Book III.",
                "Examples of extended mnemonics for Move From Spe",
                "cial Purpose Register:",
                " "
            ]
        },
        {
            "description": "Move to CR from XER Extended",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mcrxrx",
                    "regs": [ "BF" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [
                "CR4×BF+32:4×BF+35 := XEROV OV32 CA CA32"
            ],
            "body": [
                "The contents of the OV, OV32, CA, and CA32 are cop",
                "ied to Condition Register field BF."
            ]
        },
        {
            "description": "Move to CR from XER TGCC",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mcrxrt",
                    "regs": [ "BF" ],
                    "release": "PPCAS"
                }
            ],
            "layout": [

            ],
            "code": [
                "CR4´BF:4´BF+3 := 0b0 || XER41:43"
            ],
            "body": [
                "0b0 concatenated with the contents of XER41:43 is cop",
                "ied into the Condition Register field designated by BF.",
                "In tags inactive mode, this instruction is an illegal ",
                "instruction and an attempt to execute this instruction ",
                "will invoke the system illegal instruction error handler."
            ]
        },
        {
            "description": "M ove To One Condition Register Field",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtocrf",
                    "regs": [ "FXM,RS" ],
                    "release": "v2.01"
                }
            ],
            "layout": [
                [ "31", "RS", "1", "FXM", "/", "144", "/" ],
                [ "0", "6", "11", "12", "20", "21", "31" ]
            ],
            "code": [

            ],
            "body": [
                "If exactly one bit of the FXM field is set to 1, let n be the ",
                "position of that bit in the field (0 £ n £ 7). The contents ",
                "of bits 4´n+32:4´n+35 of register RS are placed into ",
                "CR field n (CR bits 4´n+32:4´n+35). Otherwise, the ",
                "contents of the Condition Register are undefined."
            ]
        },
        {
            "description": "Move To Condition Register Fields",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mtcrf",
                    "regs": [ "FXM,RS" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RS", "0", "FXM", "/", "144", "/" ],
                [ "0", "6", "11", "12", "20", "21", "31" ]
            ],
            "code": [
                "mask := 4(FXM0) || 4(FXM1) || ... 4(FXM7)",
                "CR := ((RS)32:63 & mask) | (CR & :=mask)"
            ],
            "body": [
                "The contents of bits 32:63 of register RS are placed ",
                "into the Condition Register under control of the field ",
                "mask specified by FXM. The field mask identifies the ",
                "4-bit fields affected. Let i be an integer in the range 0-7. ",
                "If FXMi=1 then CR field i (CR bits 4´i+32:4´i+35) is set ",
                "to the contents of the corresponding field of the ",
                "low-order 32 bits of RS.",
                "Example of extended mnemonics for Move To Condi",
                "tion Register Fields:"
            ]
        },
        {
            "description": "Move From One Condition Register Field",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfocrf",
                    "regs": [ "RT,FXM" ],
                    "release": "v2.01"
                }
            ],
            "layout": [
                [ "31", "RT", "1", "FXM", "/", "19", "/" ],
                [ "0", "6", "11", "12", "20", "21", "31" ]
            ],
            "code": [

            ],
            "body": [
                "If exactly one bit of the FXM field is set to 1, let n be ",
                "the position of that bit in the field (0 £ n £ 7). The ",
                "contents of CR field n (CR bits 4´n+32:4´n+35) are ",
                "placed into bits 4´n+32:4´n+35 of register RT, and the ",
                "contents of the remaining bits of register RT are ",
                "undefined. Otherwise, the contents of register RT are ",
                "undefined.",
                "  "
            ]
        },
        {
            "description": "Move From Condition Register",
            "form": "XFX-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "mfcr",
                    "regs": [ "RT" ],
                    "release": "P1"
                }
            ],
            "layout": [
                [ "31", "RT", "0", "///", "", "19", "/" ],
                [ "0", "6", "11", "12", "", "21", "31" ]
            ],
            "code": [

            ],
            "body": [
                "   RT ¬ 320 || CR"
            ]
        },
        {
            "description": "Set Boolean",
            "form": "X-form",
            "category": "Fixed-Point Facility",
            "mnemonics": [
                {
                    "mnemonic": "setb",
                    "regs": [ "RT,BFA" ],
                    "release": "v3.0"
                }
            ],
            "layout": [

            ],
            "code": [

            ],
            "body": [
                "If the contents of bit 0 of CR field BFA are equal to 0b1, ",
                "the contents of register RT are set to ",
                "0xFFFF_FFFF_FFFF_FFFF."
            ]
        }
    ],
    "chapters": [
        {
            "name": "Fixed-Point Facility",
            "chapters": []
        }
    ]
}
